/* automatically generated by rust-bindgen 0.60.1 */
//!
//! Bindgen generated bindings
//!
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(improper_ctypes)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::redundant_static_lifetimes)]

//include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &[u8; 1usize] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING: u32 = 32;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const LIBXML_DOTTED_VERSION: &[u8; 7usize] = b"2.9.12\0";
pub const LIBXML_VERSION: u32 = 209012;
pub const LIBXML_VERSION_STRING: &[u8; 7usize] = b"209012\0";
pub const LIBXML_VERSION_EXTRA: &[u8; 1usize] = b"\0";
pub const LIBXML_MODULE_EXTENSION: &[u8; 5usize] = b".dll\0";
pub const BASE_BUFFER_SIZE: u32 = 4096;
pub const XML_DEFAULT_VERSION: &[u8; 4usize] = b"1.0\0";
pub const XML_DETECT_IDS: u32 = 2;
pub const XML_COMPLETE_ATTRS: u32 = 4;
pub const XML_SKIP_IDS: u32 = 8;
pub const XML_SAX2_MAGIC: u32 = 3740122799;
pub const _LIBICONV_VERSION: u32 = 272;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _UPPER: u32 = 1;
pub const _LOWER: u32 = 2;
pub const _DIGIT: u32 = 4;
pub const _SPACE: u32 = 8;
pub const _PUNCT: u32 = 16;
pub const _CONTROL: u32 = 32;
pub const _BLANK: u32 = 64;
pub const _HEX: u32 = 128;
pub const _LEADBYTE: u32 = 32768;
pub const _ALPHA: u32 = 259;
pub const _SH_DENYRW: u32 = 16;
pub const _SH_DENYWR: u32 = 32;
pub const _SH_DENYRD: u32 = 48;
pub const _SH_DENYNO: u32 = 64;
pub const _SH_SECURE: u32 = 128;
pub const SH_DENYRW: u32 = 16;
pub const SH_DENYWR: u32 = 32;
pub const SH_DENYRD: u32 = 48;
pub const SH_DENYNO: u32 = 64;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const _S_IFMT: u32 = 61440;
pub const _S_IFDIR: u32 = 16384;
pub const _S_IFCHR: u32 = 8192;
pub const _S_IFIFO: u32 = 4096;
pub const _S_IFREG: u32 = 32768;
pub const _S_IREAD: u32 = 256;
pub const _S_IWRITE: u32 = 128;
pub const _S_IEXEC: u32 = 64;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFREG: u32 = 32768;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const ICONV_TRIVIALP: u32 = 0;
pub const ICONV_GET_TRANSLITERATE: u32 = 1;
pub const ICONV_SET_TRANSLITERATE: u32 = 2;
pub const ICONV_GET_DISCARD_ILSEQ: u32 = 3;
pub const ICONV_SET_DISCARD_ILSEQ: u32 = 4;
pub const ICONV_SET_HOOKS: u32 = 5;
pub const ICONV_SET_FALLBACKS: u32 = 6;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const XMLSEC_VERSION: &[u8; 7usize] = b"1.2.32\0";
pub const XMLSEC_VERSION_MAJOR: u32 = 1;
pub const XMLSEC_VERSION_MINOR: u32 = 2;
pub const XMLSEC_VERSION_SUBMINOR: u32 = 32;
pub const XMLSEC_VERSION_INFO: &[u8; 7usize] = b"3:32:2\0";
pub const xmlSecKeyDataUsageUnknown: u32 = 0;
pub const xmlSecKeyDataUsageKeyInfoNodeRead: u32 = 1;
pub const xmlSecKeyDataUsageKeyInfoNodeWrite: u32 = 2;
pub const xmlSecKeyDataUsageKeyValueNodeRead: u32 = 4;
pub const xmlSecKeyDataUsageKeyValueNodeWrite: u32 = 8;
pub const xmlSecKeyDataUsageRetrievalMethodNodeXml: u32 = 16;
pub const xmlSecKeyDataUsageRetrievalMethodNodeBin: u32 = 32;
pub const xmlSecKeyDataUsageAny: u32 = 1048575;
pub const xmlSecKeyDataUsageKeyInfoNode: u32 = 3;
pub const xmlSecKeyDataUsageKeyValueNode: u32 = 12;
pub const xmlSecKeyDataUsageRetrievalMethodNode: u32 = 48;
pub const xmlSecKeyDataTypeUnknown: u32 = 0;
pub const xmlSecKeyDataTypeNone: u32 = 0;
pub const xmlSecKeyDataTypePublic: u32 = 1;
pub const xmlSecKeyDataTypePrivate: u32 = 2;
pub const xmlSecKeyDataTypeSymmetric: u32 = 4;
pub const xmlSecKeyDataTypeSession: u32 = 8;
pub const xmlSecKeyDataTypePermanent: u32 = 16;
pub const xmlSecKeyDataTypeTrusted: u32 = 256;
pub const xmlSecKeyDataTypeAny: u32 = 65535;
pub const TIME_UTC: u32 = 1;
pub const xmlSecKeyUsageSign: u32 = 1;
pub const xmlSecKeyUsageVerify: u32 = 2;
pub const xmlSecKeyUsageEncrypt: u32 = 4;
pub const xmlSecKeyUsageDecrypt: u32 = 8;
pub const xmlSecKeyUsageKeyExchange: u32 = 16;
pub const xmlSecKeyUsageAny: u32 = 4294967295;
pub const XML_XPATH_CHECKNS: u32 = 1;
pub const XML_XPATH_NOVAR: u32 = 2;
pub const XMLSEC_TRANSFORM_BINARY_CHUNK: u32 = 1024;
pub const xmlSecTransformUriTypeNone: u32 = 0;
pub const xmlSecTransformUriTypeEmpty: u32 = 1;
pub const xmlSecTransformUriTypeSameDocument: u32 = 2;
pub const xmlSecTransformUriTypeLocal: u32 = 4;
pub const xmlSecTransformUriTypeRemote: u32 = 8;
pub const xmlSecTransformUriTypeAny: u32 = 65535;
pub const xmlSecTransformDataTypeUnknown: u32 = 0;
pub const xmlSecTransformDataTypeBin: u32 = 1;
pub const xmlSecTransformDataTypeXml: u32 = 2;
pub const xmlSecTransformUsageUnknown: u32 = 0;
pub const xmlSecTransformUsageDSigTransform: u32 = 1;
pub const xmlSecTransformUsageC14NMethod: u32 = 2;
pub const xmlSecTransformUsageDigestMethod: u32 = 4;
pub const xmlSecTransformUsageSignatureMethod: u32 = 8;
pub const xmlSecTransformUsageEncryptionMethod: u32 = 16;
pub const xmlSecTransformUsageAny: u32 = 65535;
pub const XMLSEC_TRANSFORMCTX_FLAGS_USE_VISA3D_HACK: u32 = 1;
pub const XMLSEC_KEYINFO_FLAGS_DONT_STOP_ON_KEY_FOUND: u32 = 1;
pub const XMLSEC_KEYINFO_FLAGS_STOP_ON_UNKNOWN_CHILD: u32 = 2;
pub const XMLSEC_KEYINFO_FLAGS_KEYNAME_STOP_ON_UNKNOWN: u32 = 4;
pub const XMLSEC_KEYINFO_FLAGS_KEYVALUE_STOP_ON_UNKNOWN_CHILD: u32 = 8;
pub const XMLSEC_KEYINFO_FLAGS_RETRMETHOD_STOP_ON_UNKNOWN_HREF: u32 = 16;
pub const XMLSEC_KEYINFO_FLAGS_RETRMETHOD_STOP_ON_MISMATCH_HREF: u32 = 32;
pub const XMLSEC_KEYINFO_FLAGS_X509DATA_STOP_ON_UNKNOWN_CHILD: u32 = 256;
pub const XMLSEC_KEYINFO_FLAGS_X509DATA_DONT_VERIFY_CERTS: u32 = 512;
pub const XMLSEC_KEYINFO_FLAGS_X509DATA_STOP_ON_UNKNOWN_CERT: u32 = 1024;
pub const XMLSEC_KEYINFO_FLAGS_X509DATA_STOP_ON_INVALID_CERT: u32 = 2048;
pub const XMLSEC_KEYINFO_FLAGS_ENCKEY_DONT_STOP_ON_FAILED_DECRYPTION: u32 = 4096;
pub const XMLSEC_KEYINFO_FLAGS_STOP_ON_EMPTY_NODE: u32 = 8192;
pub const XMLSEC_KEYINFO_FLAGS_X509DATA_SKIP_STRICT_CHECKS: u32 = 16384;
pub const XMLSEC_DSIG_FLAGS_IGNORE_MANIFESTS: u32 = 1;
pub const XMLSEC_DSIG_FLAGS_STORE_SIGNEDINFO_REFERENCES: u32 = 2;
pub const XMLSEC_DSIG_FLAGS_STORE_MANIFEST_REFERENCES: u32 = 4;
pub const XMLSEC_DSIG_FLAGS_STORE_SIGNATURE: u32 = 8;
pub const XMLSEC_DSIG_FLAGS_USE_VISA3D_HACK: u32 = 16;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type size_t = ::std::os::raw::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn();
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    );
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    fn test_field__locale_pctype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__crt_locale_data_public>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__crt_locale_data_public),
                "::",
                stringify!(_locale_pctype)
            )
        );
    }
    test_field__locale_pctype();
    fn test_field__locale_mb_cur_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__crt_locale_data_public>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__crt_locale_data_public),
                "::",
                stringify!(_locale_mb_cur_max)
            )
        );
    }
    test_field__locale_mb_cur_max();
    fn test_field__locale_lc_codepage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__crt_locale_data_public>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__crt_locale_data_public),
                "::",
                stringify!(_locale_lc_codepage)
            )
        );
    }
    test_field__locale_lc_codepage();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    fn test_field_locinfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__crt_locale_pointers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__crt_locale_pointers),
                "::",
                stringify!(locinfo)
            )
        );
    }
    test_field_locinfo();
    fn test_field_mbcinfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__crt_locale_pointers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__crt_locale_pointers),
                "::",
                stringify!(mbcinfo)
            )
        );
    }
    test_field_mbcinfo();
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    fn test_field__Wchar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Mbstatet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_Mbstatet),
                "::",
                stringify!(_Wchar)
            )
        );
    }
    test_field__Wchar();
    fn test_field__Byte() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Mbstatet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_Mbstatet),
                "::",
                stringify!(_Byte)
            )
        );
    }
    test_field__Byte();
    fn test_field__State() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Mbstatet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_Mbstatet),
                "::",
                stringify!(_State)
            )
        );
    }
    test_field__State();
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = size_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__iobuf() {
    assert_eq!(
        ::std::mem::size_of::<_iobuf>(),
        8usize,
        concat!("Size of: ", stringify!(_iobuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_iobuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_iobuf))
    );
    fn test_field__Placeholder() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_iobuf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._Placeholder) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_iobuf),
                "::",
                stringify!(_Placeholder)
            )
        );
    }
    test_field__Placeholder();
}
pub type FILE = _iobuf;
extern "C" {
    pub fn __acrt_iob_func(_Ix: ::std::os::raw::c_uint) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fgetws(
        _Buffer: *mut wchar_t,
        _BufferCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(_Buffer: *const wchar_t, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getws_s(_Buffer: *mut wchar_t, _BufferCount: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn putwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn _putws(_Buffer: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_FileName: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfreopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfsopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wpopen(_Command: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_FileName: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const wchar_t, _FilePrefix: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtmpnam_s(_Buffer: *mut wchar_t, _BufferCount: size_t) -> errno_t;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _putwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn __stdio_common_vfwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _MaxCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const wchar_t,
        _BufferCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut ::std::os::raw::c_char,
        _Pointer: *mut *mut *mut ::std::os::raw::c_char,
        _Count: *mut *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
extern "C" {
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn fread_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: size_t,
        _ElementSize: size_t,
        _ElementCount: size_t,
        _Stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn gets_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _Size: rsize_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
extern "C" {
    pub fn tmpnam_s(_Buffer: *mut ::std::os::raw::c_char, _Size: rsize_t) -> errno_t;
}
extern "C" {
    pub fn clearerr(_Stream: *mut FILE);
}
extern "C" {
    pub fn fclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn feof(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(
        _Buffer: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn freopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fsopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fwrite(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn getc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrorMessage: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _pclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _popen(
        _Command: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(_Buffer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putw(_Word: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        _OldFileName: *const ::std::os::raw::c_char,
        _NewFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(_Stream: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Maximum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setvbuf(
        _Stream: *mut FILE,
        _Buffer: *mut ::std::os::raw::c_char,
        _Mode: ::std::os::raw::c_int,
        _Size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam(
        _DirectoryName: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _fclose_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fflush_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_nolock(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: size_t,
        _ElementCount: size_t,
        _Stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fread_nolock_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: size_t,
        _ElementSize: size_t,
        _ElementCount: size_t,
        _Stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fseek_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _fwrite_nolock(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: size_t,
        _ElementCount: size_t,
        _Stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _getc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ungetc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__commode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _MaxCount: size_t,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        _Directory: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Format: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(_Ch: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlCheckVersion(version: ::std::os::raw::c_int);
}
#[doc = " xmlChar:"]
#[doc = ""]
#[doc = " This is a basic byte in an UTF-8 encoded string."]
#[doc = " It's unsigned allowing to pinpoint case where char * are assigned"]
#[doc = " to xmlChar * (possibly making serialization back impossible)."]
pub type xmlChar = ::std::os::raw::c_uchar;
extern "C" {
    pub fn xmlStrdup(cur: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlStrndup(cur: *const xmlChar, len: ::std::os::raw::c_int) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlCharStrndup(
        cur: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlCharStrdup(cur: *const ::std::os::raw::c_char) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlStrsub(
        str_: *const xmlChar,
        start: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    ) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlStrchr(str_: *const xmlChar, val: xmlChar) -> *const xmlChar;
}
extern "C" {
    pub fn xmlStrstr(str_: *const xmlChar, val: *const xmlChar) -> *const xmlChar;
}
extern "C" {
    pub fn xmlStrcasestr(str_: *const xmlChar, val: *const xmlChar) -> *const xmlChar;
}
extern "C" {
    pub fn xmlStrcmp(str1: *const xmlChar, str2: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlStrncmp(
        str1: *const xmlChar,
        str2: *const xmlChar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlStrcasecmp(str1: *const xmlChar, str2: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlStrncasecmp(
        str1: *const xmlChar,
        str2: *const xmlChar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlStrEqual(str1: *const xmlChar, str2: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlStrQEqual(
        pref: *const xmlChar,
        name: *const xmlChar,
        str_: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlStrlen(str_: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlStrcat(cur: *mut xmlChar, add: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlStrncat(
        cur: *mut xmlChar,
        add: *const xmlChar,
        len: ::std::os::raw::c_int,
    ) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlStrncatNew(
        str1: *const xmlChar,
        str2: *const xmlChar,
        len: ::std::os::raw::c_int,
    ) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlStrPrintf(
        buf: *mut xmlChar,
        len: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlStrVPrintf(
        buf: *mut xmlChar,
        len: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlGetUTF8Char(
        utf: *const ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlCheckUTF8(utf: *const ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlUTF8Strsize(utf: *const xmlChar, len: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlUTF8Strndup(utf: *const xmlChar, len: ::std::os::raw::c_int) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlUTF8Strpos(utf: *const xmlChar, pos: ::std::os::raw::c_int) -> *const xmlChar;
}
extern "C" {
    pub fn xmlUTF8Strloc(utf: *const xmlChar, utfchar: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlUTF8Strsub(
        utf: *const xmlChar,
        start: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    ) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlUTF8Strlen(utf: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlUTF8Size(utf: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlUTF8Charcmp(utf1: *const xmlChar, utf2: *const xmlChar) -> ::std::os::raw::c_int;
}
pub type xmlParserInputBuffer = _xmlParserInputBuffer;
pub type xmlParserInputBufferPtr = *mut xmlParserInputBuffer;
pub type xmlOutputBuffer = _xmlOutputBuffer;
pub type xmlOutputBufferPtr = *mut xmlOutputBuffer;
pub type xmlParserInput = _xmlParserInput;
pub type xmlParserInputPtr = *mut xmlParserInput;
#[doc = " xmlParserCtxt:"]
#[doc = ""]
#[doc = " The parser context."]
#[doc = " NOTE This doesn't completely define the parser state, the (current ?)"]
#[doc = "      design of the parser uses recursive function calls since this allow"]
#[doc = "      and easy mapping from the production rules of the specification"]
#[doc = "      to the actual code. The drawback is that the actual function call"]
#[doc = "      also reflect the parser state. However most of the parsing routines"]
#[doc = "      takes as the only argument the parser context pointer, so migrating"]
#[doc = "      to a state based parser for progressive parsing shouldn't be too hard."]
pub type xmlParserCtxt = _xmlParserCtxt;
pub type xmlParserCtxtPtr = *mut xmlParserCtxt;
#[doc = " xmlSAXLocator:"]
#[doc = ""]
#[doc = " A SAX Locator."]
pub type xmlSAXLocator = _xmlSAXLocator;
pub type xmlSAXLocatorPtr = *mut xmlSAXLocator;
pub type xmlSAXHandler = _xmlSAXHandler;
pub type xmlSAXHandlerPtr = *mut xmlSAXHandler;
pub type xmlEntity = _xmlEntity;
pub type xmlEntityPtr = *mut xmlEntity;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_DOUBLEIT: xmlBufferAllocationScheme = 0;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_EXACT: xmlBufferAllocationScheme = 1;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_IMMUTABLE: xmlBufferAllocationScheme = 2;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_IO: xmlBufferAllocationScheme = 3;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_HYBRID: xmlBufferAllocationScheme = 4;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_BOUNDED: xmlBufferAllocationScheme = 5;
#[doc = " xmlBufferAllocationScheme:"]
#[doc = ""]
#[doc = " A buffer allocation scheme can be defined to either match exactly the"]
#[doc = " need or double it's allocated size each time it is found too small."]
pub type xmlBufferAllocationScheme = ::std::os::raw::c_int;
#[doc = " xmlBuffer:"]
#[doc = ""]
#[doc = " A buffer structure, this old construct is limited to 2GB and"]
#[doc = " is being deprecated, use API with xmlBuf instead"]
pub type xmlBuffer = _xmlBuffer;
pub type xmlBufferPtr = *mut xmlBuffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlBuffer {
    pub content: *mut xmlChar,
    pub use_: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
    pub alloc: xmlBufferAllocationScheme,
    pub contentIO: *mut xmlChar,
}
#[test]
fn bindgen_test_layout__xmlBuffer() {
    assert_eq!(
        ::std::mem::size_of::<_xmlBuffer>(),
        32usize,
        concat!("Size of: ", stringify!(_xmlBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlBuffer))
    );
    fn test_field_content() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlBuffer),
                "::",
                stringify!(content)
            )
        );
    }
    test_field_content();
    fn test_field_use() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).use_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlBuffer),
                "::",
                stringify!(use_)
            )
        );
    }
    test_field_use();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlBuffer),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_alloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlBuffer),
                "::",
                stringify!(alloc)
            )
        );
    }
    test_field_alloc();
    fn test_field_contentIO() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).contentIO) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlBuffer),
                "::",
                stringify!(contentIO)
            )
        );
    }
    test_field_contentIO();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlBuf {
    _unused: [u8; 0],
}
#[doc = " xmlBuf:"]
#[doc = ""]
#[doc = " A buffer structure, new one, the actual structure internals are not public"]
pub type xmlBuf = _xmlBuf;
#[doc = " xmlBufPtr:"]
#[doc = ""]
#[doc = " A pointer to a buffer structure, the actual structure internals are not"]
#[doc = " public"]
pub type xmlBufPtr = *mut xmlBuf;
extern "C" {
    pub fn xmlBufContent(buf: *const xmlBuf) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlBufEnd(buf: xmlBufPtr) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlBufUse(buf: xmlBufPtr) -> size_t;
}
extern "C" {
    pub fn xmlBufShrink(buf: xmlBufPtr, len: size_t) -> size_t;
}
pub const xmlElementType_XML_ELEMENT_NODE: xmlElementType = 1;
pub const xmlElementType_XML_ATTRIBUTE_NODE: xmlElementType = 2;
pub const xmlElementType_XML_TEXT_NODE: xmlElementType = 3;
pub const xmlElementType_XML_CDATA_SECTION_NODE: xmlElementType = 4;
pub const xmlElementType_XML_ENTITY_REF_NODE: xmlElementType = 5;
pub const xmlElementType_XML_ENTITY_NODE: xmlElementType = 6;
pub const xmlElementType_XML_PI_NODE: xmlElementType = 7;
pub const xmlElementType_XML_COMMENT_NODE: xmlElementType = 8;
pub const xmlElementType_XML_DOCUMENT_NODE: xmlElementType = 9;
pub const xmlElementType_XML_DOCUMENT_TYPE_NODE: xmlElementType = 10;
pub const xmlElementType_XML_DOCUMENT_FRAG_NODE: xmlElementType = 11;
pub const xmlElementType_XML_NOTATION_NODE: xmlElementType = 12;
pub const xmlElementType_XML_HTML_DOCUMENT_NODE: xmlElementType = 13;
pub const xmlElementType_XML_DTD_NODE: xmlElementType = 14;
pub const xmlElementType_XML_ELEMENT_DECL: xmlElementType = 15;
pub const xmlElementType_XML_ATTRIBUTE_DECL: xmlElementType = 16;
pub const xmlElementType_XML_ENTITY_DECL: xmlElementType = 17;
pub const xmlElementType_XML_NAMESPACE_DECL: xmlElementType = 18;
pub const xmlElementType_XML_XINCLUDE_START: xmlElementType = 19;
pub const xmlElementType_XML_XINCLUDE_END: xmlElementType = 20;
pub const xmlElementType_XML_DOCB_DOCUMENT_NODE: xmlElementType = 21;
pub type xmlElementType = ::std::os::raw::c_int;
#[doc = " xmlNotation:"]
#[doc = ""]
#[doc = " A DTD Notation definition."]
pub type xmlNotation = _xmlNotation;
pub type xmlNotationPtr = *mut xmlNotation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlNotation {
    pub name: *const xmlChar,
    pub PublicID: *const xmlChar,
    pub SystemID: *const xmlChar,
}
#[test]
fn bindgen_test_layout__xmlNotation() {
    assert_eq!(
        ::std::mem::size_of::<_xmlNotation>(),
        24usize,
        concat!("Size of: ", stringify!(_xmlNotation))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlNotation>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlNotation))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNotation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNotation),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_PublicID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNotation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).PublicID) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNotation),
                "::",
                stringify!(PublicID)
            )
        );
    }
    test_field_PublicID();
    fn test_field_SystemID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNotation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SystemID) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNotation),
                "::",
                stringify!(SystemID)
            )
        );
    }
    test_field_SystemID();
}
pub const xmlAttributeType_XML_ATTRIBUTE_CDATA: xmlAttributeType = 1;
pub const xmlAttributeType_XML_ATTRIBUTE_ID: xmlAttributeType = 2;
pub const xmlAttributeType_XML_ATTRIBUTE_IDREF: xmlAttributeType = 3;
pub const xmlAttributeType_XML_ATTRIBUTE_IDREFS: xmlAttributeType = 4;
pub const xmlAttributeType_XML_ATTRIBUTE_ENTITY: xmlAttributeType = 5;
pub const xmlAttributeType_XML_ATTRIBUTE_ENTITIES: xmlAttributeType = 6;
pub const xmlAttributeType_XML_ATTRIBUTE_NMTOKEN: xmlAttributeType = 7;
pub const xmlAttributeType_XML_ATTRIBUTE_NMTOKENS: xmlAttributeType = 8;
pub const xmlAttributeType_XML_ATTRIBUTE_ENUMERATION: xmlAttributeType = 9;
pub const xmlAttributeType_XML_ATTRIBUTE_NOTATION: xmlAttributeType = 10;
#[doc = " xmlAttributeType:"]
#[doc = ""]
#[doc = " A DTD Attribute type definition."]
pub type xmlAttributeType = ::std::os::raw::c_int;
pub const xmlAttributeDefault_XML_ATTRIBUTE_NONE: xmlAttributeDefault = 1;
pub const xmlAttributeDefault_XML_ATTRIBUTE_REQUIRED: xmlAttributeDefault = 2;
pub const xmlAttributeDefault_XML_ATTRIBUTE_IMPLIED: xmlAttributeDefault = 3;
pub const xmlAttributeDefault_XML_ATTRIBUTE_FIXED: xmlAttributeDefault = 4;
#[doc = " xmlAttributeDefault:"]
#[doc = ""]
#[doc = " A DTD Attribute default definition."]
pub type xmlAttributeDefault = ::std::os::raw::c_int;
#[doc = " xmlEnumeration:"]
#[doc = ""]
#[doc = " List structure used when there is an enumeration in DTDs."]
pub type xmlEnumeration = _xmlEnumeration;
pub type xmlEnumerationPtr = *mut xmlEnumeration;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlEnumeration {
    pub next: *mut _xmlEnumeration,
    pub name: *const xmlChar,
}
#[test]
fn bindgen_test_layout__xmlEnumeration() {
    assert_eq!(
        ::std::mem::size_of::<_xmlEnumeration>(),
        16usize,
        concat!("Size of: ", stringify!(_xmlEnumeration))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlEnumeration>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlEnumeration))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEnumeration>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEnumeration),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEnumeration>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEnumeration),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[doc = " xmlAttribute:"]
#[doc = ""]
#[doc = " An Attribute declaration in a DTD."]
pub type xmlAttribute = _xmlAttribute;
pub type xmlAttributePtr = *mut xmlAttribute;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlAttribute {
    pub _private: *mut ::std::os::raw::c_void,
    pub type_: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub nexth: *mut _xmlAttribute,
    pub atype: xmlAttributeType,
    pub def: xmlAttributeDefault,
    pub defaultValue: *const xmlChar,
    pub tree: xmlEnumerationPtr,
    pub prefix: *const xmlChar,
    pub elem: *const xmlChar,
}
#[test]
fn bindgen_test_layout__xmlAttribute() {
    assert_eq!(
        ::std::mem::size_of::<_xmlAttribute>(),
        120usize,
        concat!("Size of: ", stringify!(_xmlAttribute))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlAttribute>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlAttribute))
    );
    fn test_field__private() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._private) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(_private)
            )
        );
    }
    test_field__private();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_children() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(children)
            )
        );
    }
    test_field_children();
    fn test_field_last() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(last)
            )
        );
    }
    test_field_last();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_doc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(doc)
            )
        );
    }
    test_field_doc();
    fn test_field_nexth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nexth) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(nexth)
            )
        );
    }
    test_field_nexth();
    fn test_field_atype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atype) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(atype)
            )
        );
    }
    test_field_atype();
    fn test_field_def() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).def) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(def)
            )
        );
    }
    test_field_def();
    fn test_field_defaultValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defaultValue) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(defaultValue)
            )
        );
    }
    test_field_defaultValue();
    fn test_field_tree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tree) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(tree)
            )
        );
    }
    test_field_tree();
    fn test_field_prefix() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(prefix)
            )
        );
    }
    test_field_prefix();
    fn test_field_elem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttribute>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).elem) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttribute),
                "::",
                stringify!(elem)
            )
        );
    }
    test_field_elem();
}
pub const xmlElementContentType_XML_ELEMENT_CONTENT_PCDATA: xmlElementContentType = 1;
pub const xmlElementContentType_XML_ELEMENT_CONTENT_ELEMENT: xmlElementContentType = 2;
pub const xmlElementContentType_XML_ELEMENT_CONTENT_SEQ: xmlElementContentType = 3;
pub const xmlElementContentType_XML_ELEMENT_CONTENT_OR: xmlElementContentType = 4;
#[doc = " xmlElementContentType:"]
#[doc = ""]
#[doc = " Possible definitions of element content types."]
pub type xmlElementContentType = ::std::os::raw::c_int;
pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_ONCE: xmlElementContentOccur = 1;
pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_OPT: xmlElementContentOccur = 2;
pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_MULT: xmlElementContentOccur = 3;
pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_PLUS: xmlElementContentOccur = 4;
#[doc = " xmlElementContentOccur:"]
#[doc = ""]
#[doc = " Possible definitions of element content occurrences."]
pub type xmlElementContentOccur = ::std::os::raw::c_int;
#[doc = " xmlElementContent:"]
#[doc = ""]
#[doc = " An XML Element content as stored after parsing an element definition"]
#[doc = " in a DTD."]
pub type xmlElementContent = _xmlElementContent;
pub type xmlElementContentPtr = *mut xmlElementContent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlElementContent {
    pub type_: xmlElementContentType,
    pub ocur: xmlElementContentOccur,
    pub name: *const xmlChar,
    pub c1: *mut _xmlElementContent,
    pub c2: *mut _xmlElementContent,
    pub parent: *mut _xmlElementContent,
    pub prefix: *const xmlChar,
}
#[test]
fn bindgen_test_layout__xmlElementContent() {
    assert_eq!(
        ::std::mem::size_of::<_xmlElementContent>(),
        48usize,
        concat!("Size of: ", stringify!(_xmlElementContent))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlElementContent>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlElementContent))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElementContent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElementContent),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_ocur() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElementContent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ocur) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElementContent),
                "::",
                stringify!(ocur)
            )
        );
    }
    test_field_ocur();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElementContent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElementContent),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_c1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElementContent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c1) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElementContent),
                "::",
                stringify!(c1)
            )
        );
    }
    test_field_c1();
    fn test_field_c2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElementContent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c2) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElementContent),
                "::",
                stringify!(c2)
            )
        );
    }
    test_field_c2();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElementContent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElementContent),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_prefix() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElementContent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElementContent),
                "::",
                stringify!(prefix)
            )
        );
    }
    test_field_prefix();
}
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_UNDEFINED: xmlElementTypeVal = 0;
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_EMPTY: xmlElementTypeVal = 1;
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_ANY: xmlElementTypeVal = 2;
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_MIXED: xmlElementTypeVal = 3;
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_ELEMENT: xmlElementTypeVal = 4;
#[doc = " xmlElementTypeVal:"]
#[doc = ""]
#[doc = " The different possibilities for an element content type."]
pub type xmlElementTypeVal = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRegexp {
    _unused: [u8; 0],
}
#[doc = " xmlRegexpPtr:"]
#[doc = ""]
#[doc = " A libxml regular expression, they can actually be far more complex"]
#[doc = " thank the POSIX regex expressions."]
pub type xmlRegexp = _xmlRegexp;
pub type xmlRegexpPtr = *mut xmlRegexp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRegExecCtxt {
    _unused: [u8; 0],
}
#[doc = " xmlRegExecCtxtPtr:"]
#[doc = ""]
#[doc = " A libxml progressive regular expression evaluation context"]
pub type xmlRegExecCtxt = _xmlRegExecCtxt;
pub type xmlRegExecCtxtPtr = *mut xmlRegExecCtxt;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __threadid() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __threadhandle() -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlDict {
    _unused: [u8; 0],
}
pub type xmlDict = _xmlDict;
pub type xmlDictPtr = *mut xmlDict;
extern "C" {
    pub fn xmlInitializeDict() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlDictCreate() -> xmlDictPtr;
}
extern "C" {
    pub fn xmlDictSetLimit(dict: xmlDictPtr, limit: size_t) -> size_t;
}
extern "C" {
    pub fn xmlDictGetUsage(dict: xmlDictPtr) -> size_t;
}
extern "C" {
    pub fn xmlDictCreateSub(sub: xmlDictPtr) -> xmlDictPtr;
}
extern "C" {
    pub fn xmlDictReference(dict: xmlDictPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlDictFree(dict: xmlDictPtr);
}
extern "C" {
    pub fn xmlDictLookup(
        dict: xmlDictPtr,
        name: *const xmlChar,
        len: ::std::os::raw::c_int,
    ) -> *const xmlChar;
}
extern "C" {
    pub fn xmlDictExists(
        dict: xmlDictPtr,
        name: *const xmlChar,
        len: ::std::os::raw::c_int,
    ) -> *const xmlChar;
}
extern "C" {
    pub fn xmlDictQLookup(
        dict: xmlDictPtr,
        prefix: *const xmlChar,
        name: *const xmlChar,
    ) -> *const xmlChar;
}
extern "C" {
    pub fn xmlDictOwns(dict: xmlDictPtr, str_: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlDictSize(dict: xmlDictPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlDictCleanup();
}
extern "C" {
    pub fn xmlRegexpCompile(regexp: *const xmlChar) -> xmlRegexpPtr;
}
extern "C" {
    pub fn xmlRegFreeRegexp(regexp: xmlRegexpPtr);
}
extern "C" {
    pub fn xmlRegexpExec(comp: xmlRegexpPtr, value: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlRegexpPrint(output: *mut FILE, regexp: xmlRegexpPtr);
}
extern "C" {
    pub fn xmlRegexpIsDeterminist(comp: xmlRegexpPtr) -> ::std::os::raw::c_int;
}
#[doc = " xmlRegExecCallbacks:"]
#[doc = " @exec: the regular expression context"]
#[doc = " @token: the current token string"]
#[doc = " @transdata: transition data"]
#[doc = " @inputdata: input data"]
#[doc = ""]
#[doc = " Callback function when doing a transition in the automata"]
pub type xmlRegExecCallbacks = ::std::option::Option<
    unsafe extern "C" fn(
        exec: xmlRegExecCtxtPtr,
        token: *const xmlChar,
        transdata: *mut ::std::os::raw::c_void,
        inputdata: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn xmlRegNewExecCtxt(
        comp: xmlRegexpPtr,
        callback: xmlRegExecCallbacks,
        data: *mut ::std::os::raw::c_void,
    ) -> xmlRegExecCtxtPtr;
}
extern "C" {
    pub fn xmlRegFreeExecCtxt(exec: xmlRegExecCtxtPtr);
}
extern "C" {
    pub fn xmlRegExecPushString(
        exec: xmlRegExecCtxtPtr,
        value: *const xmlChar,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlRegExecPushString2(
        exec: xmlRegExecCtxtPtr,
        value: *const xmlChar,
        value2: *const xmlChar,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlRegExecNextValues(
        exec: xmlRegExecCtxtPtr,
        nbval: *mut ::std::os::raw::c_int,
        nbneg: *mut ::std::os::raw::c_int,
        values: *mut *mut xmlChar,
        terminal: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlRegExecErrInfo(
        exec: xmlRegExecCtxtPtr,
        string: *mut *const xmlChar,
        nbval: *mut ::std::os::raw::c_int,
        nbneg: *mut ::std::os::raw::c_int,
        values: *mut *mut xmlChar,
        terminal: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " xmlElement:"]
#[doc = ""]
#[doc = " An XML Element declaration from a DTD."]
pub type xmlElement = _xmlElement;
pub type xmlElementPtr = *mut xmlElement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlElement {
    pub _private: *mut ::std::os::raw::c_void,
    pub type_: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub etype: xmlElementTypeVal,
    pub content: xmlElementContentPtr,
    pub attributes: xmlAttributePtr,
    pub prefix: *const xmlChar,
    pub contModel: xmlRegexpPtr,
}
#[test]
fn bindgen_test_layout__xmlElement() {
    assert_eq!(
        ::std::mem::size_of::<_xmlElement>(),
        112usize,
        concat!("Size of: ", stringify!(_xmlElement))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlElement>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlElement))
    );
    fn test_field__private() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._private) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElement),
                "::",
                stringify!(_private)
            )
        );
    }
    test_field__private();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElement),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElement),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_children() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElement),
                "::",
                stringify!(children)
            )
        );
    }
    test_field_children();
    fn test_field_last() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElement),
                "::",
                stringify!(last)
            )
        );
    }
    test_field_last();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElement),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElement),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElement),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_doc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElement),
                "::",
                stringify!(doc)
            )
        );
    }
    test_field_doc();
    fn test_field_etype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).etype) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElement),
                "::",
                stringify!(etype)
            )
        );
    }
    test_field_etype();
    fn test_field_content() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElement),
                "::",
                stringify!(content)
            )
        );
    }
    test_field_content();
    fn test_field_attributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElement),
                "::",
                stringify!(attributes)
            )
        );
    }
    test_field_attributes();
    fn test_field_prefix() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElement),
                "::",
                stringify!(prefix)
            )
        );
    }
    test_field_prefix();
    fn test_field_contModel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlElement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).contModel) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlElement),
                "::",
                stringify!(contModel)
            )
        );
    }
    test_field_contModel();
}
pub use self::xmlElementType as xmlNsType;
#[doc = " xmlNs:"]
#[doc = ""]
#[doc = " An XML namespace."]
#[doc = " Note that prefix == NULL is valid, it defines the default namespace"]
#[doc = " within the subtree (until overridden)."]
#[doc = ""]
#[doc = " xmlNsType is unified with xmlElementType."]
pub type xmlNs = _xmlNs;
pub type xmlNsPtr = *mut xmlNs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlNs {
    pub next: *mut _xmlNs,
    pub type_: xmlNsType,
    pub href: *const xmlChar,
    pub prefix: *const xmlChar,
    pub _private: *mut ::std::os::raw::c_void,
    pub context: *mut _xmlDoc,
}
#[test]
fn bindgen_test_layout__xmlNs() {
    assert_eq!(
        ::std::mem::size_of::<_xmlNs>(),
        48usize,
        concat!("Size of: ", stringify!(_xmlNs))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlNs>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlNs))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNs),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNs),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_href() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).href) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNs),
                "::",
                stringify!(href)
            )
        );
    }
    test_field_href();
    fn test_field_prefix() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNs),
                "::",
                stringify!(prefix)
            )
        );
    }
    test_field_prefix();
    fn test_field__private() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._private) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNs),
                "::",
                stringify!(_private)
            )
        );
    }
    test_field__private();
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNs),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
}
#[doc = " xmlDtd:"]
#[doc = ""]
#[doc = " An XML DTD, as defined by <!DOCTYPE ... There is actually one for"]
#[doc = " the internal subset and for the external subset."]
pub type xmlDtd = _xmlDtd;
pub type xmlDtdPtr = *mut xmlDtd;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlDtd {
    pub _private: *mut ::std::os::raw::c_void,
    pub type_: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDoc,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub notations: *mut ::std::os::raw::c_void,
    pub elements: *mut ::std::os::raw::c_void,
    pub attributes: *mut ::std::os::raw::c_void,
    pub entities: *mut ::std::os::raw::c_void,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub pentities: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlDtd() {
    assert_eq!(
        ::std::mem::size_of::<_xmlDtd>(),
        128usize,
        concat!("Size of: ", stringify!(_xmlDtd))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlDtd>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlDtd))
    );
    fn test_field__private() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._private) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(_private)
            )
        );
    }
    test_field__private();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_children() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(children)
            )
        );
    }
    test_field_children();
    fn test_field_last() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(last)
            )
        );
    }
    test_field_last();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_doc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(doc)
            )
        );
    }
    test_field_doc();
    fn test_field_notations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).notations) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(notations)
            )
        );
    }
    test_field_notations();
    fn test_field_elements() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).elements) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(elements)
            )
        );
    }
    test_field_elements();
    fn test_field_attributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(attributes)
            )
        );
    }
    test_field_attributes();
    fn test_field_entities() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entities) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(entities)
            )
        );
    }
    test_field_entities();
    fn test_field_ExternalID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ExternalID) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(ExternalID)
            )
        );
    }
    test_field_ExternalID();
    fn test_field_SystemID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SystemID) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(SystemID)
            )
        );
    }
    test_field_SystemID();
    fn test_field_pentities() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDtd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pentities) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDtd),
                "::",
                stringify!(pentities)
            )
        );
    }
    test_field_pentities();
}
#[doc = " xmlAttr:"]
#[doc = ""]
#[doc = " An attribute on an XML node."]
pub type xmlAttr = _xmlAttr;
pub type xmlAttrPtr = *mut xmlAttr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlAttr {
    pub _private: *mut ::std::os::raw::c_void,
    pub type_: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlAttr,
    pub prev: *mut _xmlAttr,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub atype: xmlAttributeType,
    pub psvi: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlAttr() {
    assert_eq!(
        ::std::mem::size_of::<_xmlAttr>(),
        96usize,
        concat!("Size of: ", stringify!(_xmlAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlAttr>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlAttr))
    );
    fn test_field__private() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._private) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttr),
                "::",
                stringify!(_private)
            )
        );
    }
    test_field__private();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttr),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttr),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_children() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttr),
                "::",
                stringify!(children)
            )
        );
    }
    test_field_children();
    fn test_field_last() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttr),
                "::",
                stringify!(last)
            )
        );
    }
    test_field_last();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttr),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttr),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttr),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_doc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttr),
                "::",
                stringify!(doc)
            )
        );
    }
    test_field_doc();
    fn test_field_ns() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ns) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttr),
                "::",
                stringify!(ns)
            )
        );
    }
    test_field_ns();
    fn test_field_atype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atype) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttr),
                "::",
                stringify!(atype)
            )
        );
    }
    test_field_atype();
    fn test_field_psvi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlAttr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).psvi) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlAttr),
                "::",
                stringify!(psvi)
            )
        );
    }
    test_field_psvi();
}
#[doc = " xmlID:"]
#[doc = ""]
#[doc = " An XML ID instance."]
pub type xmlID = _xmlID;
pub type xmlIDPtr = *mut xmlID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlID {
    pub next: *mut _xmlID,
    pub value: *const xmlChar,
    pub attr: xmlAttrPtr,
    pub name: *const xmlChar,
    pub lineno: ::std::os::raw::c_int,
    pub doc: *mut _xmlDoc,
}
#[test]
fn bindgen_test_layout__xmlID() {
    assert_eq!(
        ::std::mem::size_of::<_xmlID>(),
        48usize,
        concat!("Size of: ", stringify!(_xmlID))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlID>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlID))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlID),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlID),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_attr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attr) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlID),
                "::",
                stringify!(attr)
            )
        );
    }
    test_field_attr();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlID),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_lineno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lineno) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlID),
                "::",
                stringify!(lineno)
            )
        );
    }
    test_field_lineno();
    fn test_field_doc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlID),
                "::",
                stringify!(doc)
            )
        );
    }
    test_field_doc();
}
#[doc = " xmlRef:"]
#[doc = ""]
#[doc = " An XML IDREF instance."]
pub type xmlRef = _xmlRef;
pub type xmlRefPtr = *mut xmlRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRef {
    pub next: *mut _xmlRef,
    pub value: *const xmlChar,
    pub attr: xmlAttrPtr,
    pub name: *const xmlChar,
    pub lineno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlRef() {
    assert_eq!(
        ::std::mem::size_of::<_xmlRef>(),
        40usize,
        concat!("Size of: ", stringify!(_xmlRef))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlRef>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlRef))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlRef>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlRef),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlRef>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlRef),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_attr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlRef>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attr) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlRef),
                "::",
                stringify!(attr)
            )
        );
    }
    test_field_attr();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlRef>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlRef),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_lineno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlRef>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lineno) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlRef),
                "::",
                stringify!(lineno)
            )
        );
    }
    test_field_lineno();
}
#[doc = " xmlNode:"]
#[doc = ""]
#[doc = " A node in an XML tree."]
pub type xmlNode = _xmlNode;
pub type xmlNodePtr = *mut xmlNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlNode {
    pub _private: *mut ::std::os::raw::c_void,
    pub type_: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub content: *mut xmlChar,
    pub properties: *mut _xmlAttr,
    pub nsDef: *mut xmlNs,
    pub psvi: *mut ::std::os::raw::c_void,
    pub line: ::std::os::raw::c_ushort,
    pub extra: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__xmlNode() {
    assert_eq!(
        ::std::mem::size_of::<_xmlNode>(),
        120usize,
        concat!("Size of: ", stringify!(_xmlNode))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlNode>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlNode))
    );
    fn test_field__private() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._private) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(_private)
            )
        );
    }
    test_field__private();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_children() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(children)
            )
        );
    }
    test_field_children();
    fn test_field_last() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(last)
            )
        );
    }
    test_field_last();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_doc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(doc)
            )
        );
    }
    test_field_doc();
    fn test_field_ns() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ns) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(ns)
            )
        );
    }
    test_field_ns();
    fn test_field_content() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(content)
            )
        );
    }
    test_field_content();
    fn test_field_properties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(properties)
            )
        );
    }
    test_field_properties();
    fn test_field_nsDef() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsDef) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(nsDef)
            )
        );
    }
    test_field_nsDef();
    fn test_field_psvi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).psvi) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(psvi)
            )
        );
    }
    test_field_psvi();
    fn test_field_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(line)
            )
        );
    }
    test_field_line();
    fn test_field_extra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize
            },
            114usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNode),
                "::",
                stringify!(extra)
            )
        );
    }
    test_field_extra();
}
pub const xmlDocProperties_XML_DOC_WELLFORMED: xmlDocProperties = 1;
pub const xmlDocProperties_XML_DOC_NSVALID: xmlDocProperties = 2;
pub const xmlDocProperties_XML_DOC_OLD10: xmlDocProperties = 4;
pub const xmlDocProperties_XML_DOC_DTDVALID: xmlDocProperties = 8;
pub const xmlDocProperties_XML_DOC_XINCLUDE: xmlDocProperties = 16;
pub const xmlDocProperties_XML_DOC_USERBUILT: xmlDocProperties = 32;
pub const xmlDocProperties_XML_DOC_INTERNAL: xmlDocProperties = 64;
pub const xmlDocProperties_XML_DOC_HTML: xmlDocProperties = 128;
#[doc = " xmlDocProperty"]
#[doc = ""]
#[doc = " Set of properties of the document as found by the parser"]
#[doc = " Some of them are linked to similarly named xmlParserOption"]
pub type xmlDocProperties = ::std::os::raw::c_int;
#[doc = " xmlDoc:"]
#[doc = ""]
#[doc = " An XML document."]
pub type xmlDoc = _xmlDoc;
pub type xmlDocPtr = *mut xmlDoc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlDoc {
    pub _private: *mut ::std::os::raw::c_void,
    pub type_: xmlElementType,
    pub name: *mut ::std::os::raw::c_char,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub compression: ::std::os::raw::c_int,
    pub standalone: ::std::os::raw::c_int,
    pub intSubset: *mut _xmlDtd,
    pub extSubset: *mut _xmlDtd,
    pub oldNs: *mut _xmlNs,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub ids: *mut ::std::os::raw::c_void,
    pub refs: *mut ::std::os::raw::c_void,
    pub URL: *const xmlChar,
    pub charset: ::std::os::raw::c_int,
    pub dict: *mut _xmlDict,
    pub psvi: *mut ::std::os::raw::c_void,
    pub parseFlags: ::std::os::raw::c_int,
    pub properties: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlDoc() {
    assert_eq!(
        ::std::mem::size_of::<_xmlDoc>(),
        176usize,
        concat!("Size of: ", stringify!(_xmlDoc))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlDoc>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlDoc))
    );
    fn test_field__private() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._private) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(_private)
            )
        );
    }
    test_field__private();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_children() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(children)
            )
        );
    }
    test_field_children();
    fn test_field_last() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(last)
            )
        );
    }
    test_field_last();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_doc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(doc)
            )
        );
    }
    test_field_doc();
    fn test_field_compression() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compression) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(compression)
            )
        );
    }
    test_field_compression();
    fn test_field_standalone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).standalone) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(standalone)
            )
        );
    }
    test_field_standalone();
    fn test_field_intSubset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).intSubset) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(intSubset)
            )
        );
    }
    test_field_intSubset();
    fn test_field_extSubset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extSubset) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(extSubset)
            )
        );
    }
    test_field_extSubset();
    fn test_field_oldNs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).oldNs) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(oldNs)
            )
        );
    }
    test_field_oldNs();
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_encoding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(encoding)
            )
        );
    }
    test_field_encoding();
    fn test_field_ids() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ids) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(ids)
            )
        );
    }
    test_field_ids();
    fn test_field_refs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(refs)
            )
        );
    }
    test_field_refs();
    fn test_field_URL() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).URL) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(URL)
            )
        );
    }
    test_field_URL();
    fn test_field_charset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).charset) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(charset)
            )
        );
    }
    test_field_charset();
    fn test_field_dict() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(dict)
            )
        );
    }
    test_field_dict();
    fn test_field_psvi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).psvi) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(psvi)
            )
        );
    }
    test_field_psvi();
    fn test_field_parseFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parseFlags) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(parseFlags)
            )
        );
    }
    test_field_parseFlags();
    fn test_field_properties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDoc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize
            },
            172usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDoc),
                "::",
                stringify!(properties)
            )
        );
    }
    test_field_properties();
}
#[doc = " xmlDOMWrapCtxt:"]
#[doc = ""]
#[doc = " Context for DOM wrapper-operations."]
pub type xmlDOMWrapCtxt = _xmlDOMWrapCtxt;
pub type xmlDOMWrapCtxtPtr = *mut xmlDOMWrapCtxt;
#[doc = " xmlDOMWrapAcquireNsFunction:"]
#[doc = " @ctxt:  a DOM wrapper context"]
#[doc = " @node:  the context node (element or attribute)"]
#[doc = " @nsName:  the requested namespace name"]
#[doc = " @nsPrefix:  the requested namespace prefix"]
#[doc = ""]
#[doc = " A function called to acquire namespaces (xmlNs) from the wrapper."]
#[doc = ""]
#[doc = " Returns an xmlNsPtr or NULL in case of an error."]
pub type xmlDOMWrapAcquireNsFunction = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: xmlDOMWrapCtxtPtr,
        node: xmlNodePtr,
        nsName: *const xmlChar,
        nsPrefix: *const xmlChar,
    ) -> xmlNsPtr,
>;
#[doc = " xmlDOMWrapCtxt:"]
#[doc = ""]
#[doc = " Context for DOM wrapper-operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlDOMWrapCtxt {
    pub _private: *mut ::std::os::raw::c_void,
    pub type_: ::std::os::raw::c_int,
    pub namespaceMap: *mut ::std::os::raw::c_void,
    pub getNsForNodeFunc: xmlDOMWrapAcquireNsFunction,
}
#[test]
fn bindgen_test_layout__xmlDOMWrapCtxt() {
    assert_eq!(
        ::std::mem::size_of::<_xmlDOMWrapCtxt>(),
        32usize,
        concat!("Size of: ", stringify!(_xmlDOMWrapCtxt))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlDOMWrapCtxt>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlDOMWrapCtxt))
    );
    fn test_field__private() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDOMWrapCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._private) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDOMWrapCtxt),
                "::",
                stringify!(_private)
            )
        );
    }
    test_field__private();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDOMWrapCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDOMWrapCtxt),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_namespaceMap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDOMWrapCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).namespaceMap) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDOMWrapCtxt),
                "::",
                stringify!(namespaceMap)
            )
        );
    }
    test_field_namespaceMap();
    fn test_field_getNsForNodeFunc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlDOMWrapCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getNsForNodeFunc) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlDOMWrapCtxt),
                "::",
                stringify!(getNsForNodeFunc)
            )
        );
    }
    test_field_getNsForNodeFunc();
}
extern "C" {
    pub fn xmlValidateNCName(
        value: *const xmlChar,
        space: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateQName(
        value: *const xmlChar,
        space: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateName(
        value: *const xmlChar,
        space: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateNMToken(
        value: *const xmlChar,
        space: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlBuildQName(
        ncname: *const xmlChar,
        prefix: *const xmlChar,
        memory: *mut xmlChar,
        len: ::std::os::raw::c_int,
    ) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlSplitQName2(name: *const xmlChar, prefix: *mut *mut xmlChar) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlSplitQName3(name: *const xmlChar, len: *mut ::std::os::raw::c_int) -> *const xmlChar;
}
extern "C" {
    pub fn xmlSetBufferAllocationScheme(scheme: xmlBufferAllocationScheme);
}
extern "C" {
    pub fn xmlGetBufferAllocationScheme() -> xmlBufferAllocationScheme;
}
extern "C" {
    pub fn xmlBufferCreate() -> xmlBufferPtr;
}
extern "C" {
    pub fn xmlBufferCreateSize(size: size_t) -> xmlBufferPtr;
}
extern "C" {
    pub fn xmlBufferCreateStatic(mem: *mut ::std::os::raw::c_void, size: size_t) -> xmlBufferPtr;
}
extern "C" {
    pub fn xmlBufferResize(
        buf: xmlBufferPtr,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlBufferFree(buf: xmlBufferPtr);
}
extern "C" {
    pub fn xmlBufferDump(file: *mut FILE, buf: xmlBufferPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlBufferAdd(
        buf: xmlBufferPtr,
        str_: *const xmlChar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlBufferAddHead(
        buf: xmlBufferPtr,
        str_: *const xmlChar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlBufferCat(buf: xmlBufferPtr, str_: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlBufferCCat(
        buf: xmlBufferPtr,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlBufferShrink(buf: xmlBufferPtr, len: ::std::os::raw::c_uint)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlBufferGrow(buf: xmlBufferPtr, len: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlBufferEmpty(buf: xmlBufferPtr);
}
extern "C" {
    pub fn xmlBufferContent(buf: *const xmlBuffer) -> *const xmlChar;
}
extern "C" {
    pub fn xmlBufferDetach(buf: xmlBufferPtr) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlBufferSetAllocationScheme(buf: xmlBufferPtr, scheme: xmlBufferAllocationScheme);
}
extern "C" {
    pub fn xmlBufferLength(buf: *const xmlBuffer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlCreateIntSubset(
        doc: xmlDocPtr,
        name: *const xmlChar,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
    ) -> xmlDtdPtr;
}
extern "C" {
    pub fn xmlNewDtd(
        doc: xmlDocPtr,
        name: *const xmlChar,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
    ) -> xmlDtdPtr;
}
extern "C" {
    pub fn xmlGetIntSubset(doc: *const xmlDoc) -> xmlDtdPtr;
}
extern "C" {
    pub fn xmlFreeDtd(cur: xmlDtdPtr);
}
extern "C" {
    pub fn xmlNewGlobalNs(doc: xmlDocPtr, href: *const xmlChar, prefix: *const xmlChar)
        -> xmlNsPtr;
}
extern "C" {
    pub fn xmlNewNs(node: xmlNodePtr, href: *const xmlChar, prefix: *const xmlChar) -> xmlNsPtr;
}
extern "C" {
    pub fn xmlFreeNs(cur: xmlNsPtr);
}
extern "C" {
    pub fn xmlFreeNsList(cur: xmlNsPtr);
}
extern "C" {
    pub fn xmlNewDoc(version: *const xmlChar) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlFreeDoc(cur: xmlDocPtr);
}
extern "C" {
    pub fn xmlNewDocProp(doc: xmlDocPtr, name: *const xmlChar, value: *const xmlChar)
        -> xmlAttrPtr;
}
extern "C" {
    pub fn xmlNewProp(node: xmlNodePtr, name: *const xmlChar, value: *const xmlChar) -> xmlAttrPtr;
}
extern "C" {
    pub fn xmlNewNsProp(
        node: xmlNodePtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
        value: *const xmlChar,
    ) -> xmlAttrPtr;
}
extern "C" {
    pub fn xmlNewNsPropEatName(
        node: xmlNodePtr,
        ns: xmlNsPtr,
        name: *mut xmlChar,
        value: *const xmlChar,
    ) -> xmlAttrPtr;
}
extern "C" {
    pub fn xmlFreePropList(cur: xmlAttrPtr);
}
extern "C" {
    pub fn xmlFreeProp(cur: xmlAttrPtr);
}
extern "C" {
    pub fn xmlCopyProp(target: xmlNodePtr, cur: xmlAttrPtr) -> xmlAttrPtr;
}
extern "C" {
    pub fn xmlCopyPropList(target: xmlNodePtr, cur: xmlAttrPtr) -> xmlAttrPtr;
}
extern "C" {
    pub fn xmlCopyDtd(dtd: xmlDtdPtr) -> xmlDtdPtr;
}
extern "C" {
    pub fn xmlCopyDoc(doc: xmlDocPtr, recursive: ::std::os::raw::c_int) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlNewDocNode(
        doc: xmlDocPtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewDocNodeEatName(
        doc: xmlDocPtr,
        ns: xmlNsPtr,
        name: *mut xmlChar,
        content: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewNode(ns: xmlNsPtr, name: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewNodeEatName(ns: xmlNsPtr, name: *mut xmlChar) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewChild(
        parent: xmlNodePtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewDocText(doc: *const xmlDoc, content: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewText(content: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewDocPI(doc: xmlDocPtr, name: *const xmlChar, content: *const xmlChar)
        -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewPI(name: *const xmlChar, content: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewDocTextLen(
        doc: xmlDocPtr,
        content: *const xmlChar,
        len: ::std::os::raw::c_int,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewTextLen(content: *const xmlChar, len: ::std::os::raw::c_int) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewDocComment(doc: xmlDocPtr, content: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewComment(content: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewCDataBlock(
        doc: xmlDocPtr,
        content: *const xmlChar,
        len: ::std::os::raw::c_int,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewCharRef(doc: xmlDocPtr, name: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewReference(doc: *const xmlDoc, name: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlCopyNode(node: xmlNodePtr, recursive: ::std::os::raw::c_int) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlDocCopyNode(
        node: xmlNodePtr,
        doc: xmlDocPtr,
        recursive: ::std::os::raw::c_int,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlDocCopyNodeList(doc: xmlDocPtr, node: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlCopyNodeList(node: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewTextChild(
        parent: xmlNodePtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewDocRawNode(
        doc: xmlDocPtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNewDocFragment(doc: xmlDocPtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlGetLineNo(node: *const xmlNode) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn xmlGetNodePath(node: *const xmlNode) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlDocGetRootElement(doc: *const xmlDoc) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlGetLastChild(parent: *const xmlNode) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNodeIsText(node: *const xmlNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlIsBlankNode(node: *const xmlNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlDocSetRootElement(doc: xmlDocPtr, root: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNodeSetName(cur: xmlNodePtr, name: *const xmlChar);
}
extern "C" {
    pub fn xmlAddChild(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlAddChildList(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlReplaceNode(old: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlAddPrevSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlAddSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlAddNextSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlUnlinkNode(cur: xmlNodePtr);
}
extern "C" {
    pub fn xmlTextMerge(first: xmlNodePtr, second: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlTextConcat(
        node: xmlNodePtr,
        content: *const xmlChar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlFreeNodeList(cur: xmlNodePtr);
}
extern "C" {
    pub fn xmlFreeNode(cur: xmlNodePtr);
}
extern "C" {
    pub fn xmlSetTreeDoc(tree: xmlNodePtr, doc: xmlDocPtr);
}
extern "C" {
    pub fn xmlSetListDoc(list: xmlNodePtr, doc: xmlDocPtr);
}
extern "C" {
    pub fn xmlSearchNs(doc: xmlDocPtr, node: xmlNodePtr, nameSpace: *const xmlChar) -> xmlNsPtr;
}
extern "C" {
    pub fn xmlSearchNsByHref(doc: xmlDocPtr, node: xmlNodePtr, href: *const xmlChar) -> xmlNsPtr;
}
extern "C" {
    pub fn xmlGetNsList(doc: *const xmlDoc, node: *const xmlNode) -> *mut xmlNsPtr;
}
extern "C" {
    pub fn xmlSetNs(node: xmlNodePtr, ns: xmlNsPtr);
}
extern "C" {
    pub fn xmlCopyNamespace(cur: xmlNsPtr) -> xmlNsPtr;
}
extern "C" {
    pub fn xmlCopyNamespaceList(cur: xmlNsPtr) -> xmlNsPtr;
}
extern "C" {
    pub fn xmlSetProp(node: xmlNodePtr, name: *const xmlChar, value: *const xmlChar) -> xmlAttrPtr;
}
extern "C" {
    pub fn xmlSetNsProp(
        node: xmlNodePtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
        value: *const xmlChar,
    ) -> xmlAttrPtr;
}
extern "C" {
    pub fn xmlGetNoNsProp(node: *const xmlNode, name: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlGetProp(node: *const xmlNode, name: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlHasProp(node: *const xmlNode, name: *const xmlChar) -> xmlAttrPtr;
}
extern "C" {
    pub fn xmlHasNsProp(
        node: *const xmlNode,
        name: *const xmlChar,
        nameSpace: *const xmlChar,
    ) -> xmlAttrPtr;
}
extern "C" {
    pub fn xmlGetNsProp(
        node: *const xmlNode,
        name: *const xmlChar,
        nameSpace: *const xmlChar,
    ) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlStringGetNodeList(doc: *const xmlDoc, value: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlStringLenGetNodeList(
        doc: *const xmlDoc,
        value: *const xmlChar,
        len: ::std::os::raw::c_int,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlNodeListGetString(
        doc: xmlDocPtr,
        list: *const xmlNode,
        inLine: ::std::os::raw::c_int,
    ) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlNodeListGetRawString(
        doc: *const xmlDoc,
        list: *const xmlNode,
        inLine: ::std::os::raw::c_int,
    ) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlNodeSetContent(cur: xmlNodePtr, content: *const xmlChar);
}
extern "C" {
    pub fn xmlNodeSetContentLen(
        cur: xmlNodePtr,
        content: *const xmlChar,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn xmlNodeAddContent(cur: xmlNodePtr, content: *const xmlChar);
}
extern "C" {
    pub fn xmlNodeAddContentLen(
        cur: xmlNodePtr,
        content: *const xmlChar,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn xmlNodeGetContent(cur: *const xmlNode) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlNodeBufGetContent(buffer: xmlBufferPtr, cur: *const xmlNode)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlBufGetNodeContent(buf: xmlBufPtr, cur: *const xmlNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlNodeGetLang(cur: *const xmlNode) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlNodeGetSpacePreserve(cur: *const xmlNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlNodeSetLang(cur: xmlNodePtr, lang: *const xmlChar);
}
extern "C" {
    pub fn xmlNodeSetSpacePreserve(cur: xmlNodePtr, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xmlNodeGetBase(doc: *const xmlDoc, cur: *const xmlNode) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlNodeSetBase(cur: xmlNodePtr, uri: *const xmlChar);
}
extern "C" {
    pub fn xmlRemoveProp(cur: xmlAttrPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlUnsetNsProp(
        node: xmlNodePtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlUnsetProp(node: xmlNodePtr, name: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlBufferWriteCHAR(buf: xmlBufferPtr, string: *const xmlChar);
}
extern "C" {
    pub fn xmlBufferWriteChar(buf: xmlBufferPtr, string: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn xmlBufferWriteQuotedString(buf: xmlBufferPtr, string: *const xmlChar);
}
extern "C" {
    pub fn xmlAttrSerializeTxtContent(
        buf: xmlBufferPtr,
        doc: xmlDocPtr,
        attr: xmlAttrPtr,
        string: *const xmlChar,
    );
}
extern "C" {
    pub fn xmlReconciliateNs(doc: xmlDocPtr, tree: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlDocDumpFormatMemory(
        cur: xmlDocPtr,
        mem: *mut *mut xmlChar,
        size: *mut ::std::os::raw::c_int,
        format: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn xmlDocDumpMemory(
        cur: xmlDocPtr,
        mem: *mut *mut xmlChar,
        size: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn xmlDocDumpMemoryEnc(
        out_doc: xmlDocPtr,
        doc_txt_ptr: *mut *mut xmlChar,
        doc_txt_len: *mut ::std::os::raw::c_int,
        txt_encoding: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn xmlDocDumpFormatMemoryEnc(
        out_doc: xmlDocPtr,
        doc_txt_ptr: *mut *mut xmlChar,
        doc_txt_len: *mut ::std::os::raw::c_int,
        txt_encoding: *const ::std::os::raw::c_char,
        format: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn xmlDocFormatDump(
        f: *mut FILE,
        cur: xmlDocPtr,
        format: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlDocDump(f: *mut FILE, cur: xmlDocPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlElemDump(f: *mut FILE, doc: xmlDocPtr, cur: xmlNodePtr);
}
extern "C" {
    pub fn xmlSaveFile(
        filename: *const ::std::os::raw::c_char,
        cur: xmlDocPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSaveFormatFile(
        filename: *const ::std::os::raw::c_char,
        cur: xmlDocPtr,
        format: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlBufNodeDump(
        buf: xmlBufPtr,
        doc: xmlDocPtr,
        cur: xmlNodePtr,
        level: ::std::os::raw::c_int,
        format: ::std::os::raw::c_int,
    ) -> size_t;
}
extern "C" {
    pub fn xmlNodeDump(
        buf: xmlBufferPtr,
        doc: xmlDocPtr,
        cur: xmlNodePtr,
        level: ::std::os::raw::c_int,
        format: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSaveFileTo(
        buf: xmlOutputBufferPtr,
        cur: xmlDocPtr,
        encoding: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSaveFormatFileTo(
        buf: xmlOutputBufferPtr,
        cur: xmlDocPtr,
        encoding: *const ::std::os::raw::c_char,
        format: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlNodeDumpOutput(
        buf: xmlOutputBufferPtr,
        doc: xmlDocPtr,
        cur: xmlNodePtr,
        level: ::std::os::raw::c_int,
        format: ::std::os::raw::c_int,
        encoding: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn xmlSaveFormatFileEnc(
        filename: *const ::std::os::raw::c_char,
        cur: xmlDocPtr,
        encoding: *const ::std::os::raw::c_char,
        format: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSaveFileEnc(
        filename: *const ::std::os::raw::c_char,
        cur: xmlDocPtr,
        encoding: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlIsXHTML(systemID: *const xmlChar, publicID: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlGetDocCompressMode(doc: *const xmlDoc) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSetDocCompressMode(doc: xmlDocPtr, mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xmlGetCompressMode() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSetCompressMode(mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xmlDOMWrapNewCtxt() -> xmlDOMWrapCtxtPtr;
}
extern "C" {
    pub fn xmlDOMWrapFreeCtxt(ctxt: xmlDOMWrapCtxtPtr);
}
extern "C" {
    pub fn xmlDOMWrapReconcileNamespaces(
        ctxt: xmlDOMWrapCtxtPtr,
        elem: xmlNodePtr,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlDOMWrapAdoptNode(
        ctxt: xmlDOMWrapCtxtPtr,
        sourceDoc: xmlDocPtr,
        node: xmlNodePtr,
        destDoc: xmlDocPtr,
        destParent: xmlNodePtr,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlDOMWrapRemoveNode(
        ctxt: xmlDOMWrapCtxtPtr,
        doc: xmlDocPtr,
        node: xmlNodePtr,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlDOMWrapCloneNode(
        ctxt: xmlDOMWrapCtxtPtr,
        sourceDoc: xmlDocPtr,
        node: xmlNodePtr,
        clonedNode: *mut xmlNodePtr,
        destDoc: xmlDocPtr,
        destParent: xmlNodePtr,
        deep: ::std::os::raw::c_int,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlChildElementCount(parent: xmlNodePtr) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn xmlNextElementSibling(node: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlFirstElementChild(parent: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlLastElementChild(parent: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlPreviousElementSibling(node: xmlNodePtr) -> xmlNodePtr;
}
#[doc = " xmlFreeFunc:"]
#[doc = " @mem: an already allocated block of memory"]
#[doc = ""]
#[doc = " Signature for a free() implementation."]
pub type xmlFreeFunc =
    ::std::option::Option<unsafe extern "C" fn(mem: *mut ::std::os::raw::c_void)>;
#[doc = " xmlMallocFunc:"]
#[doc = " @size:  the size requested in bytes"]
#[doc = ""]
#[doc = " Signature for a malloc() implementation."]
#[doc = ""]
#[doc = " Returns a pointer to the newly allocated block or NULL in case of error."]
pub type xmlMallocFunc =
    ::std::option::Option<unsafe extern "C" fn(size: size_t) -> *mut ::std::os::raw::c_void>;
#[doc = " xmlReallocFunc:"]
#[doc = " @mem: an already allocated block of memory"]
#[doc = " @size:  the new size requested in bytes"]
#[doc = ""]
#[doc = " Signature for a realloc() implementation."]
#[doc = ""]
#[doc = " Returns a pointer to the newly reallocated block or NULL in case of error."]
pub type xmlReallocFunc = ::std::option::Option<
    unsafe extern "C" fn(
        mem: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " xmlStrdupFunc:"]
#[doc = " @str: a zero terminated string"]
#[doc = ""]
#[doc = " Signature for an strdup() implementation."]
#[doc = ""]
#[doc = " Returns the copy of the string or NULL in case of error."]
pub type xmlStrdupFunc = ::std::option::Option<
    unsafe extern "C" fn(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
extern "C" {
    pub fn xmlMemSetup(
        freeFunc: xmlFreeFunc,
        mallocFunc: xmlMallocFunc,
        reallocFunc: xmlReallocFunc,
        strdupFunc: xmlStrdupFunc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlMemGet(
        freeFunc: *mut xmlFreeFunc,
        mallocFunc: *mut xmlMallocFunc,
        reallocFunc: *mut xmlReallocFunc,
        strdupFunc: *mut xmlStrdupFunc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlGcMemSetup(
        freeFunc: xmlFreeFunc,
        mallocFunc: xmlMallocFunc,
        mallocAtomicFunc: xmlMallocFunc,
        reallocFunc: xmlReallocFunc,
        strdupFunc: xmlStrdupFunc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlGcMemGet(
        freeFunc: *mut xmlFreeFunc,
        mallocFunc: *mut xmlMallocFunc,
        mallocAtomicFunc: *mut xmlMallocFunc,
        reallocFunc: *mut xmlReallocFunc,
        strdupFunc: *mut xmlStrdupFunc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlInitMemory() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlCleanupMemory();
}
extern "C" {
    pub fn xmlMemUsed() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlMemBlocks() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlMemDisplay(fp: *mut FILE);
}
extern "C" {
    pub fn xmlMemDisplayLast(fp: *mut FILE, nbBytes: ::std::os::raw::c_long);
}
extern "C" {
    pub fn xmlMemShow(fp: *mut FILE, nr: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xmlMemoryDump();
}
extern "C" {
    pub fn xmlMemMalloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlMemRealloc(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlMemFree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn xmlMemoryStrdup(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xmlMallocLoc(
        size: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlReallocLoc(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlMallocAtomicLoc(
        size: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlMemStrdupLoc(
        str_: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlMutex {
    _unused: [u8; 0],
}
pub type xmlMutex = _xmlMutex;
pub type xmlMutexPtr = *mut xmlMutex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRMutex {
    _unused: [u8; 0],
}
pub type xmlRMutex = _xmlRMutex;
pub type xmlRMutexPtr = *mut xmlRMutex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlHashTable {
    _unused: [u8; 0],
}
pub type xmlHashTable = _xmlHashTable;
pub type xmlHashTablePtr = *mut xmlHashTable;
#[doc = " xmlHashDeallocator:"]
#[doc = " @payload:  the data in the hash"]
#[doc = " @name:  the name associated"]
#[doc = ""]
#[doc = " Callback to free data from a hash."]
pub type xmlHashDeallocator = ::std::option::Option<
    unsafe extern "C" fn(payload: *mut ::std::os::raw::c_void, name: *const xmlChar),
>;
#[doc = " xmlHashCopier:"]
#[doc = " @payload:  the data in the hash"]
#[doc = " @name:  the name associated"]
#[doc = ""]
#[doc = " Callback to copy data from a hash."]
#[doc = ""]
#[doc = " Returns a copy of the data or NULL in case of error."]
pub type xmlHashCopier = ::std::option::Option<
    unsafe extern "C" fn(
        payload: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " xmlHashScanner:"]
#[doc = " @payload:  the data in the hash"]
#[doc = " @data:  extra scanner data"]
#[doc = " @name:  the name associated"]
#[doc = ""]
#[doc = " Callback when scanning data in a hash with the simple scanner."]
pub type xmlHashScanner = ::std::option::Option<
    unsafe extern "C" fn(
        payload: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
    ),
>;
#[doc = " xmlHashScannerFull:"]
#[doc = " @payload:  the data in the hash"]
#[doc = " @data:  extra scanner data"]
#[doc = " @name:  the name associated"]
#[doc = " @name2:  the second name associated"]
#[doc = " @name3:  the third name associated"]
#[doc = ""]
#[doc = " Callback when scanning data in a hash with the full scanner."]
pub type xmlHashScannerFull = ::std::option::Option<
    unsafe extern "C" fn(
        payload: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        name2: *const xmlChar,
        name3: *const xmlChar,
    ),
>;
extern "C" {
    pub fn xmlHashCreate(size: ::std::os::raw::c_int) -> xmlHashTablePtr;
}
extern "C" {
    pub fn xmlHashCreateDict(size: ::std::os::raw::c_int, dict: xmlDictPtr) -> xmlHashTablePtr;
}
extern "C" {
    pub fn xmlHashFree(table: xmlHashTablePtr, f: xmlHashDeallocator);
}
extern "C" {
    pub fn xmlHashDefaultDeallocator(entry: *mut ::std::os::raw::c_void, name: *const xmlChar);
}
extern "C" {
    pub fn xmlHashAddEntry(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlHashUpdateEntry(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        userdata: *mut ::std::os::raw::c_void,
        f: xmlHashDeallocator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlHashAddEntry2(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        name2: *const xmlChar,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlHashUpdateEntry2(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        name2: *const xmlChar,
        userdata: *mut ::std::os::raw::c_void,
        f: xmlHashDeallocator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlHashAddEntry3(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        name2: *const xmlChar,
        name3: *const xmlChar,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlHashUpdateEntry3(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        name2: *const xmlChar,
        name3: *const xmlChar,
        userdata: *mut ::std::os::raw::c_void,
        f: xmlHashDeallocator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlHashRemoveEntry(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        f: xmlHashDeallocator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlHashRemoveEntry2(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        name2: *const xmlChar,
        f: xmlHashDeallocator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlHashRemoveEntry3(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        name2: *const xmlChar,
        name3: *const xmlChar,
        f: xmlHashDeallocator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlHashLookup(
        table: xmlHashTablePtr,
        name: *const xmlChar,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlHashLookup2(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        name2: *const xmlChar,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlHashLookup3(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        name2: *const xmlChar,
        name3: *const xmlChar,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlHashQLookup(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        prefix: *const xmlChar,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlHashQLookup2(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        prefix: *const xmlChar,
        name2: *const xmlChar,
        prefix2: *const xmlChar,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlHashQLookup3(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        prefix: *const xmlChar,
        name2: *const xmlChar,
        prefix2: *const xmlChar,
        name3: *const xmlChar,
        prefix3: *const xmlChar,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlHashCopy(table: xmlHashTablePtr, f: xmlHashCopier) -> xmlHashTablePtr;
}
extern "C" {
    pub fn xmlHashSize(table: xmlHashTablePtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlHashScan(
        table: xmlHashTablePtr,
        f: xmlHashScanner,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn xmlHashScan3(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        name2: *const xmlChar,
        name3: *const xmlChar,
        f: xmlHashScanner,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn xmlHashScanFull(
        table: xmlHashTablePtr,
        f: xmlHashScannerFull,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn xmlHashScanFull3(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        name2: *const xmlChar,
        name3: *const xmlChar,
        f: xmlHashScannerFull,
        data: *mut ::std::os::raw::c_void,
    );
}
pub const xmlErrorLevel_XML_ERR_NONE: xmlErrorLevel = 0;
pub const xmlErrorLevel_XML_ERR_WARNING: xmlErrorLevel = 1;
pub const xmlErrorLevel_XML_ERR_ERROR: xmlErrorLevel = 2;
pub const xmlErrorLevel_XML_ERR_FATAL: xmlErrorLevel = 3;
#[doc = " xmlErrorLevel:"]
#[doc = ""]
#[doc = " Indicates the level of an error"]
pub type xmlErrorLevel = ::std::os::raw::c_int;
pub const xmlErrorDomain_XML_FROM_NONE: xmlErrorDomain = 0;
pub const xmlErrorDomain_XML_FROM_PARSER: xmlErrorDomain = 1;
pub const xmlErrorDomain_XML_FROM_TREE: xmlErrorDomain = 2;
pub const xmlErrorDomain_XML_FROM_NAMESPACE: xmlErrorDomain = 3;
pub const xmlErrorDomain_XML_FROM_DTD: xmlErrorDomain = 4;
pub const xmlErrorDomain_XML_FROM_HTML: xmlErrorDomain = 5;
pub const xmlErrorDomain_XML_FROM_MEMORY: xmlErrorDomain = 6;
pub const xmlErrorDomain_XML_FROM_OUTPUT: xmlErrorDomain = 7;
pub const xmlErrorDomain_XML_FROM_IO: xmlErrorDomain = 8;
pub const xmlErrorDomain_XML_FROM_FTP: xmlErrorDomain = 9;
pub const xmlErrorDomain_XML_FROM_HTTP: xmlErrorDomain = 10;
pub const xmlErrorDomain_XML_FROM_XINCLUDE: xmlErrorDomain = 11;
pub const xmlErrorDomain_XML_FROM_XPATH: xmlErrorDomain = 12;
pub const xmlErrorDomain_XML_FROM_XPOINTER: xmlErrorDomain = 13;
pub const xmlErrorDomain_XML_FROM_REGEXP: xmlErrorDomain = 14;
pub const xmlErrorDomain_XML_FROM_DATATYPE: xmlErrorDomain = 15;
pub const xmlErrorDomain_XML_FROM_SCHEMASP: xmlErrorDomain = 16;
pub const xmlErrorDomain_XML_FROM_SCHEMASV: xmlErrorDomain = 17;
pub const xmlErrorDomain_XML_FROM_RELAXNGP: xmlErrorDomain = 18;
pub const xmlErrorDomain_XML_FROM_RELAXNGV: xmlErrorDomain = 19;
pub const xmlErrorDomain_XML_FROM_CATALOG: xmlErrorDomain = 20;
pub const xmlErrorDomain_XML_FROM_C14N: xmlErrorDomain = 21;
pub const xmlErrorDomain_XML_FROM_XSLT: xmlErrorDomain = 22;
pub const xmlErrorDomain_XML_FROM_VALID: xmlErrorDomain = 23;
pub const xmlErrorDomain_XML_FROM_CHECK: xmlErrorDomain = 24;
pub const xmlErrorDomain_XML_FROM_WRITER: xmlErrorDomain = 25;
pub const xmlErrorDomain_XML_FROM_MODULE: xmlErrorDomain = 26;
pub const xmlErrorDomain_XML_FROM_I18N: xmlErrorDomain = 27;
pub const xmlErrorDomain_XML_FROM_SCHEMATRONV: xmlErrorDomain = 28;
pub const xmlErrorDomain_XML_FROM_BUFFER: xmlErrorDomain = 29;
pub const xmlErrorDomain_XML_FROM_URI: xmlErrorDomain = 30;
#[doc = " xmlErrorDomain:"]
#[doc = ""]
#[doc = " Indicates where an error may have come from"]
pub type xmlErrorDomain = ::std::os::raw::c_int;
#[doc = " xmlError:"]
#[doc = ""]
#[doc = " An XML Error instance."]
pub type xmlError = _xmlError;
pub type xmlErrorPtr = *mut xmlError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlError {
    pub domain: ::std::os::raw::c_int,
    pub code: ::std::os::raw::c_int,
    pub message: *mut ::std::os::raw::c_char,
    pub level: xmlErrorLevel,
    pub file: *mut ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_int,
    pub str1: *mut ::std::os::raw::c_char,
    pub str2: *mut ::std::os::raw::c_char,
    pub str3: *mut ::std::os::raw::c_char,
    pub int1: ::std::os::raw::c_int,
    pub int2: ::std::os::raw::c_int,
    pub ctxt: *mut ::std::os::raw::c_void,
    pub node: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlError() {
    assert_eq!(
        ::std::mem::size_of::<_xmlError>(),
        88usize,
        concat!("Size of: ", stringify!(_xmlError))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlError>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlError))
    );
    fn test_field_domain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlError),
                "::",
                stringify!(domain)
            )
        );
    }
    test_field_domain();
    fn test_field_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlError),
                "::",
                stringify!(code)
            )
        );
    }
    test_field_code();
    fn test_field_message() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlError),
                "::",
                stringify!(message)
            )
        );
    }
    test_field_message();
    fn test_field_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlError),
                "::",
                stringify!(level)
            )
        );
    }
    test_field_level();
    fn test_field_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlError),
                "::",
                stringify!(file)
            )
        );
    }
    test_field_file();
    fn test_field_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlError),
                "::",
                stringify!(line)
            )
        );
    }
    test_field_line();
    fn test_field_str1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).str1) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlError),
                "::",
                stringify!(str1)
            )
        );
    }
    test_field_str1();
    fn test_field_str2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).str2) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlError),
                "::",
                stringify!(str2)
            )
        );
    }
    test_field_str2();
    fn test_field_str3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).str3) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlError),
                "::",
                stringify!(str3)
            )
        );
    }
    test_field_str3();
    fn test_field_int1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int1) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlError),
                "::",
                stringify!(int1)
            )
        );
    }
    test_field_int1();
    fn test_field_int2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int2) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlError),
                "::",
                stringify!(int2)
            )
        );
    }
    test_field_int2();
    fn test_field_ctxt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctxt) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlError),
                "::",
                stringify!(ctxt)
            )
        );
    }
    test_field_ctxt();
    fn test_field_node() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlError),
                "::",
                stringify!(node)
            )
        );
    }
    test_field_node();
}
pub const xmlParserErrors_XML_ERR_OK: xmlParserErrors = 0;
pub const xmlParserErrors_XML_ERR_INTERNAL_ERROR: xmlParserErrors = 1;
pub const xmlParserErrors_XML_ERR_NO_MEMORY: xmlParserErrors = 2;
pub const xmlParserErrors_XML_ERR_DOCUMENT_START: xmlParserErrors = 3;
pub const xmlParserErrors_XML_ERR_DOCUMENT_EMPTY: xmlParserErrors = 4;
pub const xmlParserErrors_XML_ERR_DOCUMENT_END: xmlParserErrors = 5;
pub const xmlParserErrors_XML_ERR_INVALID_HEX_CHARREF: xmlParserErrors = 6;
pub const xmlParserErrors_XML_ERR_INVALID_DEC_CHARREF: xmlParserErrors = 7;
pub const xmlParserErrors_XML_ERR_INVALID_CHARREF: xmlParserErrors = 8;
pub const xmlParserErrors_XML_ERR_INVALID_CHAR: xmlParserErrors = 9;
pub const xmlParserErrors_XML_ERR_CHARREF_AT_EOF: xmlParserErrors = 10;
pub const xmlParserErrors_XML_ERR_CHARREF_IN_PROLOG: xmlParserErrors = 11;
pub const xmlParserErrors_XML_ERR_CHARREF_IN_EPILOG: xmlParserErrors = 12;
pub const xmlParserErrors_XML_ERR_CHARREF_IN_DTD: xmlParserErrors = 13;
pub const xmlParserErrors_XML_ERR_ENTITYREF_AT_EOF: xmlParserErrors = 14;
pub const xmlParserErrors_XML_ERR_ENTITYREF_IN_PROLOG: xmlParserErrors = 15;
pub const xmlParserErrors_XML_ERR_ENTITYREF_IN_EPILOG: xmlParserErrors = 16;
pub const xmlParserErrors_XML_ERR_ENTITYREF_IN_DTD: xmlParserErrors = 17;
pub const xmlParserErrors_XML_ERR_PEREF_AT_EOF: xmlParserErrors = 18;
pub const xmlParserErrors_XML_ERR_PEREF_IN_PROLOG: xmlParserErrors = 19;
pub const xmlParserErrors_XML_ERR_PEREF_IN_EPILOG: xmlParserErrors = 20;
pub const xmlParserErrors_XML_ERR_PEREF_IN_INT_SUBSET: xmlParserErrors = 21;
pub const xmlParserErrors_XML_ERR_ENTITYREF_NO_NAME: xmlParserErrors = 22;
pub const xmlParserErrors_XML_ERR_ENTITYREF_SEMICOL_MISSING: xmlParserErrors = 23;
pub const xmlParserErrors_XML_ERR_PEREF_NO_NAME: xmlParserErrors = 24;
pub const xmlParserErrors_XML_ERR_PEREF_SEMICOL_MISSING: xmlParserErrors = 25;
pub const xmlParserErrors_XML_ERR_UNDECLARED_ENTITY: xmlParserErrors = 26;
pub const xmlParserErrors_XML_WAR_UNDECLARED_ENTITY: xmlParserErrors = 27;
pub const xmlParserErrors_XML_ERR_UNPARSED_ENTITY: xmlParserErrors = 28;
pub const xmlParserErrors_XML_ERR_ENTITY_IS_EXTERNAL: xmlParserErrors = 29;
pub const xmlParserErrors_XML_ERR_ENTITY_IS_PARAMETER: xmlParserErrors = 30;
pub const xmlParserErrors_XML_ERR_UNKNOWN_ENCODING: xmlParserErrors = 31;
pub const xmlParserErrors_XML_ERR_UNSUPPORTED_ENCODING: xmlParserErrors = 32;
pub const xmlParserErrors_XML_ERR_STRING_NOT_STARTED: xmlParserErrors = 33;
pub const xmlParserErrors_XML_ERR_STRING_NOT_CLOSED: xmlParserErrors = 34;
pub const xmlParserErrors_XML_ERR_NS_DECL_ERROR: xmlParserErrors = 35;
pub const xmlParserErrors_XML_ERR_ENTITY_NOT_STARTED: xmlParserErrors = 36;
pub const xmlParserErrors_XML_ERR_ENTITY_NOT_FINISHED: xmlParserErrors = 37;
pub const xmlParserErrors_XML_ERR_LT_IN_ATTRIBUTE: xmlParserErrors = 38;
pub const xmlParserErrors_XML_ERR_ATTRIBUTE_NOT_STARTED: xmlParserErrors = 39;
pub const xmlParserErrors_XML_ERR_ATTRIBUTE_NOT_FINISHED: xmlParserErrors = 40;
pub const xmlParserErrors_XML_ERR_ATTRIBUTE_WITHOUT_VALUE: xmlParserErrors = 41;
pub const xmlParserErrors_XML_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 42;
pub const xmlParserErrors_XML_ERR_LITERAL_NOT_STARTED: xmlParserErrors = 43;
pub const xmlParserErrors_XML_ERR_LITERAL_NOT_FINISHED: xmlParserErrors = 44;
pub const xmlParserErrors_XML_ERR_COMMENT_NOT_FINISHED: xmlParserErrors = 45;
pub const xmlParserErrors_XML_ERR_PI_NOT_STARTED: xmlParserErrors = 46;
pub const xmlParserErrors_XML_ERR_PI_NOT_FINISHED: xmlParserErrors = 47;
pub const xmlParserErrors_XML_ERR_NOTATION_NOT_STARTED: xmlParserErrors = 48;
pub const xmlParserErrors_XML_ERR_NOTATION_NOT_FINISHED: xmlParserErrors = 49;
pub const xmlParserErrors_XML_ERR_ATTLIST_NOT_STARTED: xmlParserErrors = 50;
pub const xmlParserErrors_XML_ERR_ATTLIST_NOT_FINISHED: xmlParserErrors = 51;
pub const xmlParserErrors_XML_ERR_MIXED_NOT_STARTED: xmlParserErrors = 52;
pub const xmlParserErrors_XML_ERR_MIXED_NOT_FINISHED: xmlParserErrors = 53;
pub const xmlParserErrors_XML_ERR_ELEMCONTENT_NOT_STARTED: xmlParserErrors = 54;
pub const xmlParserErrors_XML_ERR_ELEMCONTENT_NOT_FINISHED: xmlParserErrors = 55;
pub const xmlParserErrors_XML_ERR_XMLDECL_NOT_STARTED: xmlParserErrors = 56;
pub const xmlParserErrors_XML_ERR_XMLDECL_NOT_FINISHED: xmlParserErrors = 57;
pub const xmlParserErrors_XML_ERR_CONDSEC_NOT_STARTED: xmlParserErrors = 58;
pub const xmlParserErrors_XML_ERR_CONDSEC_NOT_FINISHED: xmlParserErrors = 59;
pub const xmlParserErrors_XML_ERR_EXT_SUBSET_NOT_FINISHED: xmlParserErrors = 60;
pub const xmlParserErrors_XML_ERR_DOCTYPE_NOT_FINISHED: xmlParserErrors = 61;
pub const xmlParserErrors_XML_ERR_MISPLACED_CDATA_END: xmlParserErrors = 62;
pub const xmlParserErrors_XML_ERR_CDATA_NOT_FINISHED: xmlParserErrors = 63;
pub const xmlParserErrors_XML_ERR_RESERVED_XML_NAME: xmlParserErrors = 64;
pub const xmlParserErrors_XML_ERR_SPACE_REQUIRED: xmlParserErrors = 65;
pub const xmlParserErrors_XML_ERR_SEPARATOR_REQUIRED: xmlParserErrors = 66;
pub const xmlParserErrors_XML_ERR_NMTOKEN_REQUIRED: xmlParserErrors = 67;
pub const xmlParserErrors_XML_ERR_NAME_REQUIRED: xmlParserErrors = 68;
pub const xmlParserErrors_XML_ERR_PCDATA_REQUIRED: xmlParserErrors = 69;
pub const xmlParserErrors_XML_ERR_URI_REQUIRED: xmlParserErrors = 70;
pub const xmlParserErrors_XML_ERR_PUBID_REQUIRED: xmlParserErrors = 71;
pub const xmlParserErrors_XML_ERR_LT_REQUIRED: xmlParserErrors = 72;
pub const xmlParserErrors_XML_ERR_GT_REQUIRED: xmlParserErrors = 73;
pub const xmlParserErrors_XML_ERR_LTSLASH_REQUIRED: xmlParserErrors = 74;
pub const xmlParserErrors_XML_ERR_EQUAL_REQUIRED: xmlParserErrors = 75;
pub const xmlParserErrors_XML_ERR_TAG_NAME_MISMATCH: xmlParserErrors = 76;
pub const xmlParserErrors_XML_ERR_TAG_NOT_FINISHED: xmlParserErrors = 77;
pub const xmlParserErrors_XML_ERR_STANDALONE_VALUE: xmlParserErrors = 78;
pub const xmlParserErrors_XML_ERR_ENCODING_NAME: xmlParserErrors = 79;
pub const xmlParserErrors_XML_ERR_HYPHEN_IN_COMMENT: xmlParserErrors = 80;
pub const xmlParserErrors_XML_ERR_INVALID_ENCODING: xmlParserErrors = 81;
pub const xmlParserErrors_XML_ERR_EXT_ENTITY_STANDALONE: xmlParserErrors = 82;
pub const xmlParserErrors_XML_ERR_CONDSEC_INVALID: xmlParserErrors = 83;
pub const xmlParserErrors_XML_ERR_VALUE_REQUIRED: xmlParserErrors = 84;
pub const xmlParserErrors_XML_ERR_NOT_WELL_BALANCED: xmlParserErrors = 85;
pub const xmlParserErrors_XML_ERR_EXTRA_CONTENT: xmlParserErrors = 86;
pub const xmlParserErrors_XML_ERR_ENTITY_CHAR_ERROR: xmlParserErrors = 87;
pub const xmlParserErrors_XML_ERR_ENTITY_PE_INTERNAL: xmlParserErrors = 88;
pub const xmlParserErrors_XML_ERR_ENTITY_LOOP: xmlParserErrors = 89;
pub const xmlParserErrors_XML_ERR_ENTITY_BOUNDARY: xmlParserErrors = 90;
pub const xmlParserErrors_XML_ERR_INVALID_URI: xmlParserErrors = 91;
pub const xmlParserErrors_XML_ERR_URI_FRAGMENT: xmlParserErrors = 92;
pub const xmlParserErrors_XML_WAR_CATALOG_PI: xmlParserErrors = 93;
pub const xmlParserErrors_XML_ERR_NO_DTD: xmlParserErrors = 94;
pub const xmlParserErrors_XML_ERR_CONDSEC_INVALID_KEYWORD: xmlParserErrors = 95;
pub const xmlParserErrors_XML_ERR_VERSION_MISSING: xmlParserErrors = 96;
pub const xmlParserErrors_XML_WAR_UNKNOWN_VERSION: xmlParserErrors = 97;
pub const xmlParserErrors_XML_WAR_LANG_VALUE: xmlParserErrors = 98;
pub const xmlParserErrors_XML_WAR_NS_URI: xmlParserErrors = 99;
pub const xmlParserErrors_XML_WAR_NS_URI_RELATIVE: xmlParserErrors = 100;
pub const xmlParserErrors_XML_ERR_MISSING_ENCODING: xmlParserErrors = 101;
pub const xmlParserErrors_XML_WAR_SPACE_VALUE: xmlParserErrors = 102;
pub const xmlParserErrors_XML_ERR_NOT_STANDALONE: xmlParserErrors = 103;
pub const xmlParserErrors_XML_ERR_ENTITY_PROCESSING: xmlParserErrors = 104;
pub const xmlParserErrors_XML_ERR_NOTATION_PROCESSING: xmlParserErrors = 105;
pub const xmlParserErrors_XML_WAR_NS_COLUMN: xmlParserErrors = 106;
pub const xmlParserErrors_XML_WAR_ENTITY_REDEFINED: xmlParserErrors = 107;
pub const xmlParserErrors_XML_ERR_UNKNOWN_VERSION: xmlParserErrors = 108;
pub const xmlParserErrors_XML_ERR_VERSION_MISMATCH: xmlParserErrors = 109;
pub const xmlParserErrors_XML_ERR_NAME_TOO_LONG: xmlParserErrors = 110;
pub const xmlParserErrors_XML_ERR_USER_STOP: xmlParserErrors = 111;
pub const xmlParserErrors_XML_NS_ERR_XML_NAMESPACE: xmlParserErrors = 200;
pub const xmlParserErrors_XML_NS_ERR_UNDEFINED_NAMESPACE: xmlParserErrors = 201;
pub const xmlParserErrors_XML_NS_ERR_QNAME: xmlParserErrors = 202;
pub const xmlParserErrors_XML_NS_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 203;
pub const xmlParserErrors_XML_NS_ERR_EMPTY: xmlParserErrors = 204;
pub const xmlParserErrors_XML_NS_ERR_COLON: xmlParserErrors = 205;
pub const xmlParserErrors_XML_DTD_ATTRIBUTE_DEFAULT: xmlParserErrors = 500;
pub const xmlParserErrors_XML_DTD_ATTRIBUTE_REDEFINED: xmlParserErrors = 501;
pub const xmlParserErrors_XML_DTD_ATTRIBUTE_VALUE: xmlParserErrors = 502;
pub const xmlParserErrors_XML_DTD_CONTENT_ERROR: xmlParserErrors = 503;
pub const xmlParserErrors_XML_DTD_CONTENT_MODEL: xmlParserErrors = 504;
pub const xmlParserErrors_XML_DTD_CONTENT_NOT_DETERMINIST: xmlParserErrors = 505;
pub const xmlParserErrors_XML_DTD_DIFFERENT_PREFIX: xmlParserErrors = 506;
pub const xmlParserErrors_XML_DTD_ELEM_DEFAULT_NAMESPACE: xmlParserErrors = 507;
pub const xmlParserErrors_XML_DTD_ELEM_NAMESPACE: xmlParserErrors = 508;
pub const xmlParserErrors_XML_DTD_ELEM_REDEFINED: xmlParserErrors = 509;
pub const xmlParserErrors_XML_DTD_EMPTY_NOTATION: xmlParserErrors = 510;
pub const xmlParserErrors_XML_DTD_ENTITY_TYPE: xmlParserErrors = 511;
pub const xmlParserErrors_XML_DTD_ID_FIXED: xmlParserErrors = 512;
pub const xmlParserErrors_XML_DTD_ID_REDEFINED: xmlParserErrors = 513;
pub const xmlParserErrors_XML_DTD_ID_SUBSET: xmlParserErrors = 514;
pub const xmlParserErrors_XML_DTD_INVALID_CHILD: xmlParserErrors = 515;
pub const xmlParserErrors_XML_DTD_INVALID_DEFAULT: xmlParserErrors = 516;
pub const xmlParserErrors_XML_DTD_LOAD_ERROR: xmlParserErrors = 517;
pub const xmlParserErrors_XML_DTD_MISSING_ATTRIBUTE: xmlParserErrors = 518;
pub const xmlParserErrors_XML_DTD_MIXED_CORRUPT: xmlParserErrors = 519;
pub const xmlParserErrors_XML_DTD_MULTIPLE_ID: xmlParserErrors = 520;
pub const xmlParserErrors_XML_DTD_NO_DOC: xmlParserErrors = 521;
pub const xmlParserErrors_XML_DTD_NO_DTD: xmlParserErrors = 522;
pub const xmlParserErrors_XML_DTD_NO_ELEM_NAME: xmlParserErrors = 523;
pub const xmlParserErrors_XML_DTD_NO_PREFIX: xmlParserErrors = 524;
pub const xmlParserErrors_XML_DTD_NO_ROOT: xmlParserErrors = 525;
pub const xmlParserErrors_XML_DTD_NOTATION_REDEFINED: xmlParserErrors = 526;
pub const xmlParserErrors_XML_DTD_NOTATION_VALUE: xmlParserErrors = 527;
pub const xmlParserErrors_XML_DTD_NOT_EMPTY: xmlParserErrors = 528;
pub const xmlParserErrors_XML_DTD_NOT_PCDATA: xmlParserErrors = 529;
pub const xmlParserErrors_XML_DTD_NOT_STANDALONE: xmlParserErrors = 530;
pub const xmlParserErrors_XML_DTD_ROOT_NAME: xmlParserErrors = 531;
pub const xmlParserErrors_XML_DTD_STANDALONE_WHITE_SPACE: xmlParserErrors = 532;
pub const xmlParserErrors_XML_DTD_UNKNOWN_ATTRIBUTE: xmlParserErrors = 533;
pub const xmlParserErrors_XML_DTD_UNKNOWN_ELEM: xmlParserErrors = 534;
pub const xmlParserErrors_XML_DTD_UNKNOWN_ENTITY: xmlParserErrors = 535;
pub const xmlParserErrors_XML_DTD_UNKNOWN_ID: xmlParserErrors = 536;
pub const xmlParserErrors_XML_DTD_UNKNOWN_NOTATION: xmlParserErrors = 537;
pub const xmlParserErrors_XML_DTD_STANDALONE_DEFAULTED: xmlParserErrors = 538;
pub const xmlParserErrors_XML_DTD_XMLID_VALUE: xmlParserErrors = 539;
pub const xmlParserErrors_XML_DTD_XMLID_TYPE: xmlParserErrors = 540;
pub const xmlParserErrors_XML_DTD_DUP_TOKEN: xmlParserErrors = 541;
pub const xmlParserErrors_XML_HTML_STRUCURE_ERROR: xmlParserErrors = 800;
pub const xmlParserErrors_XML_HTML_UNKNOWN_TAG: xmlParserErrors = 801;
pub const xmlParserErrors_XML_RNGP_ANYNAME_ATTR_ANCESTOR: xmlParserErrors = 1000;
pub const xmlParserErrors_XML_RNGP_ATTR_CONFLICT: xmlParserErrors = 1001;
pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_CHILDREN: xmlParserErrors = 1002;
pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_CONTENT: xmlParserErrors = 1003;
pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_EMPTY: xmlParserErrors = 1004;
pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_NOOP: xmlParserErrors = 1005;
pub const xmlParserErrors_XML_RNGP_CHOICE_CONTENT: xmlParserErrors = 1006;
pub const xmlParserErrors_XML_RNGP_CHOICE_EMPTY: xmlParserErrors = 1007;
pub const xmlParserErrors_XML_RNGP_CREATE_FAILURE: xmlParserErrors = 1008;
pub const xmlParserErrors_XML_RNGP_DATA_CONTENT: xmlParserErrors = 1009;
pub const xmlParserErrors_XML_RNGP_DEF_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1010;
pub const xmlParserErrors_XML_RNGP_DEFINE_CREATE_FAILED: xmlParserErrors = 1011;
pub const xmlParserErrors_XML_RNGP_DEFINE_EMPTY: xmlParserErrors = 1012;
pub const xmlParserErrors_XML_RNGP_DEFINE_MISSING: xmlParserErrors = 1013;
pub const xmlParserErrors_XML_RNGP_DEFINE_NAME_MISSING: xmlParserErrors = 1014;
pub const xmlParserErrors_XML_RNGP_ELEM_CONTENT_EMPTY: xmlParserErrors = 1015;
pub const xmlParserErrors_XML_RNGP_ELEM_CONTENT_ERROR: xmlParserErrors = 1016;
pub const xmlParserErrors_XML_RNGP_ELEMENT_EMPTY: xmlParserErrors = 1017;
pub const xmlParserErrors_XML_RNGP_ELEMENT_CONTENT: xmlParserErrors = 1018;
pub const xmlParserErrors_XML_RNGP_ELEMENT_NAME: xmlParserErrors = 1019;
pub const xmlParserErrors_XML_RNGP_ELEMENT_NO_CONTENT: xmlParserErrors = 1020;
pub const xmlParserErrors_XML_RNGP_ELEM_TEXT_CONFLICT: xmlParserErrors = 1021;
pub const xmlParserErrors_XML_RNGP_EMPTY: xmlParserErrors = 1022;
pub const xmlParserErrors_XML_RNGP_EMPTY_CONSTRUCT: xmlParserErrors = 1023;
pub const xmlParserErrors_XML_RNGP_EMPTY_CONTENT: xmlParserErrors = 1024;
pub const xmlParserErrors_XML_RNGP_EMPTY_NOT_EMPTY: xmlParserErrors = 1025;
pub const xmlParserErrors_XML_RNGP_ERROR_TYPE_LIB: xmlParserErrors = 1026;
pub const xmlParserErrors_XML_RNGP_EXCEPT_EMPTY: xmlParserErrors = 1027;
pub const xmlParserErrors_XML_RNGP_EXCEPT_MISSING: xmlParserErrors = 1028;
pub const xmlParserErrors_XML_RNGP_EXCEPT_MULTIPLE: xmlParserErrors = 1029;
pub const xmlParserErrors_XML_RNGP_EXCEPT_NO_CONTENT: xmlParserErrors = 1030;
pub const xmlParserErrors_XML_RNGP_EXTERNALREF_EMTPY: xmlParserErrors = 1031;
pub const xmlParserErrors_XML_RNGP_EXTERNAL_REF_FAILURE: xmlParserErrors = 1032;
pub const xmlParserErrors_XML_RNGP_EXTERNALREF_RECURSE: xmlParserErrors = 1033;
pub const xmlParserErrors_XML_RNGP_FORBIDDEN_ATTRIBUTE: xmlParserErrors = 1034;
pub const xmlParserErrors_XML_RNGP_FOREIGN_ELEMENT: xmlParserErrors = 1035;
pub const xmlParserErrors_XML_RNGP_GRAMMAR_CONTENT: xmlParserErrors = 1036;
pub const xmlParserErrors_XML_RNGP_GRAMMAR_EMPTY: xmlParserErrors = 1037;
pub const xmlParserErrors_XML_RNGP_GRAMMAR_MISSING: xmlParserErrors = 1038;
pub const xmlParserErrors_XML_RNGP_GRAMMAR_NO_START: xmlParserErrors = 1039;
pub const xmlParserErrors_XML_RNGP_GROUP_ATTR_CONFLICT: xmlParserErrors = 1040;
pub const xmlParserErrors_XML_RNGP_HREF_ERROR: xmlParserErrors = 1041;
pub const xmlParserErrors_XML_RNGP_INCLUDE_EMPTY: xmlParserErrors = 1042;
pub const xmlParserErrors_XML_RNGP_INCLUDE_FAILURE: xmlParserErrors = 1043;
pub const xmlParserErrors_XML_RNGP_INCLUDE_RECURSE: xmlParserErrors = 1044;
pub const xmlParserErrors_XML_RNGP_INTERLEAVE_ADD: xmlParserErrors = 1045;
pub const xmlParserErrors_XML_RNGP_INTERLEAVE_CREATE_FAILED: xmlParserErrors = 1046;
pub const xmlParserErrors_XML_RNGP_INTERLEAVE_EMPTY: xmlParserErrors = 1047;
pub const xmlParserErrors_XML_RNGP_INTERLEAVE_NO_CONTENT: xmlParserErrors = 1048;
pub const xmlParserErrors_XML_RNGP_INVALID_DEFINE_NAME: xmlParserErrors = 1049;
pub const xmlParserErrors_XML_RNGP_INVALID_URI: xmlParserErrors = 1050;
pub const xmlParserErrors_XML_RNGP_INVALID_VALUE: xmlParserErrors = 1051;
pub const xmlParserErrors_XML_RNGP_MISSING_HREF: xmlParserErrors = 1052;
pub const xmlParserErrors_XML_RNGP_NAME_MISSING: xmlParserErrors = 1053;
pub const xmlParserErrors_XML_RNGP_NEED_COMBINE: xmlParserErrors = 1054;
pub const xmlParserErrors_XML_RNGP_NOTALLOWED_NOT_EMPTY: xmlParserErrors = 1055;
pub const xmlParserErrors_XML_RNGP_NSNAME_ATTR_ANCESTOR: xmlParserErrors = 1056;
pub const xmlParserErrors_XML_RNGP_NSNAME_NO_NS: xmlParserErrors = 1057;
pub const xmlParserErrors_XML_RNGP_PARAM_FORBIDDEN: xmlParserErrors = 1058;
pub const xmlParserErrors_XML_RNGP_PARAM_NAME_MISSING: xmlParserErrors = 1059;
pub const xmlParserErrors_XML_RNGP_PARENTREF_CREATE_FAILED: xmlParserErrors = 1060;
pub const xmlParserErrors_XML_RNGP_PARENTREF_NAME_INVALID: xmlParserErrors = 1061;
pub const xmlParserErrors_XML_RNGP_PARENTREF_NO_NAME: xmlParserErrors = 1062;
pub const xmlParserErrors_XML_RNGP_PARENTREF_NO_PARENT: xmlParserErrors = 1063;
pub const xmlParserErrors_XML_RNGP_PARENTREF_NOT_EMPTY: xmlParserErrors = 1064;
pub const xmlParserErrors_XML_RNGP_PARSE_ERROR: xmlParserErrors = 1065;
pub const xmlParserErrors_XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME: xmlParserErrors = 1066;
pub const xmlParserErrors_XML_RNGP_PAT_ATTR_ATTR: xmlParserErrors = 1067;
pub const xmlParserErrors_XML_RNGP_PAT_ATTR_ELEM: xmlParserErrors = 1068;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_ATTR: xmlParserErrors = 1069;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_ELEM: xmlParserErrors = 1070;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_EMPTY: xmlParserErrors = 1071;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_GROUP: xmlParserErrors = 1072;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE: xmlParserErrors = 1073;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_LIST: xmlParserErrors = 1074;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_ONEMORE: xmlParserErrors = 1075;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_REF: xmlParserErrors = 1076;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_TEXT: xmlParserErrors = 1077;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_ATTR: xmlParserErrors = 1078;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_ELEM: xmlParserErrors = 1079;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_INTERLEAVE: xmlParserErrors = 1080;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_LIST: xmlParserErrors = 1081;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_REF: xmlParserErrors = 1082;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_TEXT: xmlParserErrors = 1083;
pub const xmlParserErrors_XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME: xmlParserErrors = 1084;
pub const xmlParserErrors_XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME: xmlParserErrors = 1085;
pub const xmlParserErrors_XML_RNGP_PAT_ONEMORE_GROUP_ATTR: xmlParserErrors = 1086;
pub const xmlParserErrors_XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR: xmlParserErrors = 1087;
pub const xmlParserErrors_XML_RNGP_PAT_START_ATTR: xmlParserErrors = 1088;
pub const xmlParserErrors_XML_RNGP_PAT_START_DATA: xmlParserErrors = 1089;
pub const xmlParserErrors_XML_RNGP_PAT_START_EMPTY: xmlParserErrors = 1090;
pub const xmlParserErrors_XML_RNGP_PAT_START_GROUP: xmlParserErrors = 1091;
pub const xmlParserErrors_XML_RNGP_PAT_START_INTERLEAVE: xmlParserErrors = 1092;
pub const xmlParserErrors_XML_RNGP_PAT_START_LIST: xmlParserErrors = 1093;
pub const xmlParserErrors_XML_RNGP_PAT_START_ONEMORE: xmlParserErrors = 1094;
pub const xmlParserErrors_XML_RNGP_PAT_START_TEXT: xmlParserErrors = 1095;
pub const xmlParserErrors_XML_RNGP_PAT_START_VALUE: xmlParserErrors = 1096;
pub const xmlParserErrors_XML_RNGP_PREFIX_UNDEFINED: xmlParserErrors = 1097;
pub const xmlParserErrors_XML_RNGP_REF_CREATE_FAILED: xmlParserErrors = 1098;
pub const xmlParserErrors_XML_RNGP_REF_CYCLE: xmlParserErrors = 1099;
pub const xmlParserErrors_XML_RNGP_REF_NAME_INVALID: xmlParserErrors = 1100;
pub const xmlParserErrors_XML_RNGP_REF_NO_DEF: xmlParserErrors = 1101;
pub const xmlParserErrors_XML_RNGP_REF_NO_NAME: xmlParserErrors = 1102;
pub const xmlParserErrors_XML_RNGP_REF_NOT_EMPTY: xmlParserErrors = 1103;
pub const xmlParserErrors_XML_RNGP_START_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1104;
pub const xmlParserErrors_XML_RNGP_START_CONTENT: xmlParserErrors = 1105;
pub const xmlParserErrors_XML_RNGP_START_EMPTY: xmlParserErrors = 1106;
pub const xmlParserErrors_XML_RNGP_START_MISSING: xmlParserErrors = 1107;
pub const xmlParserErrors_XML_RNGP_TEXT_EXPECTED: xmlParserErrors = 1108;
pub const xmlParserErrors_XML_RNGP_TEXT_HAS_CHILD: xmlParserErrors = 1109;
pub const xmlParserErrors_XML_RNGP_TYPE_MISSING: xmlParserErrors = 1110;
pub const xmlParserErrors_XML_RNGP_TYPE_NOT_FOUND: xmlParserErrors = 1111;
pub const xmlParserErrors_XML_RNGP_TYPE_VALUE: xmlParserErrors = 1112;
pub const xmlParserErrors_XML_RNGP_UNKNOWN_ATTRIBUTE: xmlParserErrors = 1113;
pub const xmlParserErrors_XML_RNGP_UNKNOWN_COMBINE: xmlParserErrors = 1114;
pub const xmlParserErrors_XML_RNGP_UNKNOWN_CONSTRUCT: xmlParserErrors = 1115;
pub const xmlParserErrors_XML_RNGP_UNKNOWN_TYPE_LIB: xmlParserErrors = 1116;
pub const xmlParserErrors_XML_RNGP_URI_FRAGMENT: xmlParserErrors = 1117;
pub const xmlParserErrors_XML_RNGP_URI_NOT_ABSOLUTE: xmlParserErrors = 1118;
pub const xmlParserErrors_XML_RNGP_VALUE_EMPTY: xmlParserErrors = 1119;
pub const xmlParserErrors_XML_RNGP_VALUE_NO_CONTENT: xmlParserErrors = 1120;
pub const xmlParserErrors_XML_RNGP_XMLNS_NAME: xmlParserErrors = 1121;
pub const xmlParserErrors_XML_RNGP_XML_NS: xmlParserErrors = 1122;
pub const xmlParserErrors_XML_XPATH_EXPRESSION_OK: xmlParserErrors = 1200;
pub const xmlParserErrors_XML_XPATH_NUMBER_ERROR: xmlParserErrors = 1201;
pub const xmlParserErrors_XML_XPATH_UNFINISHED_LITERAL_ERROR: xmlParserErrors = 1202;
pub const xmlParserErrors_XML_XPATH_START_LITERAL_ERROR: xmlParserErrors = 1203;
pub const xmlParserErrors_XML_XPATH_VARIABLE_REF_ERROR: xmlParserErrors = 1204;
pub const xmlParserErrors_XML_XPATH_UNDEF_VARIABLE_ERROR: xmlParserErrors = 1205;
pub const xmlParserErrors_XML_XPATH_INVALID_PREDICATE_ERROR: xmlParserErrors = 1206;
pub const xmlParserErrors_XML_XPATH_EXPR_ERROR: xmlParserErrors = 1207;
pub const xmlParserErrors_XML_XPATH_UNCLOSED_ERROR: xmlParserErrors = 1208;
pub const xmlParserErrors_XML_XPATH_UNKNOWN_FUNC_ERROR: xmlParserErrors = 1209;
pub const xmlParserErrors_XML_XPATH_INVALID_OPERAND: xmlParserErrors = 1210;
pub const xmlParserErrors_XML_XPATH_INVALID_TYPE: xmlParserErrors = 1211;
pub const xmlParserErrors_XML_XPATH_INVALID_ARITY: xmlParserErrors = 1212;
pub const xmlParserErrors_XML_XPATH_INVALID_CTXT_SIZE: xmlParserErrors = 1213;
pub const xmlParserErrors_XML_XPATH_INVALID_CTXT_POSITION: xmlParserErrors = 1214;
pub const xmlParserErrors_XML_XPATH_MEMORY_ERROR: xmlParserErrors = 1215;
pub const xmlParserErrors_XML_XPTR_SYNTAX_ERROR: xmlParserErrors = 1216;
pub const xmlParserErrors_XML_XPTR_RESOURCE_ERROR: xmlParserErrors = 1217;
pub const xmlParserErrors_XML_XPTR_SUB_RESOURCE_ERROR: xmlParserErrors = 1218;
pub const xmlParserErrors_XML_XPATH_UNDEF_PREFIX_ERROR: xmlParserErrors = 1219;
pub const xmlParserErrors_XML_XPATH_ENCODING_ERROR: xmlParserErrors = 1220;
pub const xmlParserErrors_XML_XPATH_INVALID_CHAR_ERROR: xmlParserErrors = 1221;
pub const xmlParserErrors_XML_TREE_INVALID_HEX: xmlParserErrors = 1300;
pub const xmlParserErrors_XML_TREE_INVALID_DEC: xmlParserErrors = 1301;
pub const xmlParserErrors_XML_TREE_UNTERMINATED_ENTITY: xmlParserErrors = 1302;
pub const xmlParserErrors_XML_TREE_NOT_UTF8: xmlParserErrors = 1303;
pub const xmlParserErrors_XML_SAVE_NOT_UTF8: xmlParserErrors = 1400;
pub const xmlParserErrors_XML_SAVE_CHAR_INVALID: xmlParserErrors = 1401;
pub const xmlParserErrors_XML_SAVE_NO_DOCTYPE: xmlParserErrors = 1402;
pub const xmlParserErrors_XML_SAVE_UNKNOWN_ENCODING: xmlParserErrors = 1403;
pub const xmlParserErrors_XML_REGEXP_COMPILE_ERROR: xmlParserErrors = 1450;
pub const xmlParserErrors_XML_IO_UNKNOWN: xmlParserErrors = 1500;
pub const xmlParserErrors_XML_IO_EACCES: xmlParserErrors = 1501;
pub const xmlParserErrors_XML_IO_EAGAIN: xmlParserErrors = 1502;
pub const xmlParserErrors_XML_IO_EBADF: xmlParserErrors = 1503;
pub const xmlParserErrors_XML_IO_EBADMSG: xmlParserErrors = 1504;
pub const xmlParserErrors_XML_IO_EBUSY: xmlParserErrors = 1505;
pub const xmlParserErrors_XML_IO_ECANCELED: xmlParserErrors = 1506;
pub const xmlParserErrors_XML_IO_ECHILD: xmlParserErrors = 1507;
pub const xmlParserErrors_XML_IO_EDEADLK: xmlParserErrors = 1508;
pub const xmlParserErrors_XML_IO_EDOM: xmlParserErrors = 1509;
pub const xmlParserErrors_XML_IO_EEXIST: xmlParserErrors = 1510;
pub const xmlParserErrors_XML_IO_EFAULT: xmlParserErrors = 1511;
pub const xmlParserErrors_XML_IO_EFBIG: xmlParserErrors = 1512;
pub const xmlParserErrors_XML_IO_EINPROGRESS: xmlParserErrors = 1513;
pub const xmlParserErrors_XML_IO_EINTR: xmlParserErrors = 1514;
pub const xmlParserErrors_XML_IO_EINVAL: xmlParserErrors = 1515;
pub const xmlParserErrors_XML_IO_EIO: xmlParserErrors = 1516;
pub const xmlParserErrors_XML_IO_EISDIR: xmlParserErrors = 1517;
pub const xmlParserErrors_XML_IO_EMFILE: xmlParserErrors = 1518;
pub const xmlParserErrors_XML_IO_EMLINK: xmlParserErrors = 1519;
pub const xmlParserErrors_XML_IO_EMSGSIZE: xmlParserErrors = 1520;
pub const xmlParserErrors_XML_IO_ENAMETOOLONG: xmlParserErrors = 1521;
pub const xmlParserErrors_XML_IO_ENFILE: xmlParserErrors = 1522;
pub const xmlParserErrors_XML_IO_ENODEV: xmlParserErrors = 1523;
pub const xmlParserErrors_XML_IO_ENOENT: xmlParserErrors = 1524;
pub const xmlParserErrors_XML_IO_ENOEXEC: xmlParserErrors = 1525;
pub const xmlParserErrors_XML_IO_ENOLCK: xmlParserErrors = 1526;
pub const xmlParserErrors_XML_IO_ENOMEM: xmlParserErrors = 1527;
pub const xmlParserErrors_XML_IO_ENOSPC: xmlParserErrors = 1528;
pub const xmlParserErrors_XML_IO_ENOSYS: xmlParserErrors = 1529;
pub const xmlParserErrors_XML_IO_ENOTDIR: xmlParserErrors = 1530;
pub const xmlParserErrors_XML_IO_ENOTEMPTY: xmlParserErrors = 1531;
pub const xmlParserErrors_XML_IO_ENOTSUP: xmlParserErrors = 1532;
pub const xmlParserErrors_XML_IO_ENOTTY: xmlParserErrors = 1533;
pub const xmlParserErrors_XML_IO_ENXIO: xmlParserErrors = 1534;
pub const xmlParserErrors_XML_IO_EPERM: xmlParserErrors = 1535;
pub const xmlParserErrors_XML_IO_EPIPE: xmlParserErrors = 1536;
pub const xmlParserErrors_XML_IO_ERANGE: xmlParserErrors = 1537;
pub const xmlParserErrors_XML_IO_EROFS: xmlParserErrors = 1538;
pub const xmlParserErrors_XML_IO_ESPIPE: xmlParserErrors = 1539;
pub const xmlParserErrors_XML_IO_ESRCH: xmlParserErrors = 1540;
pub const xmlParserErrors_XML_IO_ETIMEDOUT: xmlParserErrors = 1541;
pub const xmlParserErrors_XML_IO_EXDEV: xmlParserErrors = 1542;
pub const xmlParserErrors_XML_IO_NETWORK_ATTEMPT: xmlParserErrors = 1543;
pub const xmlParserErrors_XML_IO_ENCODER: xmlParserErrors = 1544;
pub const xmlParserErrors_XML_IO_FLUSH: xmlParserErrors = 1545;
pub const xmlParserErrors_XML_IO_WRITE: xmlParserErrors = 1546;
pub const xmlParserErrors_XML_IO_NO_INPUT: xmlParserErrors = 1547;
pub const xmlParserErrors_XML_IO_BUFFER_FULL: xmlParserErrors = 1548;
pub const xmlParserErrors_XML_IO_LOAD_ERROR: xmlParserErrors = 1549;
pub const xmlParserErrors_XML_IO_ENOTSOCK: xmlParserErrors = 1550;
pub const xmlParserErrors_XML_IO_EISCONN: xmlParserErrors = 1551;
pub const xmlParserErrors_XML_IO_ECONNREFUSED: xmlParserErrors = 1552;
pub const xmlParserErrors_XML_IO_ENETUNREACH: xmlParserErrors = 1553;
pub const xmlParserErrors_XML_IO_EADDRINUSE: xmlParserErrors = 1554;
pub const xmlParserErrors_XML_IO_EALREADY: xmlParserErrors = 1555;
pub const xmlParserErrors_XML_IO_EAFNOSUPPORT: xmlParserErrors = 1556;
pub const xmlParserErrors_XML_XINCLUDE_RECURSION: xmlParserErrors = 1600;
pub const xmlParserErrors_XML_XINCLUDE_PARSE_VALUE: xmlParserErrors = 1601;
pub const xmlParserErrors_XML_XINCLUDE_ENTITY_DEF_MISMATCH: xmlParserErrors = 1602;
pub const xmlParserErrors_XML_XINCLUDE_NO_HREF: xmlParserErrors = 1603;
pub const xmlParserErrors_XML_XINCLUDE_NO_FALLBACK: xmlParserErrors = 1604;
pub const xmlParserErrors_XML_XINCLUDE_HREF_URI: xmlParserErrors = 1605;
pub const xmlParserErrors_XML_XINCLUDE_TEXT_FRAGMENT: xmlParserErrors = 1606;
pub const xmlParserErrors_XML_XINCLUDE_TEXT_DOCUMENT: xmlParserErrors = 1607;
pub const xmlParserErrors_XML_XINCLUDE_INVALID_CHAR: xmlParserErrors = 1608;
pub const xmlParserErrors_XML_XINCLUDE_BUILD_FAILED: xmlParserErrors = 1609;
pub const xmlParserErrors_XML_XINCLUDE_UNKNOWN_ENCODING: xmlParserErrors = 1610;
pub const xmlParserErrors_XML_XINCLUDE_MULTIPLE_ROOT: xmlParserErrors = 1611;
pub const xmlParserErrors_XML_XINCLUDE_XPTR_FAILED: xmlParserErrors = 1612;
pub const xmlParserErrors_XML_XINCLUDE_XPTR_RESULT: xmlParserErrors = 1613;
pub const xmlParserErrors_XML_XINCLUDE_INCLUDE_IN_INCLUDE: xmlParserErrors = 1614;
pub const xmlParserErrors_XML_XINCLUDE_FALLBACKS_IN_INCLUDE: xmlParserErrors = 1615;
pub const xmlParserErrors_XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE: xmlParserErrors = 1616;
pub const xmlParserErrors_XML_XINCLUDE_DEPRECATED_NS: xmlParserErrors = 1617;
pub const xmlParserErrors_XML_XINCLUDE_FRAGMENT_ID: xmlParserErrors = 1618;
pub const xmlParserErrors_XML_CATALOG_MISSING_ATTR: xmlParserErrors = 1650;
pub const xmlParserErrors_XML_CATALOG_ENTRY_BROKEN: xmlParserErrors = 1651;
pub const xmlParserErrors_XML_CATALOG_PREFER_VALUE: xmlParserErrors = 1652;
pub const xmlParserErrors_XML_CATALOG_NOT_CATALOG: xmlParserErrors = 1653;
pub const xmlParserErrors_XML_CATALOG_RECURSION: xmlParserErrors = 1654;
pub const xmlParserErrors_XML_SCHEMAP_PREFIX_UNDEFINED: xmlParserErrors = 1700;
pub const xmlParserErrors_XML_SCHEMAP_ATTRFORMDEFAULT_VALUE: xmlParserErrors = 1701;
pub const xmlParserErrors_XML_SCHEMAP_ATTRGRP_NONAME_NOREF: xmlParserErrors = 1702;
pub const xmlParserErrors_XML_SCHEMAP_ATTR_NONAME_NOREF: xmlParserErrors = 1703;
pub const xmlParserErrors_XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF: xmlParserErrors = 1704;
pub const xmlParserErrors_XML_SCHEMAP_ELEMFORMDEFAULT_VALUE: xmlParserErrors = 1705;
pub const xmlParserErrors_XML_SCHEMAP_ELEM_NONAME_NOREF: xmlParserErrors = 1706;
pub const xmlParserErrors_XML_SCHEMAP_EXTENSION_NO_BASE: xmlParserErrors = 1707;
pub const xmlParserErrors_XML_SCHEMAP_FACET_NO_VALUE: xmlParserErrors = 1708;
pub const xmlParserErrors_XML_SCHEMAP_FAILED_BUILD_IMPORT: xmlParserErrors = 1709;
pub const xmlParserErrors_XML_SCHEMAP_GROUP_NONAME_NOREF: xmlParserErrors = 1710;
pub const xmlParserErrors_XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI: xmlParserErrors = 1711;
pub const xmlParserErrors_XML_SCHEMAP_IMPORT_REDEFINE_NSNAME: xmlParserErrors = 1712;
pub const xmlParserErrors_XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI: xmlParserErrors = 1713;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_BOOLEAN: xmlParserErrors = 1714;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ENUM: xmlParserErrors = 1715;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_FACET: xmlParserErrors = 1716;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_FACET_VALUE: xmlParserErrors = 1717;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_MAXOCCURS: xmlParserErrors = 1718;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_MINOCCURS: xmlParserErrors = 1719;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_REF_AND_SUBTYPE: xmlParserErrors = 1720;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_WHITE_SPACE: xmlParserErrors = 1721;
pub const xmlParserErrors_XML_SCHEMAP_NOATTR_NOREF: xmlParserErrors = 1722;
pub const xmlParserErrors_XML_SCHEMAP_NOTATION_NO_NAME: xmlParserErrors = 1723;
pub const xmlParserErrors_XML_SCHEMAP_NOTYPE_NOREF: xmlParserErrors = 1724;
pub const xmlParserErrors_XML_SCHEMAP_REF_AND_SUBTYPE: xmlParserErrors = 1725;
pub const xmlParserErrors_XML_SCHEMAP_RESTRICTION_NONAME_NOREF: xmlParserErrors = 1726;
pub const xmlParserErrors_XML_SCHEMAP_SIMPLETYPE_NONAME: xmlParserErrors = 1727;
pub const xmlParserErrors_XML_SCHEMAP_TYPE_AND_SUBTYPE: xmlParserErrors = 1728;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ALL_CHILD: xmlParserErrors = 1729;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD: xmlParserErrors = 1730;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ATTR_CHILD: xmlParserErrors = 1731;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD: xmlParserErrors = 1732;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP: xmlParserErrors = 1733;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_BASE_TYPE: xmlParserErrors = 1734;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_CHOICE_CHILD: xmlParserErrors = 1735;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD: xmlParserErrors = 1736;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD: xmlParserErrors = 1737;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ELEM_CHILD: xmlParserErrors = 1738;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD: xmlParserErrors = 1739;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_FACET_CHILD: xmlParserErrors = 1740;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_FACET_TYPE: xmlParserErrors = 1741;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_GROUP_CHILD: xmlParserErrors = 1742;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_IMPORT_CHILD: xmlParserErrors = 1743;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_LIST_CHILD: xmlParserErrors = 1744;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_NOTATION_CHILD: xmlParserErrors = 1745;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD: xmlParserErrors = 1746;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_REF: xmlParserErrors = 1747;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD: xmlParserErrors = 1748;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD: xmlParserErrors = 1749;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD: xmlParserErrors = 1750;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD: xmlParserErrors = 1751;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD: xmlParserErrors = 1752;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_TYPE: xmlParserErrors = 1753;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_UNION_CHILD: xmlParserErrors = 1754;
pub const xmlParserErrors_XML_SCHEMAP_ELEM_DEFAULT_FIXED: xmlParserErrors = 1755;
pub const xmlParserErrors_XML_SCHEMAP_REGEXP_INVALID: xmlParserErrors = 1756;
pub const xmlParserErrors_XML_SCHEMAP_FAILED_LOAD: xmlParserErrors = 1757;
pub const xmlParserErrors_XML_SCHEMAP_NOTHING_TO_PARSE: xmlParserErrors = 1758;
pub const xmlParserErrors_XML_SCHEMAP_NOROOT: xmlParserErrors = 1759;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_GROUP: xmlParserErrors = 1760;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_TYPE: xmlParserErrors = 1761;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_ELEMENT: xmlParserErrors = 1762;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_ATTRGROUP: xmlParserErrors = 1763;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_ATTR: xmlParserErrors = 1764;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_NOTATION: xmlParserErrors = 1765;
pub const xmlParserErrors_XML_SCHEMAP_FAILED_PARSE: xmlParserErrors = 1766;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_PREFIX: xmlParserErrors = 1767;
pub const xmlParserErrors_XML_SCHEMAP_DEF_AND_PREFIX: xmlParserErrors = 1768;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD: xmlParserErrors = 1769;
pub const xmlParserErrors_XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI: xmlParserErrors = 1770;
pub const xmlParserErrors_XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI: xmlParserErrors = 1771;
pub const xmlParserErrors_XML_SCHEMAP_NOT_SCHEMA: xmlParserErrors = 1772;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_MEMBER_TYPE: xmlParserErrors = 1773;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_USE: xmlParserErrors = 1774;
pub const xmlParserErrors_XML_SCHEMAP_RECURSIVE: xmlParserErrors = 1775;
pub const xmlParserErrors_XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE: xmlParserErrors = 1776;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_COMBINATION: xmlParserErrors = 1777;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION: xmlParserErrors = 1778;
pub const xmlParserErrors_XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD: xmlParserErrors = 1779;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_NAME: xmlParserErrors = 1780;
pub const xmlParserErrors_XML_SCHEMAP_REF_AND_CONTENT: xmlParserErrors = 1781;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_1: xmlParserErrors = 1782;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_2: xmlParserErrors = 1783;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_3: xmlParserErrors = 1784;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_4: xmlParserErrors = 1785;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_5: xmlParserErrors = 1786;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1: xmlParserErrors = 1787;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1: xmlParserErrors = 1788;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2: xmlParserErrors = 1789;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2: xmlParserErrors = 1790;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3: xmlParserErrors = 1791;
pub const xmlParserErrors_XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER: xmlParserErrors = 1792;
pub const xmlParserErrors_XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE: xmlParserErrors = 1793;
pub const xmlParserErrors_XML_SCHEMAP_UNION_NOT_EXPRESSIBLE: xmlParserErrors = 1794;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_3_1: xmlParserErrors = 1795;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_3_2: xmlParserErrors = 1796;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1: xmlParserErrors = 1797;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2: xmlParserErrors = 1798;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3: xmlParserErrors = 1799;
pub const xmlParserErrors_XML_SCHEMAP_COS_CT_EXTENDS_1_3: xmlParserErrors = 1800;
pub const xmlParserErrors_XML_SCHEMAV_NOROOT: xmlParserErrors = 1801;
pub const xmlParserErrors_XML_SCHEMAV_UNDECLAREDELEM: xmlParserErrors = 1802;
pub const xmlParserErrors_XML_SCHEMAV_NOTTOPLEVEL: xmlParserErrors = 1803;
pub const xmlParserErrors_XML_SCHEMAV_MISSING: xmlParserErrors = 1804;
pub const xmlParserErrors_XML_SCHEMAV_WRONGELEM: xmlParserErrors = 1805;
pub const xmlParserErrors_XML_SCHEMAV_NOTYPE: xmlParserErrors = 1806;
pub const xmlParserErrors_XML_SCHEMAV_NOROLLBACK: xmlParserErrors = 1807;
pub const xmlParserErrors_XML_SCHEMAV_ISABSTRACT: xmlParserErrors = 1808;
pub const xmlParserErrors_XML_SCHEMAV_NOTEMPTY: xmlParserErrors = 1809;
pub const xmlParserErrors_XML_SCHEMAV_ELEMCONT: xmlParserErrors = 1810;
pub const xmlParserErrors_XML_SCHEMAV_HAVEDEFAULT: xmlParserErrors = 1811;
pub const xmlParserErrors_XML_SCHEMAV_NOTNILLABLE: xmlParserErrors = 1812;
pub const xmlParserErrors_XML_SCHEMAV_EXTRACONTENT: xmlParserErrors = 1813;
pub const xmlParserErrors_XML_SCHEMAV_INVALIDATTR: xmlParserErrors = 1814;
pub const xmlParserErrors_XML_SCHEMAV_INVALIDELEM: xmlParserErrors = 1815;
pub const xmlParserErrors_XML_SCHEMAV_NOTDETERMINIST: xmlParserErrors = 1816;
pub const xmlParserErrors_XML_SCHEMAV_CONSTRUCT: xmlParserErrors = 1817;
pub const xmlParserErrors_XML_SCHEMAV_INTERNAL: xmlParserErrors = 1818;
pub const xmlParserErrors_XML_SCHEMAV_NOTSIMPLE: xmlParserErrors = 1819;
pub const xmlParserErrors_XML_SCHEMAV_ATTRUNKNOWN: xmlParserErrors = 1820;
pub const xmlParserErrors_XML_SCHEMAV_ATTRINVALID: xmlParserErrors = 1821;
pub const xmlParserErrors_XML_SCHEMAV_VALUE: xmlParserErrors = 1822;
pub const xmlParserErrors_XML_SCHEMAV_FACET: xmlParserErrors = 1823;
pub const xmlParserErrors_XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1: xmlParserErrors = 1824;
pub const xmlParserErrors_XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2: xmlParserErrors = 1825;
pub const xmlParserErrors_XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3: xmlParserErrors = 1826;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_3_1_1: xmlParserErrors = 1827;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_3_1_2: xmlParserErrors = 1828;
pub const xmlParserErrors_XML_SCHEMAV_CVC_FACET_VALID: xmlParserErrors = 1829;
pub const xmlParserErrors_XML_SCHEMAV_CVC_LENGTH_VALID: xmlParserErrors = 1830;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MINLENGTH_VALID: xmlParserErrors = 1831;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MAXLENGTH_VALID: xmlParserErrors = 1832;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MININCLUSIVE_VALID: xmlParserErrors = 1833;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID: xmlParserErrors = 1834;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID: xmlParserErrors = 1835;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID: xmlParserErrors = 1836;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TOTALDIGITS_VALID: xmlParserErrors = 1837;
pub const xmlParserErrors_XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID: xmlParserErrors = 1838;
pub const xmlParserErrors_XML_SCHEMAV_CVC_PATTERN_VALID: xmlParserErrors = 1839;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ENUMERATION_VALID: xmlParserErrors = 1840;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1: xmlParserErrors = 1841;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2: xmlParserErrors = 1842;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3: xmlParserErrors = 1843;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4: xmlParserErrors = 1844;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_1: xmlParserErrors = 1845;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_2: xmlParserErrors = 1846;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_3_1: xmlParserErrors = 1847;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_3_2_1: xmlParserErrors = 1848;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_3_2_2: xmlParserErrors = 1849;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_4_1: xmlParserErrors = 1850;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_4_2: xmlParserErrors = 1851;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_4_3: xmlParserErrors = 1852;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_1_1: xmlParserErrors = 1853;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_1_2: xmlParserErrors = 1854;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_1: xmlParserErrors = 1855;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_2_1: xmlParserErrors = 1856;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_2_2_1: xmlParserErrors = 1857;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_2_2_2: xmlParserErrors = 1858;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_6: xmlParserErrors = 1859;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_7: xmlParserErrors = 1860;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_1: xmlParserErrors = 1861;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_2: xmlParserErrors = 1862;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_3: xmlParserErrors = 1863;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_4: xmlParserErrors = 1864;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1: xmlParserErrors = 1865;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1: xmlParserErrors = 1866;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2: xmlParserErrors = 1867;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_4: xmlParserErrors = 1868;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1: xmlParserErrors = 1869;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2: xmlParserErrors = 1870;
pub const xmlParserErrors_XML_SCHEMAV_ELEMENT_CONTENT: xmlParserErrors = 1871;
pub const xmlParserErrors_XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING: xmlParserErrors = 1872;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_1: xmlParserErrors = 1873;
pub const xmlParserErrors_XML_SCHEMAV_CVC_AU: xmlParserErrors = 1874;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_1: xmlParserErrors = 1875;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_2: xmlParserErrors = 1876;
pub const xmlParserErrors_XML_SCHEMAV_CVC_IDC: xmlParserErrors = 1877;
pub const xmlParserErrors_XML_SCHEMAV_CVC_WILDCARD: xmlParserErrors = 1878;
pub const xmlParserErrors_XML_SCHEMAV_MISC: xmlParserErrors = 1879;
pub const xmlParserErrors_XML_XPTR_UNKNOWN_SCHEME: xmlParserErrors = 1900;
pub const xmlParserErrors_XML_XPTR_CHILDSEQ_START: xmlParserErrors = 1901;
pub const xmlParserErrors_XML_XPTR_EVAL_FAILED: xmlParserErrors = 1902;
pub const xmlParserErrors_XML_XPTR_EXTRA_OBJECTS: xmlParserErrors = 1903;
pub const xmlParserErrors_XML_C14N_CREATE_CTXT: xmlParserErrors = 1950;
pub const xmlParserErrors_XML_C14N_REQUIRES_UTF8: xmlParserErrors = 1951;
pub const xmlParserErrors_XML_C14N_CREATE_STACK: xmlParserErrors = 1952;
pub const xmlParserErrors_XML_C14N_INVALID_NODE: xmlParserErrors = 1953;
pub const xmlParserErrors_XML_C14N_UNKNOW_NODE: xmlParserErrors = 1954;
pub const xmlParserErrors_XML_C14N_RELATIVE_NAMESPACE: xmlParserErrors = 1955;
pub const xmlParserErrors_XML_FTP_PASV_ANSWER: xmlParserErrors = 2000;
pub const xmlParserErrors_XML_FTP_EPSV_ANSWER: xmlParserErrors = 2001;
pub const xmlParserErrors_XML_FTP_ACCNT: xmlParserErrors = 2002;
pub const xmlParserErrors_XML_FTP_URL_SYNTAX: xmlParserErrors = 2003;
pub const xmlParserErrors_XML_HTTP_URL_SYNTAX: xmlParserErrors = 2020;
pub const xmlParserErrors_XML_HTTP_USE_IP: xmlParserErrors = 2021;
pub const xmlParserErrors_XML_HTTP_UNKNOWN_HOST: xmlParserErrors = 2022;
pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_1: xmlParserErrors = 3000;
pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_2: xmlParserErrors = 3001;
pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_3: xmlParserErrors = 3002;
pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_4: xmlParserErrors = 3003;
pub const xmlParserErrors_XML_SCHEMAP_SRC_RESOLVE: xmlParserErrors = 3004;
pub const xmlParserErrors_XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE: xmlParserErrors = 3005;
pub const xmlParserErrors_XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE: xmlParserErrors = 3006;
pub const xmlParserErrors_XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES: xmlParserErrors = 3007;
pub const xmlParserErrors_XML_SCHEMAP_ST_PROPS_CORRECT_1: xmlParserErrors = 3008;
pub const xmlParserErrors_XML_SCHEMAP_ST_PROPS_CORRECT_2: xmlParserErrors = 3009;
pub const xmlParserErrors_XML_SCHEMAP_ST_PROPS_CORRECT_3: xmlParserErrors = 3010;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_1: xmlParserErrors = 3011;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_2: xmlParserErrors = 3012;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1: xmlParserErrors = 3013;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2: xmlParserErrors = 3014;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_1: xmlParserErrors = 3015;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1: xmlParserErrors = 3016;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2: xmlParserErrors = 3017;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1: xmlParserErrors = 3018;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2: xmlParserErrors = 3019;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3: xmlParserErrors = 3020;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4: xmlParserErrors = 3021;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5: xmlParserErrors = 3022;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_1: xmlParserErrors = 3023;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1: xmlParserErrors = 3024;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2: xmlParserErrors = 3025;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2: xmlParserErrors = 3026;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1: xmlParserErrors = 3027;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3: xmlParserErrors = 3028;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4: xmlParserErrors = 3029;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5: xmlParserErrors = 3030;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_DERIVED_OK_2_1: xmlParserErrors = 3031;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_DERIVED_OK_2_2: xmlParserErrors = 3032;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED: xmlParserErrors = 3033;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ELEM_MISSING: xmlParserErrors = 3034;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED: xmlParserErrors = 3035;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ATTR_MISSING: xmlParserErrors = 3036;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ATTR_INVALID_VALUE: xmlParserErrors = 3037;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_1: xmlParserErrors = 3038;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_2_1: xmlParserErrors = 3039;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_2_2: xmlParserErrors = 3040;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_3: xmlParserErrors = 3041;
pub const xmlParserErrors_XML_SCHEMAP_P_PROPS_CORRECT_1: xmlParserErrors = 3042;
pub const xmlParserErrors_XML_SCHEMAP_P_PROPS_CORRECT_2_1: xmlParserErrors = 3043;
pub const xmlParserErrors_XML_SCHEMAP_P_PROPS_CORRECT_2_2: xmlParserErrors = 3044;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_2: xmlParserErrors = 3045;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_3: xmlParserErrors = 3046;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_4: xmlParserErrors = 3047;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_5: xmlParserErrors = 3048;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_6: xmlParserErrors = 3049;
pub const xmlParserErrors_XML_SCHEMAP_SRC_INCLUDE: xmlParserErrors = 3050;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_1: xmlParserErrors = 3051;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_2: xmlParserErrors = 3052;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_3_1: xmlParserErrors = 3053;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_3_2: xmlParserErrors = 3054;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_4: xmlParserErrors = 3055;
pub const xmlParserErrors_XML_SCHEMAP_NO_XMLNS: xmlParserErrors = 3056;
pub const xmlParserErrors_XML_SCHEMAP_NO_XSI: xmlParserErrors = 3057;
pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_1: xmlParserErrors = 3058;
pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_2_1: xmlParserErrors = 3059;
pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1: xmlParserErrors = 3060;
pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2: xmlParserErrors = 3061;
pub const xmlParserErrors_XML_SCHEMAP_CVC_SIMPLE_TYPE: xmlParserErrors = 3062;
pub const xmlParserErrors_XML_SCHEMAP_COS_CT_EXTENDS_1_1: xmlParserErrors = 3063;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_1_1: xmlParserErrors = 3064;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_1_2: xmlParserErrors = 3065;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_2: xmlParserErrors = 3066;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_2_1: xmlParserErrors = 3067;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_2_2: xmlParserErrors = 3068;
pub const xmlParserErrors_XML_SCHEMAP_INTERNAL: xmlParserErrors = 3069;
pub const xmlParserErrors_XML_SCHEMAP_NOT_DETERMINISTIC: xmlParserErrors = 3070;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1: xmlParserErrors = 3071;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2: xmlParserErrors = 3072;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3: xmlParserErrors = 3073;
pub const xmlParserErrors_XML_SCHEMAP_MG_PROPS_CORRECT_1: xmlParserErrors = 3074;
pub const xmlParserErrors_XML_SCHEMAP_MG_PROPS_CORRECT_2: xmlParserErrors = 3075;
pub const xmlParserErrors_XML_SCHEMAP_SRC_CT_1: xmlParserErrors = 3076;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3: xmlParserErrors = 3077;
pub const xmlParserErrors_XML_SCHEMAP_AU_PROPS_CORRECT_2: xmlParserErrors = 3078;
pub const xmlParserErrors_XML_SCHEMAP_A_PROPS_CORRECT_2: xmlParserErrors = 3079;
pub const xmlParserErrors_XML_SCHEMAP_C_PROPS_CORRECT: xmlParserErrors = 3080;
pub const xmlParserErrors_XML_SCHEMAP_SRC_REDEFINE: xmlParserErrors = 3081;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT: xmlParserErrors = 3082;
pub const xmlParserErrors_XML_SCHEMAP_WARN_SKIP_SCHEMA: xmlParserErrors = 3083;
pub const xmlParserErrors_XML_SCHEMAP_WARN_UNLOCATED_SCHEMA: xmlParserErrors = 3084;
pub const xmlParserErrors_XML_SCHEMAP_WARN_ATTR_REDECL_PROH: xmlParserErrors = 3085;
pub const xmlParserErrors_XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH: xmlParserErrors = 3086;
pub const xmlParserErrors_XML_SCHEMAP_AG_PROPS_CORRECT: xmlParserErrors = 3087;
pub const xmlParserErrors_XML_SCHEMAP_COS_CT_EXTENDS_1_2: xmlParserErrors = 3088;
pub const xmlParserErrors_XML_SCHEMAP_AU_PROPS_CORRECT: xmlParserErrors = 3089;
pub const xmlParserErrors_XML_SCHEMAP_A_PROPS_CORRECT_3: xmlParserErrors = 3090;
pub const xmlParserErrors_XML_SCHEMAP_COS_ALL_LIMITED: xmlParserErrors = 3091;
pub const xmlParserErrors_XML_SCHEMATRONV_ASSERT: xmlParserErrors = 4000;
pub const xmlParserErrors_XML_SCHEMATRONV_REPORT: xmlParserErrors = 4001;
pub const xmlParserErrors_XML_MODULE_OPEN: xmlParserErrors = 4900;
pub const xmlParserErrors_XML_MODULE_CLOSE: xmlParserErrors = 4901;
pub const xmlParserErrors_XML_CHECK_FOUND_ELEMENT: xmlParserErrors = 5000;
pub const xmlParserErrors_XML_CHECK_FOUND_ATTRIBUTE: xmlParserErrors = 5001;
pub const xmlParserErrors_XML_CHECK_FOUND_TEXT: xmlParserErrors = 5002;
pub const xmlParserErrors_XML_CHECK_FOUND_CDATA: xmlParserErrors = 5003;
pub const xmlParserErrors_XML_CHECK_FOUND_ENTITYREF: xmlParserErrors = 5004;
pub const xmlParserErrors_XML_CHECK_FOUND_ENTITY: xmlParserErrors = 5005;
pub const xmlParserErrors_XML_CHECK_FOUND_PI: xmlParserErrors = 5006;
pub const xmlParserErrors_XML_CHECK_FOUND_COMMENT: xmlParserErrors = 5007;
pub const xmlParserErrors_XML_CHECK_FOUND_DOCTYPE: xmlParserErrors = 5008;
pub const xmlParserErrors_XML_CHECK_FOUND_FRAGMENT: xmlParserErrors = 5009;
pub const xmlParserErrors_XML_CHECK_FOUND_NOTATION: xmlParserErrors = 5010;
pub const xmlParserErrors_XML_CHECK_UNKNOWN_NODE: xmlParserErrors = 5011;
pub const xmlParserErrors_XML_CHECK_ENTITY_TYPE: xmlParserErrors = 5012;
pub const xmlParserErrors_XML_CHECK_NO_PARENT: xmlParserErrors = 5013;
pub const xmlParserErrors_XML_CHECK_NO_DOC: xmlParserErrors = 5014;
pub const xmlParserErrors_XML_CHECK_NO_NAME: xmlParserErrors = 5015;
pub const xmlParserErrors_XML_CHECK_NO_ELEM: xmlParserErrors = 5016;
pub const xmlParserErrors_XML_CHECK_WRONG_DOC: xmlParserErrors = 5017;
pub const xmlParserErrors_XML_CHECK_NO_PREV: xmlParserErrors = 5018;
pub const xmlParserErrors_XML_CHECK_WRONG_PREV: xmlParserErrors = 5019;
pub const xmlParserErrors_XML_CHECK_NO_NEXT: xmlParserErrors = 5020;
pub const xmlParserErrors_XML_CHECK_WRONG_NEXT: xmlParserErrors = 5021;
pub const xmlParserErrors_XML_CHECK_NOT_DTD: xmlParserErrors = 5022;
pub const xmlParserErrors_XML_CHECK_NOT_ATTR: xmlParserErrors = 5023;
pub const xmlParserErrors_XML_CHECK_NOT_ATTR_DECL: xmlParserErrors = 5024;
pub const xmlParserErrors_XML_CHECK_NOT_ELEM_DECL: xmlParserErrors = 5025;
pub const xmlParserErrors_XML_CHECK_NOT_ENTITY_DECL: xmlParserErrors = 5026;
pub const xmlParserErrors_XML_CHECK_NOT_NS_DECL: xmlParserErrors = 5027;
pub const xmlParserErrors_XML_CHECK_NO_HREF: xmlParserErrors = 5028;
pub const xmlParserErrors_XML_CHECK_WRONG_PARENT: xmlParserErrors = 5029;
pub const xmlParserErrors_XML_CHECK_NS_SCOPE: xmlParserErrors = 5030;
pub const xmlParserErrors_XML_CHECK_NS_ANCESTOR: xmlParserErrors = 5031;
pub const xmlParserErrors_XML_CHECK_NOT_UTF8: xmlParserErrors = 5032;
pub const xmlParserErrors_XML_CHECK_NO_DICT: xmlParserErrors = 5033;
pub const xmlParserErrors_XML_CHECK_NOT_NCNAME: xmlParserErrors = 5034;
pub const xmlParserErrors_XML_CHECK_OUTSIDE_DICT: xmlParserErrors = 5035;
pub const xmlParserErrors_XML_CHECK_WRONG_NAME: xmlParserErrors = 5036;
pub const xmlParserErrors_XML_CHECK_NAME_NOT_NULL: xmlParserErrors = 5037;
pub const xmlParserErrors_XML_I18N_NO_NAME: xmlParserErrors = 6000;
pub const xmlParserErrors_XML_I18N_NO_HANDLER: xmlParserErrors = 6001;
pub const xmlParserErrors_XML_I18N_EXCESS_HANDLER: xmlParserErrors = 6002;
pub const xmlParserErrors_XML_I18N_CONV_FAILED: xmlParserErrors = 6003;
pub const xmlParserErrors_XML_I18N_NO_OUTPUT: xmlParserErrors = 6004;
pub const xmlParserErrors_XML_BUF_OVERFLOW: xmlParserErrors = 7000;
#[doc = " xmlParserError:"]
#[doc = ""]
#[doc = " This is an error that the XML (or HTML) parser can generate"]
pub type xmlParserErrors = ::std::os::raw::c_int;
#[doc = " xmlGenericErrorFunc:"]
#[doc = " @ctx:  a parsing context"]
#[doc = " @msg:  the message"]
#[doc = " @...:  the extra arguments of the varargs to format the message"]
#[doc = ""]
#[doc = " Signature of the function to use when there is an error and"]
#[doc = " no parsing or validity context available ."]
pub type xmlGenericErrorFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[doc = " xmlStructuredErrorFunc:"]
#[doc = " @userData:  user provided data for the error callback"]
#[doc = " @error:  the error being raised."]
#[doc = ""]
#[doc = " Signature of the function to use when there is an error and"]
#[doc = " the module handles the new error reporting mechanism."]
pub type xmlStructuredErrorFunc = ::std::option::Option<
    unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void, error: xmlErrorPtr),
>;
extern "C" {
    pub fn xmlSetGenericErrorFunc(ctx: *mut ::std::os::raw::c_void, handler: xmlGenericErrorFunc);
}
extern "C" {
    pub fn initGenericErrorDefaultFunc(handler: *mut xmlGenericErrorFunc);
}
extern "C" {
    pub fn xmlSetStructuredErrorFunc(
        ctx: *mut ::std::os::raw::c_void,
        handler: xmlStructuredErrorFunc,
    );
}
extern "C" {
    pub fn xmlParserError(
        ctx: *mut ::std::os::raw::c_void,
        msg: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn xmlParserWarning(
        ctx: *mut ::std::os::raw::c_void,
        msg: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn xmlParserValidityError(
        ctx: *mut ::std::os::raw::c_void,
        msg: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn xmlParserValidityWarning(
        ctx: *mut ::std::os::raw::c_void,
        msg: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn xmlParserPrintFileInfo(input: xmlParserInputPtr);
}
extern "C" {
    pub fn xmlParserPrintFileContext(input: xmlParserInputPtr);
}
extern "C" {
    pub fn xmlGetLastError() -> xmlErrorPtr;
}
extern "C" {
    pub fn xmlResetLastError();
}
extern "C" {
    pub fn xmlCtxtGetLastError(ctx: *mut ::std::os::raw::c_void) -> xmlErrorPtr;
}
extern "C" {
    pub fn xmlCtxtResetLastError(ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn xmlResetError(err: xmlErrorPtr);
}
extern "C" {
    pub fn xmlCopyError(from: xmlErrorPtr, to: xmlErrorPtr) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlLink {
    _unused: [u8; 0],
}
pub type xmlLink = _xmlLink;
pub type xmlLinkPtr = *mut xmlLink;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlList {
    _unused: [u8; 0],
}
pub type xmlList = _xmlList;
pub type xmlListPtr = *mut xmlList;
#[doc = " xmlListDeallocator:"]
#[doc = " @lk:  the data to deallocate"]
#[doc = ""]
#[doc = " Callback function used to free data from a list."]
pub type xmlListDeallocator = ::std::option::Option<unsafe extern "C" fn(lk: xmlLinkPtr)>;
#[doc = " xmlListDataCompare:"]
#[doc = " @data0: the first data"]
#[doc = " @data1: the second data"]
#[doc = ""]
#[doc = " Callback function used to compare 2 data."]
#[doc = ""]
#[doc = " Returns 0 is equality, -1 or 1 otherwise depending on the ordering."]
pub type xmlListDataCompare = ::std::option::Option<
    unsafe extern "C" fn(
        data0: *const ::std::os::raw::c_void,
        data1: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlListWalker:"]
#[doc = " @data: the data found in the list"]
#[doc = " @user: extra user provided data to the walker"]
#[doc = ""]
#[doc = " Callback function used when walking a list with xmlListWalk()."]
#[doc = ""]
#[doc = " Returns 0 to stop walking the list, 1 otherwise."]
pub type xmlListWalker = ::std::option::Option<
    unsafe extern "C" fn(
        data: *const ::std::os::raw::c_void,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn xmlListCreate(
        deallocator: xmlListDeallocator,
        compare: xmlListDataCompare,
    ) -> xmlListPtr;
}
extern "C" {
    pub fn xmlListDelete(l: xmlListPtr);
}
extern "C" {
    pub fn xmlListSearch(
        l: xmlListPtr,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlListReverseSearch(
        l: xmlListPtr,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlListInsert(l: xmlListPtr, data: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlListAppend(l: xmlListPtr, data: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlListRemoveFirst(
        l: xmlListPtr,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlListRemoveLast(
        l: xmlListPtr,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlListRemoveAll(
        l: xmlListPtr,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlListClear(l: xmlListPtr);
}
extern "C" {
    pub fn xmlListEmpty(l: xmlListPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlListFront(l: xmlListPtr) -> xmlLinkPtr;
}
extern "C" {
    pub fn xmlListEnd(l: xmlListPtr) -> xmlLinkPtr;
}
extern "C" {
    pub fn xmlListSize(l: xmlListPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlListPopFront(l: xmlListPtr);
}
extern "C" {
    pub fn xmlListPopBack(l: xmlListPtr);
}
extern "C" {
    pub fn xmlListPushFront(
        l: xmlListPtr,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlListPushBack(
        l: xmlListPtr,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlListReverse(l: xmlListPtr);
}
extern "C" {
    pub fn xmlListSort(l: xmlListPtr);
}
extern "C" {
    pub fn xmlListWalk(l: xmlListPtr, walker: xmlListWalker, user: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn xmlListReverseWalk(
        l: xmlListPtr,
        walker: xmlListWalker,
        user: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn xmlListMerge(l1: xmlListPtr, l2: xmlListPtr);
}
extern "C" {
    pub fn xmlListDup(old: xmlListPtr) -> xmlListPtr;
}
extern "C" {
    pub fn xmlListCopy(cur: xmlListPtr, old: xmlListPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlLinkGetData(lk: xmlLinkPtr) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlAutomata {
    _unused: [u8; 0],
}
#[doc = " xmlAutomataPtr:"]
#[doc = ""]
#[doc = " A libxml automata description, It can be compiled into a regexp"]
pub type xmlAutomata = _xmlAutomata;
pub type xmlAutomataPtr = *mut xmlAutomata;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlAutomataState {
    _unused: [u8; 0],
}
#[doc = " xmlAutomataStatePtr:"]
#[doc = ""]
#[doc = " A state int the automata description,"]
pub type xmlAutomataState = _xmlAutomataState;
pub type xmlAutomataStatePtr = *mut xmlAutomataState;
extern "C" {
    pub fn xmlNewAutomata() -> xmlAutomataPtr;
}
extern "C" {
    pub fn xmlFreeAutomata(am: xmlAutomataPtr);
}
extern "C" {
    pub fn xmlAutomataGetInitState(am: xmlAutomataPtr) -> xmlAutomataStatePtr;
}
extern "C" {
    pub fn xmlAutomataSetFinalState(
        am: xmlAutomataPtr,
        state: xmlAutomataStatePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlAutomataNewState(am: xmlAutomataPtr) -> xmlAutomataStatePtr;
}
extern "C" {
    pub fn xmlAutomataNewTransition(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        token: *const xmlChar,
        data: *mut ::std::os::raw::c_void,
    ) -> xmlAutomataStatePtr;
}
extern "C" {
    pub fn xmlAutomataNewTransition2(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        token: *const xmlChar,
        token2: *const xmlChar,
        data: *mut ::std::os::raw::c_void,
    ) -> xmlAutomataStatePtr;
}
extern "C" {
    pub fn xmlAutomataNewNegTrans(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        token: *const xmlChar,
        token2: *const xmlChar,
        data: *mut ::std::os::raw::c_void,
    ) -> xmlAutomataStatePtr;
}
extern "C" {
    pub fn xmlAutomataNewCountTrans(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        token: *const xmlChar,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> xmlAutomataStatePtr;
}
extern "C" {
    pub fn xmlAutomataNewCountTrans2(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        token: *const xmlChar,
        token2: *const xmlChar,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> xmlAutomataStatePtr;
}
extern "C" {
    pub fn xmlAutomataNewOnceTrans(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        token: *const xmlChar,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> xmlAutomataStatePtr;
}
extern "C" {
    pub fn xmlAutomataNewOnceTrans2(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        token: *const xmlChar,
        token2: *const xmlChar,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> xmlAutomataStatePtr;
}
extern "C" {
    pub fn xmlAutomataNewAllTrans(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        lax: ::std::os::raw::c_int,
    ) -> xmlAutomataStatePtr;
}
extern "C" {
    pub fn xmlAutomataNewEpsilon(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
    ) -> xmlAutomataStatePtr;
}
extern "C" {
    pub fn xmlAutomataNewCountedTrans(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        counter: ::std::os::raw::c_int,
    ) -> xmlAutomataStatePtr;
}
extern "C" {
    pub fn xmlAutomataNewCounterTrans(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        counter: ::std::os::raw::c_int,
    ) -> xmlAutomataStatePtr;
}
extern "C" {
    pub fn xmlAutomataNewCounter(
        am: xmlAutomataPtr,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlAutomataCompile(am: xmlAutomataPtr) -> xmlRegexpPtr;
}
extern "C" {
    pub fn xmlAutomataIsDeterminist(am: xmlAutomataPtr) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlValidState {
    _unused: [u8; 0],
}
pub type xmlValidState = _xmlValidState;
pub type xmlValidStatePtr = *mut xmlValidState;
#[doc = " xmlValidityErrorFunc:"]
#[doc = " @ctx:  usually an xmlValidCtxtPtr to a validity error context,"]
#[doc = "        but comes from ctxt->userData (which normally contains such"]
#[doc = "        a pointer); ctxt->userData can be changed by the user."]
#[doc = " @msg:  the string to format *printf like vararg"]
#[doc = " @...:  remaining arguments to the format"]
#[doc = ""]
#[doc = " Callback called when a validity error is found. This is a message"]
#[doc = " oriented function similar to an *printf function."]
pub type xmlValidityErrorFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[doc = " xmlValidityWarningFunc:"]
#[doc = " @ctx:  usually an xmlValidCtxtPtr to a validity error context,"]
#[doc = "        but comes from ctxt->userData (which normally contains such"]
#[doc = "        a pointer); ctxt->userData can be changed by the user."]
#[doc = " @msg:  the string to format *printf like vararg"]
#[doc = " @...:  remaining arguments to the format"]
#[doc = ""]
#[doc = " Callback called when a validity warning is found. This is a message"]
#[doc = " oriented function similar to an *printf function."]
pub type xmlValidityWarningFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
pub type xmlValidCtxt = _xmlValidCtxt;
pub type xmlValidCtxtPtr = *mut xmlValidCtxt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlValidCtxt {
    pub userData: *mut ::std::os::raw::c_void,
    pub error: xmlValidityErrorFunc,
    pub warning: xmlValidityWarningFunc,
    pub node: xmlNodePtr,
    pub nodeNr: ::std::os::raw::c_int,
    pub nodeMax: ::std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub finishDtd: ::std::os::raw::c_uint,
    pub doc: xmlDocPtr,
    pub valid: ::std::os::raw::c_int,
    pub vstate: *mut xmlValidState,
    pub vstateNr: ::std::os::raw::c_int,
    pub vstateMax: ::std::os::raw::c_int,
    pub vstateTab: *mut xmlValidState,
    pub am: xmlAutomataPtr,
    pub state: xmlAutomataStatePtr,
}
#[test]
fn bindgen_test_layout__xmlValidCtxt() {
    assert_eq!(
        ::std::mem::size_of::<_xmlValidCtxt>(),
        112usize,
        concat!("Size of: ", stringify!(_xmlValidCtxt))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlValidCtxt>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlValidCtxt))
    );
    fn test_field_userData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userData) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(userData)
            )
        );
    }
    test_field_userData();
    fn test_field_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(error)
            )
        );
    }
    test_field_error();
    fn test_field_warning() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).warning) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(warning)
            )
        );
    }
    test_field_warning();
    fn test_field_node() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(node)
            )
        );
    }
    test_field_node();
    fn test_field_nodeNr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeNr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(nodeNr)
            )
        );
    }
    test_field_nodeNr();
    fn test_field_nodeMax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeMax) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(nodeMax)
            )
        );
    }
    test_field_nodeMax();
    fn test_field_nodeTab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeTab) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(nodeTab)
            )
        );
    }
    test_field_nodeTab();
    fn test_field_finishDtd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).finishDtd) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(finishDtd)
            )
        );
    }
    test_field_finishDtd();
    fn test_field_doc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(doc)
            )
        );
    }
    test_field_doc();
    fn test_field_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(valid)
            )
        );
    }
    test_field_valid();
    fn test_field_vstate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vstate) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(vstate)
            )
        );
    }
    test_field_vstate();
    fn test_field_vstateNr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vstateNr) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(vstateNr)
            )
        );
    }
    test_field_vstateNr();
    fn test_field_vstateMax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vstateMax) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(vstateMax)
            )
        );
    }
    test_field_vstateMax();
    fn test_field_vstateTab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vstateTab) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(vstateTab)
            )
        );
    }
    test_field_vstateTab();
    fn test_field_am() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).am) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(am)
            )
        );
    }
    test_field_am();
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlValidCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlValidCtxt),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
}
pub type xmlNotationTable = _xmlHashTable;
pub type xmlNotationTablePtr = *mut xmlNotationTable;
pub type xmlElementTable = _xmlHashTable;
pub type xmlElementTablePtr = *mut xmlElementTable;
pub type xmlAttributeTable = _xmlHashTable;
pub type xmlAttributeTablePtr = *mut xmlAttributeTable;
pub type xmlIDTable = _xmlHashTable;
pub type xmlIDTablePtr = *mut xmlIDTable;
pub type xmlRefTable = _xmlHashTable;
pub type xmlRefTablePtr = *mut xmlRefTable;
extern "C" {
    pub fn xmlAddNotationDecl(
        ctxt: xmlValidCtxtPtr,
        dtd: xmlDtdPtr,
        name: *const xmlChar,
        PublicID: *const xmlChar,
        SystemID: *const xmlChar,
    ) -> xmlNotationPtr;
}
extern "C" {
    pub fn xmlCopyNotationTable(table: xmlNotationTablePtr) -> xmlNotationTablePtr;
}
extern "C" {
    pub fn xmlFreeNotationTable(table: xmlNotationTablePtr);
}
extern "C" {
    pub fn xmlDumpNotationDecl(buf: xmlBufferPtr, nota: xmlNotationPtr);
}
extern "C" {
    pub fn xmlDumpNotationTable(buf: xmlBufferPtr, table: xmlNotationTablePtr);
}
extern "C" {
    pub fn xmlNewElementContent(
        name: *const xmlChar,
        type_: xmlElementContentType,
    ) -> xmlElementContentPtr;
}
extern "C" {
    pub fn xmlCopyElementContent(content: xmlElementContentPtr) -> xmlElementContentPtr;
}
extern "C" {
    pub fn xmlFreeElementContent(cur: xmlElementContentPtr);
}
extern "C" {
    pub fn xmlNewDocElementContent(
        doc: xmlDocPtr,
        name: *const xmlChar,
        type_: xmlElementContentType,
    ) -> xmlElementContentPtr;
}
extern "C" {
    pub fn xmlCopyDocElementContent(
        doc: xmlDocPtr,
        content: xmlElementContentPtr,
    ) -> xmlElementContentPtr;
}
extern "C" {
    pub fn xmlFreeDocElementContent(doc: xmlDocPtr, cur: xmlElementContentPtr);
}
extern "C" {
    pub fn xmlSnprintfElementContent(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        content: xmlElementContentPtr,
        englob: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn xmlSprintfElementContent(
        buf: *mut ::std::os::raw::c_char,
        content: xmlElementContentPtr,
        englob: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn xmlAddElementDecl(
        ctxt: xmlValidCtxtPtr,
        dtd: xmlDtdPtr,
        name: *const xmlChar,
        type_: xmlElementTypeVal,
        content: xmlElementContentPtr,
    ) -> xmlElementPtr;
}
extern "C" {
    pub fn xmlCopyElementTable(table: xmlElementTablePtr) -> xmlElementTablePtr;
}
extern "C" {
    pub fn xmlFreeElementTable(table: xmlElementTablePtr);
}
extern "C" {
    pub fn xmlDumpElementTable(buf: xmlBufferPtr, table: xmlElementTablePtr);
}
extern "C" {
    pub fn xmlDumpElementDecl(buf: xmlBufferPtr, elem: xmlElementPtr);
}
extern "C" {
    pub fn xmlCreateEnumeration(name: *const xmlChar) -> xmlEnumerationPtr;
}
extern "C" {
    pub fn xmlFreeEnumeration(cur: xmlEnumerationPtr);
}
extern "C" {
    pub fn xmlCopyEnumeration(cur: xmlEnumerationPtr) -> xmlEnumerationPtr;
}
extern "C" {
    pub fn xmlAddAttributeDecl(
        ctxt: xmlValidCtxtPtr,
        dtd: xmlDtdPtr,
        elem: *const xmlChar,
        name: *const xmlChar,
        ns: *const xmlChar,
        type_: xmlAttributeType,
        def: xmlAttributeDefault,
        defaultValue: *const xmlChar,
        tree: xmlEnumerationPtr,
    ) -> xmlAttributePtr;
}
extern "C" {
    pub fn xmlCopyAttributeTable(table: xmlAttributeTablePtr) -> xmlAttributeTablePtr;
}
extern "C" {
    pub fn xmlFreeAttributeTable(table: xmlAttributeTablePtr);
}
extern "C" {
    pub fn xmlDumpAttributeTable(buf: xmlBufferPtr, table: xmlAttributeTablePtr);
}
extern "C" {
    pub fn xmlDumpAttributeDecl(buf: xmlBufferPtr, attr: xmlAttributePtr);
}
extern "C" {
    pub fn xmlAddID(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        value: *const xmlChar,
        attr: xmlAttrPtr,
    ) -> xmlIDPtr;
}
extern "C" {
    pub fn xmlFreeIDTable(table: xmlIDTablePtr);
}
extern "C" {
    pub fn xmlGetID(doc: xmlDocPtr, ID: *const xmlChar) -> xmlAttrPtr;
}
extern "C" {
    pub fn xmlIsID(doc: xmlDocPtr, elem: xmlNodePtr, attr: xmlAttrPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlRemoveID(doc: xmlDocPtr, attr: xmlAttrPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlAddRef(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        value: *const xmlChar,
        attr: xmlAttrPtr,
    ) -> xmlRefPtr;
}
extern "C" {
    pub fn xmlFreeRefTable(table: xmlRefTablePtr);
}
extern "C" {
    pub fn xmlIsRef(doc: xmlDocPtr, elem: xmlNodePtr, attr: xmlAttrPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlRemoveRef(doc: xmlDocPtr, attr: xmlAttrPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlGetRefs(doc: xmlDocPtr, ID: *const xmlChar) -> xmlListPtr;
}
extern "C" {
    pub fn xmlNewValidCtxt() -> xmlValidCtxtPtr;
}
extern "C" {
    pub fn xmlFreeValidCtxt(arg1: xmlValidCtxtPtr);
}
extern "C" {
    pub fn xmlValidateRoot(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateElementDecl(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlElementPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidNormalizeAttributeValue(
        doc: xmlDocPtr,
        elem: xmlNodePtr,
        name: *const xmlChar,
        value: *const xmlChar,
    ) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlValidCtxtNormalizeAttributeValue(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
        name: *const xmlChar,
        value: *const xmlChar,
    ) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlValidateAttributeDecl(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        attr: xmlAttributePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateAttributeValue(
        type_: xmlAttributeType,
        value: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateNotationDecl(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        nota: xmlNotationPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateDtd(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        dtd: xmlDtdPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateDtdFinal(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateDocument(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateElement(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateOneElement(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateOneAttribute(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
        attr: xmlAttrPtr,
        value: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateOneNamespace(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
        prefix: *const xmlChar,
        ns: xmlNsPtr,
        value: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateDocumentFinal(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateNotationUse(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        notationName: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlIsMixedElement(doc: xmlDocPtr, name: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlGetDtdAttrDesc(
        dtd: xmlDtdPtr,
        elem: *const xmlChar,
        name: *const xmlChar,
    ) -> xmlAttributePtr;
}
extern "C" {
    pub fn xmlGetDtdQAttrDesc(
        dtd: xmlDtdPtr,
        elem: *const xmlChar,
        name: *const xmlChar,
        prefix: *const xmlChar,
    ) -> xmlAttributePtr;
}
extern "C" {
    pub fn xmlGetDtdNotationDesc(dtd: xmlDtdPtr, name: *const xmlChar) -> xmlNotationPtr;
}
extern "C" {
    pub fn xmlGetDtdQElementDesc(
        dtd: xmlDtdPtr,
        name: *const xmlChar,
        prefix: *const xmlChar,
    ) -> xmlElementPtr;
}
extern "C" {
    pub fn xmlGetDtdElementDesc(dtd: xmlDtdPtr, name: *const xmlChar) -> xmlElementPtr;
}
extern "C" {
    pub fn xmlValidGetPotentialChildren(
        ctree: *mut xmlElementContent,
        names: *mut *const xmlChar,
        len: *mut ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidGetValidElements(
        prev: *mut xmlNode,
        next: *mut xmlNode,
        names: *mut *const xmlChar,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateNameValue(value: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateNamesValue(value: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateNmtokenValue(value: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidateNmtokensValue(value: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidBuildContentModel(
        ctxt: xmlValidCtxtPtr,
        elem: xmlElementPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidatePushElement(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
        qname: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidatePushCData(
        ctxt: xmlValidCtxtPtr,
        data: *const xmlChar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlValidatePopElement(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
        qname: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
pub const xmlEntityType_XML_INTERNAL_GENERAL_ENTITY: xmlEntityType = 1;
pub const xmlEntityType_XML_EXTERNAL_GENERAL_PARSED_ENTITY: xmlEntityType = 2;
pub const xmlEntityType_XML_EXTERNAL_GENERAL_UNPARSED_ENTITY: xmlEntityType = 3;
pub const xmlEntityType_XML_INTERNAL_PARAMETER_ENTITY: xmlEntityType = 4;
pub const xmlEntityType_XML_EXTERNAL_PARAMETER_ENTITY: xmlEntityType = 5;
pub const xmlEntityType_XML_INTERNAL_PREDEFINED_ENTITY: xmlEntityType = 6;
pub type xmlEntityType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlEntity {
    pub _private: *mut ::std::os::raw::c_void,
    pub type_: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub orig: *mut xmlChar,
    pub content: *mut xmlChar,
    pub length: ::std::os::raw::c_int,
    pub etype: xmlEntityType,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub nexte: *mut _xmlEntity,
    pub URI: *const xmlChar,
    pub owner: ::std::os::raw::c_int,
    pub checked: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlEntity() {
    assert_eq!(
        ::std::mem::size_of::<_xmlEntity>(),
        136usize,
        concat!("Size of: ", stringify!(_xmlEntity))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlEntity>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlEntity))
    );
    fn test_field__private() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._private) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(_private)
            )
        );
    }
    test_field__private();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_children() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(children)
            )
        );
    }
    test_field_children();
    fn test_field_last() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(last)
            )
        );
    }
    test_field_last();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_doc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(doc)
            )
        );
    }
    test_field_doc();
    fn test_field_orig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).orig) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(orig)
            )
        );
    }
    test_field_orig();
    fn test_field_content() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(content)
            )
        );
    }
    test_field_content();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_etype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).etype) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(etype)
            )
        );
    }
    test_field_etype();
    fn test_field_ExternalID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ExternalID) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(ExternalID)
            )
        );
    }
    test_field_ExternalID();
    fn test_field_SystemID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SystemID) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(SystemID)
            )
        );
    }
    test_field_SystemID();
    fn test_field_nexte() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nexte) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(nexte)
            )
        );
    }
    test_field_nexte();
    fn test_field_URI() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).URI) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(URI)
            )
        );
    }
    test_field_URI();
    fn test_field_owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(owner)
            )
        );
    }
    test_field_owner();
    fn test_field_checked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlEntity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).checked) as usize - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlEntity),
                "::",
                stringify!(checked)
            )
        );
    }
    test_field_checked();
}
pub type xmlEntitiesTable = _xmlHashTable;
pub type xmlEntitiesTablePtr = *mut xmlEntitiesTable;
extern "C" {
    pub fn xmlInitializePredefinedEntities();
}
extern "C" {
    pub fn xmlNewEntity(
        doc: xmlDocPtr,
        name: *const xmlChar,
        type_: ::std::os::raw::c_int,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlEntityPtr;
}
extern "C" {
    pub fn xmlAddDocEntity(
        doc: xmlDocPtr,
        name: *const xmlChar,
        type_: ::std::os::raw::c_int,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlEntityPtr;
}
extern "C" {
    pub fn xmlAddDtdEntity(
        doc: xmlDocPtr,
        name: *const xmlChar,
        type_: ::std::os::raw::c_int,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlEntityPtr;
}
extern "C" {
    pub fn xmlGetPredefinedEntity(name: *const xmlChar) -> xmlEntityPtr;
}
extern "C" {
    pub fn xmlGetDocEntity(doc: *const xmlDoc, name: *const xmlChar) -> xmlEntityPtr;
}
extern "C" {
    pub fn xmlGetDtdEntity(doc: xmlDocPtr, name: *const xmlChar) -> xmlEntityPtr;
}
extern "C" {
    pub fn xmlGetParameterEntity(doc: xmlDocPtr, name: *const xmlChar) -> xmlEntityPtr;
}
extern "C" {
    pub fn xmlEncodeEntities(doc: xmlDocPtr, input: *const xmlChar) -> *const xmlChar;
}
extern "C" {
    pub fn xmlEncodeEntitiesReentrant(doc: xmlDocPtr, input: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlEncodeSpecialChars(doc: *const xmlDoc, input: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlCreateEntitiesTable() -> xmlEntitiesTablePtr;
}
extern "C" {
    pub fn xmlCopyEntitiesTable(table: xmlEntitiesTablePtr) -> xmlEntitiesTablePtr;
}
extern "C" {
    pub fn xmlFreeEntitiesTable(table: xmlEntitiesTablePtr);
}
extern "C" {
    pub fn xmlDumpEntitiesTable(buf: xmlBufferPtr, table: xmlEntitiesTablePtr);
}
extern "C" {
    pub fn xmlDumpEntityDecl(buf: xmlBufferPtr, ent: xmlEntityPtr);
}
extern "C" {
    pub fn xmlCleanupPredefinedEntities();
}
#[doc = " xmlParserInputDeallocate:"]
#[doc = " @str:  the string to deallocate"]
#[doc = ""]
#[doc = " Callback for freeing some parser input allocations."]
pub type xmlParserInputDeallocate = ::std::option::Option<unsafe extern "C" fn(str_: *mut xmlChar)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserInput {
    pub buf: xmlParserInputBufferPtr,
    pub filename: *const ::std::os::raw::c_char,
    pub directory: *const ::std::os::raw::c_char,
    pub base: *const xmlChar,
    pub cur: *const xmlChar,
    pub end: *const xmlChar,
    pub length: ::std::os::raw::c_int,
    pub line: ::std::os::raw::c_int,
    pub col: ::std::os::raw::c_int,
    pub consumed: ::std::os::raw::c_ulong,
    pub free: xmlParserInputDeallocate,
    pub encoding: *const xmlChar,
    pub version: *const xmlChar,
    pub standalone: ::std::os::raw::c_int,
    pub id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlParserInput() {
    assert_eq!(
        ::std::mem::size_of::<_xmlParserInput>(),
        96usize,
        concat!("Size of: ", stringify!(_xmlParserInput))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlParserInput>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlParserInput))
    );
    fn test_field_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(buf)
            )
        );
    }
    test_field_buf();
    fn test_field_filename() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(filename)
            )
        );
    }
    test_field_filename();
    fn test_field_directory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).directory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(directory)
            )
        );
    }
    test_field_directory();
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cur() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cur) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(cur)
            )
        );
    }
    test_field_cur();
    fn test_field_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(end)
            )
        );
    }
    test_field_end();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(line)
            )
        );
    }
    test_field_line();
    fn test_field_col() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).col) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(col)
            )
        );
    }
    test_field_col();
    fn test_field_consumed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).consumed) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(consumed)
            )
        );
    }
    test_field_consumed();
    fn test_field_free() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(free)
            )
        );
    }
    test_field_free();
    fn test_field_encoding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(encoding)
            )
        );
    }
    test_field_encoding();
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_standalone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).standalone) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(standalone)
            )
        );
    }
    test_field_standalone();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInput>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInput),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
}
#[doc = " xmlParserNodeInfo:"]
#[doc = ""]
#[doc = " The parser can be asked to collect Node information, i.e. at what"]
#[doc = " place in the file they were detected."]
#[doc = " NOTE: This is off by default and not very well tested."]
pub type xmlParserNodeInfo = _xmlParserNodeInfo;
pub type xmlParserNodeInfoPtr = *mut xmlParserNodeInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserNodeInfo {
    pub node: *const _xmlNode,
    pub begin_pos: ::std::os::raw::c_ulong,
    pub begin_line: ::std::os::raw::c_ulong,
    pub end_pos: ::std::os::raw::c_ulong,
    pub end_line: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__xmlParserNodeInfo() {
    assert_eq!(
        ::std::mem::size_of::<_xmlParserNodeInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_xmlParserNodeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlParserNodeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlParserNodeInfo))
    );
    fn test_field_node() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserNodeInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserNodeInfo),
                "::",
                stringify!(node)
            )
        );
    }
    test_field_node();
    fn test_field_begin_pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserNodeInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).begin_pos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserNodeInfo),
                "::",
                stringify!(begin_pos)
            )
        );
    }
    test_field_begin_pos();
    fn test_field_begin_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserNodeInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).begin_line) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserNodeInfo),
                "::",
                stringify!(begin_line)
            )
        );
    }
    test_field_begin_line();
    fn test_field_end_pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserNodeInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end_pos) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserNodeInfo),
                "::",
                stringify!(end_pos)
            )
        );
    }
    test_field_end_pos();
    fn test_field_end_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserNodeInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end_line) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserNodeInfo),
                "::",
                stringify!(end_line)
            )
        );
    }
    test_field_end_line();
}
pub type xmlParserNodeInfoSeq = _xmlParserNodeInfoSeq;
pub type xmlParserNodeInfoSeqPtr = *mut xmlParserNodeInfoSeq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserNodeInfoSeq {
    pub maximum: ::std::os::raw::c_ulong,
    pub length: ::std::os::raw::c_ulong,
    pub buffer: *mut xmlParserNodeInfo,
}
#[test]
fn bindgen_test_layout__xmlParserNodeInfoSeq() {
    assert_eq!(
        ::std::mem::size_of::<_xmlParserNodeInfoSeq>(),
        16usize,
        concat!("Size of: ", stringify!(_xmlParserNodeInfoSeq))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlParserNodeInfoSeq>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlParserNodeInfoSeq))
    );
    fn test_field_maximum() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserNodeInfoSeq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserNodeInfoSeq),
                "::",
                stringify!(maximum)
            )
        );
    }
    test_field_maximum();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserNodeInfoSeq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserNodeInfoSeq),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserNodeInfoSeq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserNodeInfoSeq),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
}
pub const xmlParserInputState_XML_PARSER_EOF: xmlParserInputState = -1;
pub const xmlParserInputState_XML_PARSER_START: xmlParserInputState = 0;
pub const xmlParserInputState_XML_PARSER_MISC: xmlParserInputState = 1;
pub const xmlParserInputState_XML_PARSER_PI: xmlParserInputState = 2;
pub const xmlParserInputState_XML_PARSER_DTD: xmlParserInputState = 3;
pub const xmlParserInputState_XML_PARSER_PROLOG: xmlParserInputState = 4;
pub const xmlParserInputState_XML_PARSER_COMMENT: xmlParserInputState = 5;
pub const xmlParserInputState_XML_PARSER_START_TAG: xmlParserInputState = 6;
pub const xmlParserInputState_XML_PARSER_CONTENT: xmlParserInputState = 7;
pub const xmlParserInputState_XML_PARSER_CDATA_SECTION: xmlParserInputState = 8;
pub const xmlParserInputState_XML_PARSER_END_TAG: xmlParserInputState = 9;
pub const xmlParserInputState_XML_PARSER_ENTITY_DECL: xmlParserInputState = 10;
pub const xmlParserInputState_XML_PARSER_ENTITY_VALUE: xmlParserInputState = 11;
pub const xmlParserInputState_XML_PARSER_ATTRIBUTE_VALUE: xmlParserInputState = 12;
pub const xmlParserInputState_XML_PARSER_SYSTEM_LITERAL: xmlParserInputState = 13;
pub const xmlParserInputState_XML_PARSER_EPILOG: xmlParserInputState = 14;
pub const xmlParserInputState_XML_PARSER_IGNORE: xmlParserInputState = 15;
pub const xmlParserInputState_XML_PARSER_PUBLIC_LITERAL: xmlParserInputState = 16;
#[doc = " xmlParserInputState:"]
#[doc = ""]
#[doc = " The parser is now working also as a state based parser."]
#[doc = " The recursive one use the state info for entities processing."]
pub type xmlParserInputState = ::std::os::raw::c_int;
pub const xmlParserMode_XML_PARSE_UNKNOWN: xmlParserMode = 0;
pub const xmlParserMode_XML_PARSE_DOM: xmlParserMode = 1;
pub const xmlParserMode_XML_PARSE_SAX: xmlParserMode = 2;
pub const xmlParserMode_XML_PARSE_PUSH_DOM: xmlParserMode = 3;
pub const xmlParserMode_XML_PARSE_PUSH_SAX: xmlParserMode = 4;
pub const xmlParserMode_XML_PARSE_READER: xmlParserMode = 5;
#[doc = " xmlParserMode:"]
#[doc = ""]
#[doc = " A parser can operate in various modes"]
pub type xmlParserMode = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlStartTag {
    _unused: [u8; 0],
}
pub type xmlStartTag = _xmlStartTag;
#[doc = " xmlParserCtxt:"]
#[doc = ""]
#[doc = " The parser context."]
#[doc = " NOTE This doesn't completely define the parser state, the (current ?)"]
#[doc = "      design of the parser uses recursive function calls since this allow"]
#[doc = "      and easy mapping from the production rules of the specification"]
#[doc = "      to the actual code. The drawback is that the actual function call"]
#[doc = "      also reflect the parser state. However most of the parsing routines"]
#[doc = "      takes as the only argument the parser context pointer, so migrating"]
#[doc = "      to a state based parser for progressive parsing shouldn't be too hard."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserCtxt {
    pub sax: *mut _xmlSAXHandler,
    pub userData: *mut ::std::os::raw::c_void,
    pub myDoc: xmlDocPtr,
    pub wellFormed: ::std::os::raw::c_int,
    pub replaceEntities: ::std::os::raw::c_int,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub standalone: ::std::os::raw::c_int,
    pub html: ::std::os::raw::c_int,
    pub input: xmlParserInputPtr,
    pub inputNr: ::std::os::raw::c_int,
    pub inputMax: ::std::os::raw::c_int,
    pub inputTab: *mut xmlParserInputPtr,
    pub node: xmlNodePtr,
    pub nodeNr: ::std::os::raw::c_int,
    pub nodeMax: ::std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub record_info: ::std::os::raw::c_int,
    pub node_seq: xmlParserNodeInfoSeq,
    pub errNo: ::std::os::raw::c_int,
    pub hasExternalSubset: ::std::os::raw::c_int,
    pub hasPErefs: ::std::os::raw::c_int,
    pub external: ::std::os::raw::c_int,
    pub valid: ::std::os::raw::c_int,
    pub validate: ::std::os::raw::c_int,
    pub vctxt: xmlValidCtxt,
    pub instate: xmlParserInputState,
    pub token: ::std::os::raw::c_int,
    pub directory: *mut ::std::os::raw::c_char,
    pub name: *const xmlChar,
    pub nameNr: ::std::os::raw::c_int,
    pub nameMax: ::std::os::raw::c_int,
    pub nameTab: *mut *const xmlChar,
    pub nbChars: ::std::os::raw::c_long,
    pub checkIndex: ::std::os::raw::c_long,
    pub keepBlanks: ::std::os::raw::c_int,
    pub disableSAX: ::std::os::raw::c_int,
    pub inSubset: ::std::os::raw::c_int,
    pub intSubName: *const xmlChar,
    pub extSubURI: *mut xmlChar,
    pub extSubSystem: *mut xmlChar,
    pub space: *mut ::std::os::raw::c_int,
    pub spaceNr: ::std::os::raw::c_int,
    pub spaceMax: ::std::os::raw::c_int,
    pub spaceTab: *mut ::std::os::raw::c_int,
    pub depth: ::std::os::raw::c_int,
    pub entity: xmlParserInputPtr,
    pub charset: ::std::os::raw::c_int,
    pub nodelen: ::std::os::raw::c_int,
    pub nodemem: ::std::os::raw::c_int,
    pub pedantic: ::std::os::raw::c_int,
    pub _private: *mut ::std::os::raw::c_void,
    pub loadsubset: ::std::os::raw::c_int,
    pub linenumbers: ::std::os::raw::c_int,
    pub catalogs: *mut ::std::os::raw::c_void,
    pub recovery: ::std::os::raw::c_int,
    pub progressive: ::std::os::raw::c_int,
    pub dict: xmlDictPtr,
    pub atts: *mut *const xmlChar,
    pub maxatts: ::std::os::raw::c_int,
    pub docdict: ::std::os::raw::c_int,
    pub str_xml: *const xmlChar,
    pub str_xmlns: *const xmlChar,
    pub str_xml_ns: *const xmlChar,
    pub sax2: ::std::os::raw::c_int,
    pub nsNr: ::std::os::raw::c_int,
    pub nsMax: ::std::os::raw::c_int,
    pub nsTab: *mut *const xmlChar,
    pub attallocs: *mut ::std::os::raw::c_int,
    pub pushTab: *mut xmlStartTag,
    pub attsDefault: xmlHashTablePtr,
    pub attsSpecial: xmlHashTablePtr,
    pub nsWellFormed: ::std::os::raw::c_int,
    pub options: ::std::os::raw::c_int,
    pub dictNames: ::std::os::raw::c_int,
    pub freeElemsNr: ::std::os::raw::c_int,
    pub freeElems: xmlNodePtr,
    pub freeAttrsNr: ::std::os::raw::c_int,
    pub freeAttrs: xmlAttrPtr,
    pub lastError: xmlError,
    pub parseMode: xmlParserMode,
    pub nbentities: ::std::os::raw::c_ulong,
    pub sizeentities: ::std::os::raw::c_ulong,
    pub nodeInfo: *mut xmlParserNodeInfo,
    pub nodeInfoNr: ::std::os::raw::c_int,
    pub nodeInfoMax: ::std::os::raw::c_int,
    pub nodeInfoTab: *mut xmlParserNodeInfo,
    pub input_id: ::std::os::raw::c_int,
    pub sizeentcopy: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__xmlParserCtxt() {
    assert_eq!(
        ::std::mem::size_of::<_xmlParserCtxt>(),
        720usize,
        concat!("Size of: ", stringify!(_xmlParserCtxt))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlParserCtxt>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlParserCtxt))
    );
    fn test_field_sax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sax) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(sax)
            )
        );
    }
    test_field_sax();
    fn test_field_userData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userData) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(userData)
            )
        );
    }
    test_field_userData();
    fn test_field_myDoc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).myDoc) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(myDoc)
            )
        );
    }
    test_field_myDoc();
    fn test_field_wellFormed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wellFormed) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(wellFormed)
            )
        );
    }
    test_field_wellFormed();
    fn test_field_replaceEntities() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).replaceEntities) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(replaceEntities)
            )
        );
    }
    test_field_replaceEntities();
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_encoding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(encoding)
            )
        );
    }
    test_field_encoding();
    fn test_field_standalone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).standalone) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(standalone)
            )
        );
    }
    test_field_standalone();
    fn test_field_html() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).html) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(html)
            )
        );
    }
    test_field_html();
    fn test_field_input() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(input)
            )
        );
    }
    test_field_input();
    fn test_field_inputNr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inputNr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(inputNr)
            )
        );
    }
    test_field_inputNr();
    fn test_field_inputMax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inputMax) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(inputMax)
            )
        );
    }
    test_field_inputMax();
    fn test_field_inputTab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inputTab) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(inputTab)
            )
        );
    }
    test_field_inputTab();
    fn test_field_node() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(node)
            )
        );
    }
    test_field_node();
    fn test_field_nodeNr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeNr) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nodeNr)
            )
        );
    }
    test_field_nodeNr();
    fn test_field_nodeMax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeMax) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nodeMax)
            )
        );
    }
    test_field_nodeMax();
    fn test_field_nodeTab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeTab) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nodeTab)
            )
        );
    }
    test_field_nodeTab();
    fn test_field_record_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).record_info) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(record_info)
            )
        );
    }
    test_field_record_info();
    fn test_field_node_seq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).node_seq) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(node_seq)
            )
        );
    }
    test_field_node_seq();
    fn test_field_errNo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).errNo) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(errNo)
            )
        );
    }
    test_field_errNo();
    fn test_field_hasExternalSubset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hasExternalSubset) as usize - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(hasExternalSubset)
            )
        );
    }
    test_field_hasExternalSubset();
    fn test_field_hasPErefs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hasPErefs) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(hasPErefs)
            )
        );
    }
    test_field_hasPErefs();
    fn test_field_external() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).external) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(external)
            )
        );
    }
    test_field_external();
    fn test_field_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(valid)
            )
        );
    }
    test_field_valid();
    fn test_field_validate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).validate) as usize - ptr as usize
            },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(validate)
            )
        );
    }
    test_field_validate();
    fn test_field_vctxt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vctxt) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(vctxt)
            )
        );
    }
    test_field_vctxt();
    fn test_field_instate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).instate) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(instate)
            )
        );
    }
    test_field_instate();
    fn test_field_token() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).token) as usize - ptr as usize
            },
            268usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(token)
            )
        );
    }
    test_field_token();
    fn test_field_directory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).directory) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(directory)
            )
        );
    }
    test_field_directory();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_nameNr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nameNr) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nameNr)
            )
        );
    }
    test_field_nameNr();
    fn test_field_nameMax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nameMax) as usize - ptr as usize
            },
            292usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nameMax)
            )
        );
    }
    test_field_nameMax();
    fn test_field_nameTab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nameTab) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nameTab)
            )
        );
    }
    test_field_nameTab();
    fn test_field_nbChars() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nbChars) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nbChars)
            )
        );
    }
    test_field_nbChars();
    fn test_field_checkIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).checkIndex) as usize - ptr as usize
            },
            308usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(checkIndex)
            )
        );
    }
    test_field_checkIndex();
    fn test_field_keepBlanks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keepBlanks) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(keepBlanks)
            )
        );
    }
    test_field_keepBlanks();
    fn test_field_disableSAX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).disableSAX) as usize - ptr as usize
            },
            316usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(disableSAX)
            )
        );
    }
    test_field_disableSAX();
    fn test_field_inSubset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inSubset) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(inSubset)
            )
        );
    }
    test_field_inSubset();
    fn test_field_intSubName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).intSubName) as usize - ptr as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(intSubName)
            )
        );
    }
    test_field_intSubName();
    fn test_field_extSubURI() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extSubURI) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(extSubURI)
            )
        );
    }
    test_field_extSubURI();
    fn test_field_extSubSystem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extSubSystem) as usize - ptr as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(extSubSystem)
            )
        );
    }
    test_field_extSubSystem();
    fn test_field_space() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).space) as usize - ptr as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(space)
            )
        );
    }
    test_field_space();
    fn test_field_spaceNr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).spaceNr) as usize - ptr as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(spaceNr)
            )
        );
    }
    test_field_spaceNr();
    fn test_field_spaceMax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).spaceMax) as usize - ptr as usize
            },
            364usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(spaceMax)
            )
        );
    }
    test_field_spaceMax();
    fn test_field_spaceTab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).spaceTab) as usize - ptr as usize
            },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(spaceTab)
            )
        );
    }
    test_field_spaceTab();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
    fn test_field_entity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entity) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(entity)
            )
        );
    }
    test_field_entity();
    fn test_field_charset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).charset) as usize - ptr as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(charset)
            )
        );
    }
    test_field_charset();
    fn test_field_nodelen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodelen) as usize - ptr as usize
            },
            396usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nodelen)
            )
        );
    }
    test_field_nodelen();
    fn test_field_nodemem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodemem) as usize - ptr as usize
            },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nodemem)
            )
        );
    }
    test_field_nodemem();
    fn test_field_pedantic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pedantic) as usize - ptr as usize
            },
            404usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(pedantic)
            )
        );
    }
    test_field_pedantic();
    fn test_field__private() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._private) as usize - ptr as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(_private)
            )
        );
    }
    test_field__private();
    fn test_field_loadsubset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loadsubset) as usize - ptr as usize
            },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(loadsubset)
            )
        );
    }
    test_field_loadsubset();
    fn test_field_linenumbers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linenumbers) as usize - ptr as usize
            },
            420usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(linenumbers)
            )
        );
    }
    test_field_linenumbers();
    fn test_field_catalogs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).catalogs) as usize - ptr as usize
            },
            424usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(catalogs)
            )
        );
    }
    test_field_catalogs();
    fn test_field_recovery() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).recovery) as usize - ptr as usize
            },
            432usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(recovery)
            )
        );
    }
    test_field_recovery();
    fn test_field_progressive() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).progressive) as usize - ptr as usize
            },
            436usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(progressive)
            )
        );
    }
    test_field_progressive();
    fn test_field_dict() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize
            },
            440usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(dict)
            )
        );
    }
    test_field_dict();
    fn test_field_atts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atts) as usize - ptr as usize
            },
            448usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(atts)
            )
        );
    }
    test_field_atts();
    fn test_field_maxatts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxatts) as usize - ptr as usize
            },
            456usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(maxatts)
            )
        );
    }
    test_field_maxatts();
    fn test_field_docdict() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).docdict) as usize - ptr as usize
            },
            460usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(docdict)
            )
        );
    }
    test_field_docdict();
    fn test_field_str_xml() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).str_xml) as usize - ptr as usize
            },
            464usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(str_xml)
            )
        );
    }
    test_field_str_xml();
    fn test_field_str_xmlns() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).str_xmlns) as usize - ptr as usize
            },
            472usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(str_xmlns)
            )
        );
    }
    test_field_str_xmlns();
    fn test_field_str_xml_ns() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).str_xml_ns) as usize - ptr as usize
            },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(str_xml_ns)
            )
        );
    }
    test_field_str_xml_ns();
    fn test_field_sax2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sax2) as usize - ptr as usize
            },
            488usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(sax2)
            )
        );
    }
    test_field_sax2();
    fn test_field_nsNr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsNr) as usize - ptr as usize
            },
            492usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nsNr)
            )
        );
    }
    test_field_nsNr();
    fn test_field_nsMax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsMax) as usize - ptr as usize
            },
            496usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nsMax)
            )
        );
    }
    test_field_nsMax();
    fn test_field_nsTab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsTab) as usize - ptr as usize
            },
            504usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nsTab)
            )
        );
    }
    test_field_nsTab();
    fn test_field_attallocs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attallocs) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(attallocs)
            )
        );
    }
    test_field_attallocs();
    fn test_field_pushTab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pushTab) as usize - ptr as usize
            },
            520usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(pushTab)
            )
        );
    }
    test_field_pushTab();
    fn test_field_attsDefault() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attsDefault) as usize - ptr as usize
            },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(attsDefault)
            )
        );
    }
    test_field_attsDefault();
    fn test_field_attsSpecial() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attsSpecial) as usize - ptr as usize
            },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(attsSpecial)
            )
        );
    }
    test_field_attsSpecial();
    fn test_field_nsWellFormed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsWellFormed) as usize - ptr as usize
            },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nsWellFormed)
            )
        );
    }
    test_field_nsWellFormed();
    fn test_field_options() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize
            },
            548usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(options)
            )
        );
    }
    test_field_options();
    fn test_field_dictNames() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dictNames) as usize - ptr as usize
            },
            552usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(dictNames)
            )
        );
    }
    test_field_dictNames();
    fn test_field_freeElemsNr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).freeElemsNr) as usize - ptr as usize
            },
            556usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(freeElemsNr)
            )
        );
    }
    test_field_freeElemsNr();
    fn test_field_freeElems() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).freeElems) as usize - ptr as usize
            },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(freeElems)
            )
        );
    }
    test_field_freeElems();
    fn test_field_freeAttrsNr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).freeAttrsNr) as usize - ptr as usize
            },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(freeAttrsNr)
            )
        );
    }
    test_field_freeAttrsNr();
    fn test_field_freeAttrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).freeAttrs) as usize - ptr as usize
            },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(freeAttrs)
            )
        );
    }
    test_field_freeAttrs();
    fn test_field_lastError() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastError) as usize - ptr as usize
            },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(lastError)
            )
        );
    }
    test_field_lastError();
    fn test_field_parseMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parseMode) as usize - ptr as usize
            },
            672usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(parseMode)
            )
        );
    }
    test_field_parseMode();
    fn test_field_nbentities() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nbentities) as usize - ptr as usize
            },
            676usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nbentities)
            )
        );
    }
    test_field_nbentities();
    fn test_field_sizeentities() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sizeentities) as usize - ptr as usize
            },
            680usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(sizeentities)
            )
        );
    }
    test_field_sizeentities();
    fn test_field_nodeInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeInfo) as usize - ptr as usize
            },
            688usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nodeInfo)
            )
        );
    }
    test_field_nodeInfo();
    fn test_field_nodeInfoNr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeInfoNr) as usize - ptr as usize
            },
            696usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nodeInfoNr)
            )
        );
    }
    test_field_nodeInfoNr();
    fn test_field_nodeInfoMax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeInfoMax) as usize - ptr as usize
            },
            700usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nodeInfoMax)
            )
        );
    }
    test_field_nodeInfoMax();
    fn test_field_nodeInfoTab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeInfoTab) as usize - ptr as usize
            },
            704usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(nodeInfoTab)
            )
        );
    }
    test_field_nodeInfoTab();
    fn test_field_input_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).input_id) as usize - ptr as usize
            },
            712usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(input_id)
            )
        );
    }
    test_field_input_id();
    fn test_field_sizeentcopy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserCtxt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sizeentcopy) as usize - ptr as usize
            },
            716usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserCtxt),
                "::",
                stringify!(sizeentcopy)
            )
        );
    }
    test_field_sizeentcopy();
}
#[doc = " xmlSAXLocator:"]
#[doc = ""]
#[doc = " A SAX Locator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSAXLocator {
    pub getPublicId: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const xmlChar,
    >,
    pub getSystemId: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const xmlChar,
    >,
    pub getLineNumber: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub getColumnNumber: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__xmlSAXLocator() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSAXLocator>(),
        32usize,
        concat!("Size of: ", stringify!(_xmlSAXLocator))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSAXLocator>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSAXLocator))
    );
    fn test_field_getPublicId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXLocator>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getPublicId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXLocator),
                "::",
                stringify!(getPublicId)
            )
        );
    }
    test_field_getPublicId();
    fn test_field_getSystemId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXLocator>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getSystemId) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXLocator),
                "::",
                stringify!(getSystemId)
            )
        );
    }
    test_field_getSystemId();
    fn test_field_getLineNumber() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXLocator>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getLineNumber) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXLocator),
                "::",
                stringify!(getLineNumber)
            )
        );
    }
    test_field_getLineNumber();
    fn test_field_getColumnNumber() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXLocator>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getColumnNumber) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXLocator),
                "::",
                stringify!(getColumnNumber)
            )
        );
    }
    test_field_getColumnNumber();
}
#[doc = " resolveEntitySAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @publicId: The public ID of the entity"]
#[doc = " @systemId: The system ID of the entity"]
#[doc = ""]
#[doc = " Callback:"]
#[doc = " The entity loader, to control the loading of external entities,"]
#[doc = " the application can either:"]
#[doc = "    - override this resolveEntity() callback in the SAX block"]
#[doc = "    - or better use the xmlSetExternalEntityLoader() function to"]
#[doc = "      set up it's own entity resolution routine"]
#[doc = ""]
#[doc = " Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour."]
pub type resolveEntitySAXFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        publicId: *const xmlChar,
        systemId: *const xmlChar,
    ) -> xmlParserInputPtr,
>;
#[doc = " internalSubsetSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @name:  the root element name"]
#[doc = " @ExternalID:  the external ID"]
#[doc = " @SystemID:  the SYSTEM ID (e.g. filename or URL)"]
#[doc = ""]
#[doc = " Callback on internal subset declaration."]
pub type internalSubsetSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
    ),
>;
#[doc = " externalSubsetSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @name:  the root element name"]
#[doc = " @ExternalID:  the external ID"]
#[doc = " @SystemID:  the SYSTEM ID (e.g. filename or URL)"]
#[doc = ""]
#[doc = " Callback on external subset declaration."]
pub type externalSubsetSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
    ),
>;
#[doc = " getEntitySAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @name: The entity name"]
#[doc = ""]
#[doc = " Get an entity by name."]
#[doc = ""]
#[doc = " Returns the xmlEntityPtr if found."]
pub type getEntitySAXFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar) -> xmlEntityPtr,
>;
#[doc = " getParameterEntitySAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @name: The entity name"]
#[doc = ""]
#[doc = " Get a parameter entity by name."]
#[doc = ""]
#[doc = " Returns the xmlEntityPtr if found."]
pub type getParameterEntitySAXFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar) -> xmlEntityPtr,
>;
#[doc = " entityDeclSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @name:  the entity name"]
#[doc = " @type:  the entity type"]
#[doc = " @publicId: The public ID of the entity"]
#[doc = " @systemId: The system ID of the entity"]
#[doc = " @content: the entity value (without processing)."]
#[doc = ""]
#[doc = " An entity definition has been parsed."]
pub type entityDeclSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        type_: ::std::os::raw::c_int,
        publicId: *const xmlChar,
        systemId: *const xmlChar,
        content: *mut xmlChar,
    ),
>;
#[doc = " notationDeclSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @name: The name of the notation"]
#[doc = " @publicId: The public ID of the entity"]
#[doc = " @systemId: The system ID of the entity"]
#[doc = ""]
#[doc = " What to do when a notation declaration has been parsed."]
pub type notationDeclSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        publicId: *const xmlChar,
        systemId: *const xmlChar,
    ),
>;
#[doc = " attributeDeclSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @elem:  the name of the element"]
#[doc = " @fullname:  the attribute name"]
#[doc = " @type:  the attribute type"]
#[doc = " @def:  the type of default value"]
#[doc = " @defaultValue: the attribute default value"]
#[doc = " @tree:  the tree of enumerated value set"]
#[doc = ""]
#[doc = " An attribute definition has been parsed."]
pub type attributeDeclSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        elem: *const xmlChar,
        fullname: *const xmlChar,
        type_: ::std::os::raw::c_int,
        def: ::std::os::raw::c_int,
        defaultValue: *const xmlChar,
        tree: xmlEnumerationPtr,
    ),
>;
#[doc = " elementDeclSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @name:  the element name"]
#[doc = " @type:  the element type"]
#[doc = " @content: the element value tree"]
#[doc = ""]
#[doc = " An element definition has been parsed."]
pub type elementDeclSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        type_: ::std::os::raw::c_int,
        content: xmlElementContentPtr,
    ),
>;
#[doc = " unparsedEntityDeclSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @name: The name of the entity"]
#[doc = " @publicId: The public ID of the entity"]
#[doc = " @systemId: The system ID of the entity"]
#[doc = " @notationName: the name of the notation"]
#[doc = ""]
#[doc = " What to do when an unparsed entity declaration is parsed."]
pub type unparsedEntityDeclSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        publicId: *const xmlChar,
        systemId: *const xmlChar,
        notationName: *const xmlChar,
    ),
>;
#[doc = " setDocumentLocatorSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @loc: A SAX Locator"]
#[doc = ""]
#[doc = " Receive the document locator at startup, actually xmlDefaultSAXLocator."]
#[doc = " Everything is available on the context, so this is useless in our case."]
pub type setDocumentLocatorSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, loc: xmlSAXLocatorPtr),
>;
#[doc = " startDocumentSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = ""]
#[doc = " Called when the document start being processed."]
pub type startDocumentSAXFunc =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
#[doc = " endDocumentSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = ""]
#[doc = " Called when the document end has been detected."]
pub type endDocumentSAXFunc =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
#[doc = " startElementSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @name:  The element name, including namespace prefix"]
#[doc = " @atts:  An array of name/value attributes pairs, NULL terminated"]
#[doc = ""]
#[doc = " Called when an opening tag has been processed."]
pub type startElementSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        atts: *mut *const xmlChar,
    ),
>;
#[doc = " endElementSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @name:  The element name"]
#[doc = ""]
#[doc = " Called when the end of an element has been detected."]
pub type endElementSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar),
>;
#[doc = " attributeSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @name:  The attribute name, including namespace prefix"]
#[doc = " @value:  The attribute value"]
#[doc = ""]
#[doc = " Handle an attribute that has been read by the parser."]
#[doc = " The default handling is to convert the attribute into an"]
#[doc = " DOM subtree and past it in a new xmlAttr element added to"]
#[doc = " the element."]
pub type attributeSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        value: *const xmlChar,
    ),
>;
#[doc = " referenceSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @name:  The entity name"]
#[doc = ""]
#[doc = " Called when an entity reference is detected."]
pub type referenceSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar),
>;
#[doc = " charactersSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @ch:  a xmlChar string"]
#[doc = " @len: the number of xmlChar"]
#[doc = ""]
#[doc = " Receiving some chars from the parser."]
pub type charactersSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        ch: *const xmlChar,
        len: ::std::os::raw::c_int,
    ),
>;
#[doc = " ignorableWhitespaceSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @ch:  a xmlChar string"]
#[doc = " @len: the number of xmlChar"]
#[doc = ""]
#[doc = " Receiving some ignorable whitespaces from the parser."]
#[doc = " UNUSED: by default the DOM building will use characters."]
pub type ignorableWhitespaceSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        ch: *const xmlChar,
        len: ::std::os::raw::c_int,
    ),
>;
#[doc = " processingInstructionSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @target:  the target name"]
#[doc = " @data: the PI data's"]
#[doc = ""]
#[doc = " A processing instruction has been parsed."]
pub type processingInstructionSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        target: *const xmlChar,
        data: *const xmlChar,
    ),
>;
#[doc = " commentSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @value:  the comment content"]
#[doc = ""]
#[doc = " A comment has been parsed."]
pub type commentSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, value: *const xmlChar),
>;
#[doc = " cdataBlockSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @value:  The pcdata content"]
#[doc = " @len:  the block length"]
#[doc = ""]
#[doc = " Called when a pcdata block has been parsed."]
pub type cdataBlockSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        value: *const xmlChar,
        len: ::std::os::raw::c_int,
    ),
>;
#[doc = " warningSAXFunc:"]
#[doc = " @ctx:  an XML parser context"]
#[doc = " @msg:  the message to display/transmit"]
#[doc = " @...:  extra parameters for the message display"]
#[doc = ""]
#[doc = " Display and format a warning messages, callback."]
pub type warningSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[doc = " errorSAXFunc:"]
#[doc = " @ctx:  an XML parser context"]
#[doc = " @msg:  the message to display/transmit"]
#[doc = " @...:  extra parameters for the message display"]
#[doc = ""]
#[doc = " Display and format an error messages, callback."]
pub type errorSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[doc = " fatalErrorSAXFunc:"]
#[doc = " @ctx:  an XML parser context"]
#[doc = " @msg:  the message to display/transmit"]
#[doc = " @...:  extra parameters for the message display"]
#[doc = ""]
#[doc = " Display and format fatal error messages, callback."]
#[doc = " Note: so far fatalError() SAX callbacks are not used, error()"]
#[doc = "       get all the callbacks for errors."]
pub type fatalErrorSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[doc = " isStandaloneSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = ""]
#[doc = " Is this document tagged standalone?"]
#[doc = ""]
#[doc = " Returns 1 if true"]
pub type isStandaloneSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " hasInternalSubsetSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = ""]
#[doc = " Does this document has an internal subset."]
#[doc = ""]
#[doc = " Returns 1 if true"]
pub type hasInternalSubsetSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " hasExternalSubsetSAXFunc:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = ""]
#[doc = " Does this document has an external subset?"]
#[doc = ""]
#[doc = " Returns 1 if true"]
pub type hasExternalSubsetSAXFunc = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " startElementNsSAX2Func:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @localname:  the local name of the element"]
#[doc = " @prefix:  the element namespace prefix if available"]
#[doc = " @URI:  the element namespace name if available"]
#[doc = " @nb_namespaces:  number of namespace definitions on that node"]
#[doc = " @namespaces:  pointer to the array of prefix/URI pairs namespace definitions"]
#[doc = " @nb_attributes:  the number of attributes on that node"]
#[doc = " @nb_defaulted:  the number of defaulted attributes. The defaulted"]
#[doc = "                  ones are at the end of the array"]
#[doc = " @attributes:  pointer to the array of (localname/prefix/URI/value/end)"]
#[doc = "               attribute values."]
#[doc = ""]
#[doc = " SAX2 callback when an element start has been detected by the parser."]
#[doc = " It provides the namespace information for the element, as well as"]
#[doc = " the new namespace declarations on the element."]
pub type startElementNsSAX2Func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        localname: *const xmlChar,
        prefix: *const xmlChar,
        URI: *const xmlChar,
        nb_namespaces: ::std::os::raw::c_int,
        namespaces: *mut *const xmlChar,
        nb_attributes: ::std::os::raw::c_int,
        nb_defaulted: ::std::os::raw::c_int,
        attributes: *mut *const xmlChar,
    ),
>;
#[doc = " endElementNsSAX2Func:"]
#[doc = " @ctx:  the user data (XML parser context)"]
#[doc = " @localname:  the local name of the element"]
#[doc = " @prefix:  the element namespace prefix if available"]
#[doc = " @URI:  the element namespace name if available"]
#[doc = ""]
#[doc = " SAX2 callback when an element end has been detected by the parser."]
#[doc = " It provides the namespace information for the element."]
pub type endElementNsSAX2Func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        localname: *const xmlChar,
        prefix: *const xmlChar,
        URI: *const xmlChar,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSAXHandler {
    pub internalSubset: internalSubsetSAXFunc,
    pub isStandalone: isStandaloneSAXFunc,
    pub hasInternalSubset: hasInternalSubsetSAXFunc,
    pub hasExternalSubset: hasExternalSubsetSAXFunc,
    pub resolveEntity: resolveEntitySAXFunc,
    pub getEntity: getEntitySAXFunc,
    pub entityDecl: entityDeclSAXFunc,
    pub notationDecl: notationDeclSAXFunc,
    pub attributeDecl: attributeDeclSAXFunc,
    pub elementDecl: elementDeclSAXFunc,
    pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
    pub setDocumentLocator: setDocumentLocatorSAXFunc,
    pub startDocument: startDocumentSAXFunc,
    pub endDocument: endDocumentSAXFunc,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub reference: referenceSAXFunc,
    pub characters: charactersSAXFunc,
    pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
    pub processingInstruction: processingInstructionSAXFunc,
    pub comment: commentSAXFunc,
    pub warning: warningSAXFunc,
    pub error: errorSAXFunc,
    pub fatalError: fatalErrorSAXFunc,
    pub getParameterEntity: getParameterEntitySAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub externalSubset: externalSubsetSAXFunc,
    pub initialized: ::std::os::raw::c_uint,
    pub _private: *mut ::std::os::raw::c_void,
    pub startElementNs: startElementNsSAX2Func,
    pub endElementNs: endElementNsSAX2Func,
    pub serror: xmlStructuredErrorFunc,
}
#[test]
fn bindgen_test_layout__xmlSAXHandler() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSAXHandler>(),
        256usize,
        concat!("Size of: ", stringify!(_xmlSAXHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSAXHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSAXHandler))
    );
    fn test_field_internalSubset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).internalSubset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(internalSubset)
            )
        );
    }
    test_field_internalSubset();
    fn test_field_isStandalone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isStandalone) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(isStandalone)
            )
        );
    }
    test_field_isStandalone();
    fn test_field_hasInternalSubset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hasInternalSubset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(hasInternalSubset)
            )
        );
    }
    test_field_hasInternalSubset();
    fn test_field_hasExternalSubset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hasExternalSubset) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(hasExternalSubset)
            )
        );
    }
    test_field_hasExternalSubset();
    fn test_field_resolveEntity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resolveEntity) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(resolveEntity)
            )
        );
    }
    test_field_resolveEntity();
    fn test_field_getEntity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getEntity) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(getEntity)
            )
        );
    }
    test_field_getEntity();
    fn test_field_entityDecl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entityDecl) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(entityDecl)
            )
        );
    }
    test_field_entityDecl();
    fn test_field_notationDecl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).notationDecl) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(notationDecl)
            )
        );
    }
    test_field_notationDecl();
    fn test_field_attributeDecl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attributeDecl) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(attributeDecl)
            )
        );
    }
    test_field_attributeDecl();
    fn test_field_elementDecl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).elementDecl) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(elementDecl)
            )
        );
    }
    test_field_elementDecl();
    fn test_field_unparsedEntityDecl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unparsedEntityDecl) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(unparsedEntityDecl)
            )
        );
    }
    test_field_unparsedEntityDecl();
    fn test_field_setDocumentLocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).setDocumentLocator) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(setDocumentLocator)
            )
        );
    }
    test_field_setDocumentLocator();
    fn test_field_startDocument() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).startDocument) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(startDocument)
            )
        );
    }
    test_field_startDocument();
    fn test_field_endDocument() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).endDocument) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(endDocument)
            )
        );
    }
    test_field_endDocument();
    fn test_field_startElement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).startElement) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(startElement)
            )
        );
    }
    test_field_startElement();
    fn test_field_endElement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).endElement) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(endElement)
            )
        );
    }
    test_field_endElement();
    fn test_field_reference() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reference) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(reference)
            )
        );
    }
    test_field_reference();
    fn test_field_characters() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).characters) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(characters)
            )
        );
    }
    test_field_characters();
    fn test_field_ignorableWhitespace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ignorableWhitespace) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(ignorableWhitespace)
            )
        );
    }
    test_field_ignorableWhitespace();
    fn test_field_processingInstruction() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).processingInstruction) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(processingInstruction)
            )
        );
    }
    test_field_processingInstruction();
    fn test_field_comment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).comment) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(comment)
            )
        );
    }
    test_field_comment();
    fn test_field_warning() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).warning) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(warning)
            )
        );
    }
    test_field_warning();
    fn test_field_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(error)
            )
        );
    }
    test_field_error();
    fn test_field_fatalError() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fatalError) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(fatalError)
            )
        );
    }
    test_field_fatalError();
    fn test_field_getParameterEntity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getParameterEntity) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(getParameterEntity)
            )
        );
    }
    test_field_getParameterEntity();
    fn test_field_cdataBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cdataBlock) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(cdataBlock)
            )
        );
    }
    test_field_cdataBlock();
    fn test_field_externalSubset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).externalSubset) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(externalSubset)
            )
        );
    }
    test_field_externalSubset();
    fn test_field_initialized() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initialized) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(initialized)
            )
        );
    }
    test_field_initialized();
    fn test_field__private() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._private) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(_private)
            )
        );
    }
    test_field__private();
    fn test_field_startElementNs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).startElementNs) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(startElementNs)
            )
        );
    }
    test_field_startElementNs();
    fn test_field_endElementNs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).endElementNs) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(endElementNs)
            )
        );
    }
    test_field_endElementNs();
    fn test_field_serror() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).serror) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandler),
                "::",
                stringify!(serror)
            )
        );
    }
    test_field_serror();
}
pub type xmlSAXHandlerV1 = _xmlSAXHandlerV1;
pub type xmlSAXHandlerV1Ptr = *mut xmlSAXHandlerV1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSAXHandlerV1 {
    pub internalSubset: internalSubsetSAXFunc,
    pub isStandalone: isStandaloneSAXFunc,
    pub hasInternalSubset: hasInternalSubsetSAXFunc,
    pub hasExternalSubset: hasExternalSubsetSAXFunc,
    pub resolveEntity: resolveEntitySAXFunc,
    pub getEntity: getEntitySAXFunc,
    pub entityDecl: entityDeclSAXFunc,
    pub notationDecl: notationDeclSAXFunc,
    pub attributeDecl: attributeDeclSAXFunc,
    pub elementDecl: elementDeclSAXFunc,
    pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
    pub setDocumentLocator: setDocumentLocatorSAXFunc,
    pub startDocument: startDocumentSAXFunc,
    pub endDocument: endDocumentSAXFunc,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub reference: referenceSAXFunc,
    pub characters: charactersSAXFunc,
    pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
    pub processingInstruction: processingInstructionSAXFunc,
    pub comment: commentSAXFunc,
    pub warning: warningSAXFunc,
    pub error: errorSAXFunc,
    pub fatalError: fatalErrorSAXFunc,
    pub getParameterEntity: getParameterEntitySAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub externalSubset: externalSubsetSAXFunc,
    pub initialized: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__xmlSAXHandlerV1() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSAXHandlerV1>(),
        224usize,
        concat!("Size of: ", stringify!(_xmlSAXHandlerV1))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSAXHandlerV1>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSAXHandlerV1))
    );
    fn test_field_internalSubset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).internalSubset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(internalSubset)
            )
        );
    }
    test_field_internalSubset();
    fn test_field_isStandalone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isStandalone) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(isStandalone)
            )
        );
    }
    test_field_isStandalone();
    fn test_field_hasInternalSubset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hasInternalSubset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(hasInternalSubset)
            )
        );
    }
    test_field_hasInternalSubset();
    fn test_field_hasExternalSubset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hasExternalSubset) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(hasExternalSubset)
            )
        );
    }
    test_field_hasExternalSubset();
    fn test_field_resolveEntity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resolveEntity) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(resolveEntity)
            )
        );
    }
    test_field_resolveEntity();
    fn test_field_getEntity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getEntity) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(getEntity)
            )
        );
    }
    test_field_getEntity();
    fn test_field_entityDecl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entityDecl) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(entityDecl)
            )
        );
    }
    test_field_entityDecl();
    fn test_field_notationDecl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).notationDecl) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(notationDecl)
            )
        );
    }
    test_field_notationDecl();
    fn test_field_attributeDecl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attributeDecl) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(attributeDecl)
            )
        );
    }
    test_field_attributeDecl();
    fn test_field_elementDecl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).elementDecl) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(elementDecl)
            )
        );
    }
    test_field_elementDecl();
    fn test_field_unparsedEntityDecl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unparsedEntityDecl) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(unparsedEntityDecl)
            )
        );
    }
    test_field_unparsedEntityDecl();
    fn test_field_setDocumentLocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).setDocumentLocator) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(setDocumentLocator)
            )
        );
    }
    test_field_setDocumentLocator();
    fn test_field_startDocument() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).startDocument) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(startDocument)
            )
        );
    }
    test_field_startDocument();
    fn test_field_endDocument() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).endDocument) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(endDocument)
            )
        );
    }
    test_field_endDocument();
    fn test_field_startElement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).startElement) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(startElement)
            )
        );
    }
    test_field_startElement();
    fn test_field_endElement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).endElement) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(endElement)
            )
        );
    }
    test_field_endElement();
    fn test_field_reference() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reference) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(reference)
            )
        );
    }
    test_field_reference();
    fn test_field_characters() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).characters) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(characters)
            )
        );
    }
    test_field_characters();
    fn test_field_ignorableWhitespace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ignorableWhitespace) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(ignorableWhitespace)
            )
        );
    }
    test_field_ignorableWhitespace();
    fn test_field_processingInstruction() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).processingInstruction) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(processingInstruction)
            )
        );
    }
    test_field_processingInstruction();
    fn test_field_comment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).comment) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(comment)
            )
        );
    }
    test_field_comment();
    fn test_field_warning() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).warning) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(warning)
            )
        );
    }
    test_field_warning();
    fn test_field_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(error)
            )
        );
    }
    test_field_error();
    fn test_field_fatalError() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fatalError) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(fatalError)
            )
        );
    }
    test_field_fatalError();
    fn test_field_getParameterEntity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getParameterEntity) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(getParameterEntity)
            )
        );
    }
    test_field_getParameterEntity();
    fn test_field_cdataBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cdataBlock) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(cdataBlock)
            )
        );
    }
    test_field_cdataBlock();
    fn test_field_externalSubset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).externalSubset) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(externalSubset)
            )
        );
    }
    test_field_externalSubset();
    fn test_field_initialized() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSAXHandlerV1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initialized) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSAXHandlerV1),
                "::",
                stringify!(initialized)
            )
        );
    }
    test_field_initialized();
}
#[doc = " xmlExternalEntityLoader:"]
#[doc = " @URL: The System ID of the resource requested"]
#[doc = " @ID: The Public ID of the resource requested"]
#[doc = " @context: the XML parser context"]
#[doc = ""]
#[doc = " External entity loaders types."]
#[doc = ""]
#[doc = " Returns the entity input parser."]
pub type xmlExternalEntityLoader = ::std::option::Option<
    unsafe extern "C" fn(
        URL: *const ::std::os::raw::c_char,
        ID: *const ::std::os::raw::c_char,
        context: xmlParserCtxtPtr,
    ) -> xmlParserInputPtr,
>;
extern "C" {
    pub static mut _libiconv_version: ::std::os::raw::c_int;
}
pub type libiconv_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn libiconv_open(
        tocode: *const ::std::os::raw::c_char,
        fromcode: *const ::std::os::raw::c_char,
    ) -> libiconv_t;
}
extern "C" {
    pub fn libiconv(
        cd: libiconv_t,
        inbuf: *mut *mut ::std::os::raw::c_char,
        inbytesleft: *mut size_t,
        outbuf: *mut *mut ::std::os::raw::c_char,
        outbytesleft: *mut size_t,
    ) -> size_t;
}
extern "C" {
    pub fn libiconv_close(cd: libiconv_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wcschr(
        _Str: *const ::std::os::raw::c_ushort,
        _Ch: ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _cgetws_s(
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _SizeRead: *mut size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _cputws(_Buffer: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getwch() -> wint_t;
}
extern "C" {
    pub fn _getwche() -> wint_t;
}
extern "C" {
    pub fn _putwch(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn _ungetwch(_Character: wint_t) -> wint_t;
}
extern "C" {
    pub fn _getwch_nolock() -> wint_t;
}
extern "C" {
    pub fn _getwche_nolock() -> wint_t;
}
extern "C" {
    pub fn _putwch_nolock(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn _ungetwch_nolock(_Character: wint_t) -> wint_t;
}
extern "C" {
    pub fn __conio_common_vcwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __conio_common_vcwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __conio_common_vcwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __conio_common_vcwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __pctype_func() -> *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __pwctype_func() -> *const wctype_t;
}
extern "C" {
    pub fn iswalnum(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswalpha(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswascii(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswblank(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswcntrl(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswdigit(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswgraph(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswlower(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswprint(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswpunct(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswspace(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswupper(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswxdigit(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iswcsymf(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iswcsym(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswalnum_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswalpha_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswblank_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcntrl_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswdigit_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswgraph_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswlower_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswprint_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswpunct_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswspace_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswupper_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswxdigit_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcsymf_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcsym_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn towupper(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn towlower(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn iswctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _towupper_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn _towlower_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn _iswctype_l(_C: wint_t, _Type: wctype_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isleadbyte(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isleadbyte_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_wctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wgetcwd(_DstBuf: *mut wchar_t, _SizeInWords: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetdcwd(
        _Drive: ::std::os::raw::c_int,
        _DstBuf: *mut wchar_t,
        _SizeInWords: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wchdir(_Path: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wmkdir(_Path: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wrmdir(_Path: *const wchar_t) -> ::std::os::raw::c_int;
}
pub type _fsize_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wfinddata32_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time32_t,
    pub time_access: __time32_t,
    pub time_write: __time32_t,
    pub size: _fsize_t,
    pub name: [wchar_t; 260usize],
}
#[test]
fn bindgen_test_layout__wfinddata32_t() {
    assert_eq!(
        ::std::mem::size_of::<_wfinddata32_t>(),
        540usize,
        concat!("Size of: ", stringify!(_wfinddata32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_wfinddata32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_wfinddata32_t))
    );
    fn test_field_attrib() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attrib) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata32_t),
                "::",
                stringify!(attrib)
            )
        );
    }
    test_field_attrib();
    fn test_field_time_create() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_create) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata32_t),
                "::",
                stringify!(time_create)
            )
        );
    }
    test_field_time_create();
    fn test_field_time_access() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_access) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata32_t),
                "::",
                stringify!(time_access)
            )
        );
    }
    test_field_time_access();
    fn test_field_time_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_write) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata32_t),
                "::",
                stringify!(time_write)
            )
        );
    }
    test_field_time_write();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata32_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata32_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wfinddata32i64_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time32_t,
    pub time_access: __time32_t,
    pub time_write: __time32_t,
    pub size: ::std::os::raw::c_longlong,
    pub name: [wchar_t; 260usize],
}
#[test]
fn bindgen_test_layout__wfinddata32i64_t() {
    assert_eq!(
        ::std::mem::size_of::<_wfinddata32i64_t>(),
        544usize,
        concat!("Size of: ", stringify!(_wfinddata32i64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_wfinddata32i64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_wfinddata32i64_t))
    );
    fn test_field_attrib() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata32i64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attrib) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata32i64_t),
                "::",
                stringify!(attrib)
            )
        );
    }
    test_field_attrib();
    fn test_field_time_create() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata32i64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_create) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata32i64_t),
                "::",
                stringify!(time_create)
            )
        );
    }
    test_field_time_create();
    fn test_field_time_access() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata32i64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_access) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata32i64_t),
                "::",
                stringify!(time_access)
            )
        );
    }
    test_field_time_access();
    fn test_field_time_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata32i64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_write) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata32i64_t),
                "::",
                stringify!(time_write)
            )
        );
    }
    test_field_time_write();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata32i64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata32i64_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata32i64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata32i64_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wfinddata64i32_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time64_t,
    pub time_access: __time64_t,
    pub time_write: __time64_t,
    pub size: _fsize_t,
    pub name: [wchar_t; 260usize],
}
#[test]
fn bindgen_test_layout__wfinddata64i32_t() {
    assert_eq!(
        ::std::mem::size_of::<_wfinddata64i32_t>(),
        560usize,
        concat!("Size of: ", stringify!(_wfinddata64i32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_wfinddata64i32_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_wfinddata64i32_t))
    );
    fn test_field_attrib() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata64i32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attrib) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata64i32_t),
                "::",
                stringify!(attrib)
            )
        );
    }
    test_field_attrib();
    fn test_field_time_create() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata64i32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_create) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata64i32_t),
                "::",
                stringify!(time_create)
            )
        );
    }
    test_field_time_create();
    fn test_field_time_access() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata64i32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_access) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata64i32_t),
                "::",
                stringify!(time_access)
            )
        );
    }
    test_field_time_access();
    fn test_field_time_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata64i32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_write) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata64i32_t),
                "::",
                stringify!(time_write)
            )
        );
    }
    test_field_time_write();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata64i32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata64i32_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata64i32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata64i32_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wfinddata64_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time64_t,
    pub time_access: __time64_t,
    pub time_write: __time64_t,
    pub size: ::std::os::raw::c_longlong,
    pub name: [wchar_t; 260usize],
}
#[test]
fn bindgen_test_layout__wfinddata64_t() {
    assert_eq!(
        ::std::mem::size_of::<_wfinddata64_t>(),
        560usize,
        concat!("Size of: ", stringify!(_wfinddata64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_wfinddata64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_wfinddata64_t))
    );
    fn test_field_attrib() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attrib) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata64_t),
                "::",
                stringify!(attrib)
            )
        );
    }
    test_field_attrib();
    fn test_field_time_create() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_create) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata64_t),
                "::",
                stringify!(time_create)
            )
        );
    }
    test_field_time_create();
    fn test_field_time_access() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_access) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata64_t),
                "::",
                stringify!(time_access)
            )
        );
    }
    test_field_time_access();
    fn test_field_time_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_write) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata64_t),
                "::",
                stringify!(time_write)
            )
        );
    }
    test_field_time_write();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata64_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_wfinddata64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_wfinddata64_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
extern "C" {
    pub fn _waccess(
        _FileName: *const wchar_t,
        _AccessMode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _waccess_s(_FileName: *const wchar_t, _AccessMode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _wchmod(
        _FileName: *const wchar_t,
        _Mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcreat(
        _FileName: *const wchar_t,
        _PermissionMode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfindfirst32(_FileName: *const wchar_t, _FindData: *mut _wfinddata32_t) -> isize;
}
extern "C" {
    pub fn _wfindnext32(
        _FindHandle: isize,
        _FindData: *mut _wfinddata32_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wunlink(_FileName: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wrename(
        _OldFileName: *const wchar_t,
        _NewFileName: *const wchar_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wmktemp_s(_TemplateName: *mut wchar_t, _SizeInWords: size_t) -> errno_t;
}
extern "C" {
    pub fn _wmktemp(_TemplateName: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wfindfirst32i64(_FileName: *const wchar_t, _FindData: *mut _wfinddata32i64_t) -> isize;
}
extern "C" {
    pub fn _wfindfirst64i32(_FileName: *const wchar_t, _FindData: *mut _wfinddata64i32_t) -> isize;
}
extern "C" {
    pub fn _wfindfirst64(_FileName: *const wchar_t, _FindData: *mut _wfinddata64_t) -> isize;
}
extern "C" {
    pub fn _wfindnext32i64(
        _FindHandle: isize,
        _FindData: *mut _wfinddata32i64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfindnext64i32(
        _FindHandle: isize,
        _FindData: *mut _wfinddata64i32_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfindnext64(
        _FindHandle: isize,
        _FindData: *mut _wfinddata64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wsopen_s(
        _FileHandle: *mut ::std::os::raw::c_int,
        _FileName: *const wchar_t,
        _OpenFlag: ::std::os::raw::c_int,
        _ShareFlag: ::std::os::raw::c_int,
        _PermissionFlag: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsopen_dispatch(
        _FileName: *const wchar_t,
        _OFlag: ::std::os::raw::c_int,
        _ShFlag: ::std::os::raw::c_int,
        _PMode: ::std::os::raw::c_int,
        _PFileHandle: *mut ::std::os::raw::c_int,
        _BSecure: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _wopen(
        _FileName: *const wchar_t,
        _OpenFlag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wsopen(
        _FileName: *const wchar_t,
        _OpenFlag: ::std::os::raw::c_int,
        _ShareFlag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wexecl(_FileName: *const wchar_t, _ArgList: *const wchar_t, ...) -> isize;
}
extern "C" {
    pub fn _wexecle(_FileName: *const wchar_t, _ArgList: *const wchar_t, ...) -> isize;
}
extern "C" {
    pub fn _wexeclp(_FileName: *const wchar_t, _ArgList: *const wchar_t, ...) -> isize;
}
extern "C" {
    pub fn _wexeclpe(_FileName: *const wchar_t, _ArgList: *const wchar_t, ...) -> isize;
}
extern "C" {
    pub fn _wexecv(_FileName: *const wchar_t, _ArgList: *const *const wchar_t) -> isize;
}
extern "C" {
    pub fn _wexecve(
        _FileName: *const wchar_t,
        _ArgList: *const *const wchar_t,
        _Env: *const *const wchar_t,
    ) -> isize;
}
extern "C" {
    pub fn _wexecvp(_FileName: *const wchar_t, _ArgList: *const *const wchar_t) -> isize;
}
extern "C" {
    pub fn _wexecvpe(
        _FileName: *const wchar_t,
        _ArgList: *const *const wchar_t,
        _Env: *const *const wchar_t,
    ) -> isize;
}
extern "C" {
    pub fn _wspawnl(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const wchar_t,
        _ArgList: *const wchar_t,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _wspawnle(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const wchar_t,
        _ArgList: *const wchar_t,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _wspawnlp(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const wchar_t,
        _ArgList: *const wchar_t,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _wspawnlpe(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const wchar_t,
        _ArgList: *const wchar_t,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _wspawnv(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const wchar_t,
        _ArgList: *const *const wchar_t,
    ) -> isize;
}
extern "C" {
    pub fn _wspawnve(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const wchar_t,
        _ArgList: *const *const wchar_t,
        _Env: *const *const wchar_t,
    ) -> isize;
}
extern "C" {
    pub fn _wspawnvp(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const wchar_t,
        _ArgList: *const *const wchar_t,
    ) -> isize;
}
extern "C" {
    pub fn _wspawnvpe(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const wchar_t,
        _ArgList: *const *const wchar_t,
        _Env: *const *const wchar_t,
    ) -> isize;
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: size_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: size_t,
        _Dir: *mut wchar_t,
        _DirCount: size_t,
        _Filename: *mut wchar_t,
        _FilenameCount: size_t,
        _Ext: *mut wchar_t,
        _ExtCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut size_t,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut size_t,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcslen(_String: *const ::std::os::raw::c_ushort) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: size_t) -> size_t;
}
extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: size_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: size_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: size_t,
        _Value: wchar_t,
        _MaxCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: size_t, _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: size_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: size_t, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: size_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: size_t, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        36usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        4usize,
        concat!("Alignment of ", stringify!(tm))
    );
    fn test_field_tm_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_sec)
            )
        );
    }
    test_field_tm_sec();
    fn test_field_tm_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_min)
            )
        );
    }
    test_field_tm_min();
    fn test_field_tm_hour() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_hour)
            )
        );
    }
    test_field_tm_hour();
    fn test_field_tm_mday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mday)
            )
        );
    }
    test_field_tm_mday();
    fn test_field_tm_mon() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mon)
            )
        );
    }
    test_field_tm_mon();
    fn test_field_tm_year() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_year)
            )
        );
    }
    test_field_tm_year();
    fn test_field_tm_wday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_wday)
            )
        );
    }
    test_field_tm_wday();
    fn test_field_tm_yday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_yday)
            )
        );
    }
    test_field_tm_yday();
    fn test_field_tm_isdst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_isdst)
            )
        );
    }
    test_field_tm_isdst();
}
extern "C" {
    pub fn _wasctime(_Tm: *const tm) -> *mut wchar_t;
}
extern "C" {
    pub fn _wasctime_s(_Buffer: *mut wchar_t, _SizeInWords: size_t, _Tm: *const tm) -> errno_t;
}
extern "C" {
    pub fn wcsftime(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _Format: *const wchar_t,
        _Tm: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn _wcsftime_l(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _Format: *const wchar_t,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn _wctime32(_Time: *const __time32_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wctime32_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctime64(_Time: *const __time64_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wctime64_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wstrdate_s(_Buffer: *mut wchar_t, _SizeInWords: size_t) -> errno_t;
}
extern "C" {
    pub fn _wstrdate(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wstrtime_s(_Buffer: *mut wchar_t, _SizeInWords: size_t) -> errno_t;
}
extern "C" {
    pub fn _wstrtime(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
pub type _ino_t = ::std::os::raw::c_ushort;
pub type ino_t = _ino_t;
pub type _dev_t = ::std::os::raw::c_uint;
pub type dev_t = _dev_t;
pub type _off_t = ::std::os::raw::c_long;
pub type off_t = _off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _stat32 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: __time32_t,
    pub st_mtime: __time32_t,
    pub st_ctime: __time32_t,
}
#[test]
fn bindgen_test_layout__stat32() {
    assert_eq!(
        ::std::mem::size_of::<_stat32>(),
        36usize,
        concat!("Size of: ", stringify!(_stat32))
    );
    assert_eq!(
        ::std::mem::align_of::<_stat32>(),
        4usize,
        concat!("Alignment of ", stringify!(_stat32))
    );
    fn test_field_st_dev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32),
                "::",
                stringify!(st_dev)
            )
        );
    }
    test_field_st_dev();
    fn test_field_st_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32),
                "::",
                stringify!(st_ino)
            )
        );
    }
    test_field_st_ino();
    fn test_field_st_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32),
                "::",
                stringify!(st_mode)
            )
        );
    }
    test_field_st_mode();
    fn test_field_st_nlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32),
                "::",
                stringify!(st_nlink)
            )
        );
    }
    test_field_st_nlink();
    fn test_field_st_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32),
                "::",
                stringify!(st_uid)
            )
        );
    }
    test_field_st_uid();
    fn test_field_st_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32),
                "::",
                stringify!(st_gid)
            )
        );
    }
    test_field_st_gid();
    fn test_field_st_rdev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32),
                "::",
                stringify!(st_rdev)
            )
        );
    }
    test_field_st_rdev();
    fn test_field_st_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32),
                "::",
                stringify!(st_size)
            )
        );
    }
    test_field_st_size();
    fn test_field_st_atime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_atime) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32),
                "::",
                stringify!(st_atime)
            )
        );
    }
    test_field_st_atime();
    fn test_field_st_mtime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mtime) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32),
                "::",
                stringify!(st_mtime)
            )
        );
    }
    test_field_st_mtime();
    fn test_field_st_ctime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ctime) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32),
                "::",
                stringify!(st_ctime)
            )
        );
    }
    test_field_st_ctime();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _stat32i64 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: ::std::os::raw::c_longlong,
    pub st_atime: __time32_t,
    pub st_mtime: __time32_t,
    pub st_ctime: __time32_t,
}
#[test]
fn bindgen_test_layout__stat32i64() {
    assert_eq!(
        ::std::mem::size_of::<_stat32i64>(),
        48usize,
        concat!("Size of: ", stringify!(_stat32i64))
    );
    assert_eq!(
        ::std::mem::align_of::<_stat32i64>(),
        8usize,
        concat!("Alignment of ", stringify!(_stat32i64))
    );
    fn test_field_st_dev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32i64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32i64),
                "::",
                stringify!(st_dev)
            )
        );
    }
    test_field_st_dev();
    fn test_field_st_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32i64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32i64),
                "::",
                stringify!(st_ino)
            )
        );
    }
    test_field_st_ino();
    fn test_field_st_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32i64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32i64),
                "::",
                stringify!(st_mode)
            )
        );
    }
    test_field_st_mode();
    fn test_field_st_nlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32i64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32i64),
                "::",
                stringify!(st_nlink)
            )
        );
    }
    test_field_st_nlink();
    fn test_field_st_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32i64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32i64),
                "::",
                stringify!(st_uid)
            )
        );
    }
    test_field_st_uid();
    fn test_field_st_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32i64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32i64),
                "::",
                stringify!(st_gid)
            )
        );
    }
    test_field_st_gid();
    fn test_field_st_rdev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32i64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32i64),
                "::",
                stringify!(st_rdev)
            )
        );
    }
    test_field_st_rdev();
    fn test_field_st_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32i64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32i64),
                "::",
                stringify!(st_size)
            )
        );
    }
    test_field_st_size();
    fn test_field_st_atime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32i64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_atime) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32i64),
                "::",
                stringify!(st_atime)
            )
        );
    }
    test_field_st_atime();
    fn test_field_st_mtime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32i64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mtime) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32i64),
                "::",
                stringify!(st_mtime)
            )
        );
    }
    test_field_st_mtime();
    fn test_field_st_ctime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat32i64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ctime) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat32i64),
                "::",
                stringify!(st_ctime)
            )
        );
    }
    test_field_st_ctime();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _stat64i32 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: __time64_t,
    pub st_mtime: __time64_t,
    pub st_ctime: __time64_t,
}
#[test]
fn bindgen_test_layout__stat64i32() {
    assert_eq!(
        ::std::mem::size_of::<_stat64i32>(),
        48usize,
        concat!("Size of: ", stringify!(_stat64i32))
    );
    assert_eq!(
        ::std::mem::align_of::<_stat64i32>(),
        8usize,
        concat!("Alignment of ", stringify!(_stat64i32))
    );
    fn test_field_st_dev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64i32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64i32),
                "::",
                stringify!(st_dev)
            )
        );
    }
    test_field_st_dev();
    fn test_field_st_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64i32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64i32),
                "::",
                stringify!(st_ino)
            )
        );
    }
    test_field_st_ino();
    fn test_field_st_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64i32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64i32),
                "::",
                stringify!(st_mode)
            )
        );
    }
    test_field_st_mode();
    fn test_field_st_nlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64i32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64i32),
                "::",
                stringify!(st_nlink)
            )
        );
    }
    test_field_st_nlink();
    fn test_field_st_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64i32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64i32),
                "::",
                stringify!(st_uid)
            )
        );
    }
    test_field_st_uid();
    fn test_field_st_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64i32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64i32),
                "::",
                stringify!(st_gid)
            )
        );
    }
    test_field_st_gid();
    fn test_field_st_rdev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64i32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64i32),
                "::",
                stringify!(st_rdev)
            )
        );
    }
    test_field_st_rdev();
    fn test_field_st_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64i32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64i32),
                "::",
                stringify!(st_size)
            )
        );
    }
    test_field_st_size();
    fn test_field_st_atime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64i32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_atime) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64i32),
                "::",
                stringify!(st_atime)
            )
        );
    }
    test_field_st_atime();
    fn test_field_st_mtime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64i32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mtime) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64i32),
                "::",
                stringify!(st_mtime)
            )
        );
    }
    test_field_st_mtime();
    fn test_field_st_ctime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64i32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ctime) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64i32),
                "::",
                stringify!(st_ctime)
            )
        );
    }
    test_field_st_ctime();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _stat64 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: ::std::os::raw::c_longlong,
    pub st_atime: __time64_t,
    pub st_mtime: __time64_t,
    pub st_ctime: __time64_t,
}
#[test]
fn bindgen_test_layout__stat64() {
    assert_eq!(
        ::std::mem::size_of::<_stat64>(),
        56usize,
        concat!("Size of: ", stringify!(_stat64))
    );
    assert_eq!(
        ::std::mem::align_of::<_stat64>(),
        8usize,
        concat!("Alignment of ", stringify!(_stat64))
    );
    fn test_field_st_dev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64),
                "::",
                stringify!(st_dev)
            )
        );
    }
    test_field_st_dev();
    fn test_field_st_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64),
                "::",
                stringify!(st_ino)
            )
        );
    }
    test_field_st_ino();
    fn test_field_st_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64),
                "::",
                stringify!(st_mode)
            )
        );
    }
    test_field_st_mode();
    fn test_field_st_nlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64),
                "::",
                stringify!(st_nlink)
            )
        );
    }
    test_field_st_nlink();
    fn test_field_st_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64),
                "::",
                stringify!(st_uid)
            )
        );
    }
    test_field_st_uid();
    fn test_field_st_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64),
                "::",
                stringify!(st_gid)
            )
        );
    }
    test_field_st_gid();
    fn test_field_st_rdev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64),
                "::",
                stringify!(st_rdev)
            )
        );
    }
    test_field_st_rdev();
    fn test_field_st_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64),
                "::",
                stringify!(st_size)
            )
        );
    }
    test_field_st_size();
    fn test_field_st_atime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_atime) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64),
                "::",
                stringify!(st_atime)
            )
        );
    }
    test_field_st_atime();
    fn test_field_st_mtime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mtime) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64),
                "::",
                stringify!(st_mtime)
            )
        );
    }
    test_field_st_mtime();
    fn test_field_st_ctime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_stat64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ctime) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_stat64),
                "::",
                stringify!(st_ctime)
            )
        );
    }
    test_field_st_ctime();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: time_t,
    pub st_mtime: time_t,
    pub st_ctime: time_t,
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        48usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    fn test_field_st_dev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_dev)
            )
        );
    }
    test_field_st_dev();
    fn test_field_st_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_ino)
            )
        );
    }
    test_field_st_ino();
    fn test_field_st_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_mode)
            )
        );
    }
    test_field_st_mode();
    fn test_field_st_nlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_nlink)
            )
        );
    }
    test_field_st_nlink();
    fn test_field_st_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_uid)
            )
        );
    }
    test_field_st_uid();
    fn test_field_st_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_gid)
            )
        );
    }
    test_field_st_gid();
    fn test_field_st_rdev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_rdev)
            )
        );
    }
    test_field_st_rdev();
    fn test_field_st_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_size)
            )
        );
    }
    test_field_st_size();
    fn test_field_st_atime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_atime) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_atime)
            )
        );
    }
    test_field_st_atime();
    fn test_field_st_mtime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mtime) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_mtime)
            )
        );
    }
    test_field_st_mtime();
    fn test_field_st_ctime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ctime) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_ctime)
            )
        );
    }
    test_field_st_ctime();
}
extern "C" {
    pub fn _fstat32(
        _FileHandle: ::std::os::raw::c_int,
        _Stat: *mut _stat32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fstat32i64(
        _FileHandle: ::std::os::raw::c_int,
        _Stat: *mut _stat32i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fstat64i32(
        _FileHandle: ::std::os::raw::c_int,
        _Stat: *mut _stat64i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fstat64(
        _FileHandle: ::std::os::raw::c_int,
        _Stat: *mut _stat64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stat32(
        _FileName: *const ::std::os::raw::c_char,
        _Stat: *mut _stat32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stat32i64(
        _FileName: *const ::std::os::raw::c_char,
        _Stat: *mut _stat32i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stat64i32(
        _FileName: *const ::std::os::raw::c_char,
        _Stat: *mut _stat64i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stat64(
        _FileName: *const ::std::os::raw::c_char,
        _Stat: *mut _stat64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wstat32(_FileName: *const wchar_t, _Stat: *mut _stat32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wstat32i64(_FileName: *const wchar_t, _Stat: *mut _stat32i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wstat64i32(_FileName: *const wchar_t, _Stat: *mut _stat64i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wstat64(_FileName: *const wchar_t, _Stat: *mut _stat64) -> ::std::os::raw::c_int;
}
pub type _Wint_t = wchar_t;
extern "C" {
    pub fn _wsetlocale(_Category: ::std::os::raw::c_int, _Locale: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcreate_locale(_Category: ::std::os::raw::c_int, _Locale: *const wchar_t) -> _locale_t;
}
extern "C" {
    pub fn btowc(_Ch: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn mbrlen(
        _Ch: *const ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _State: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbrtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _State: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbsrtowcs_s(
        _Retval: *mut size_t,
        _Dst: *mut wchar_t,
        _Size: size_t,
        _PSrc: *mut *const ::std::os::raw::c_char,
        _N: size_t,
        _State: *mut mbstate_t,
    ) -> errno_t;
}
extern "C" {
    pub fn mbsrtowcs(
        _Dest: *mut wchar_t,
        _PSrc: *mut *const ::std::os::raw::c_char,
        _Count: size_t,
        _State: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcrtomb_s(
        _Retval: *mut size_t,
        _Dst: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _Ch: wchar_t,
        _State: *mut mbstate_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcrtomb(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: wchar_t,
        _State: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcsrtombs_s(
        _Retval: *mut size_t,
        _Dst: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _Src: *mut *const wchar_t,
        _Size: size_t,
        _State: *mut mbstate_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsrtombs(
        _Dest: *mut ::std::os::raw::c_char,
        _PSource: *mut *const wchar_t,
        _Count: size_t,
        _State: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wctob(_WCh: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy_s(_S1: *mut wchar_t, _N1: rsize_t, _S2: *const wchar_t, _N: rsize_t) -> errno_t;
}
extern "C" {
    pub fn wmemmove_s(_S1: *mut wchar_t, _N1: rsize_t, _S2: *const wchar_t, _N: rsize_t)
        -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iconv_allocation_t {
    pub dummy1: [*mut ::std::os::raw::c_void; 28usize],
    pub dummy2: mbstate_t,
}
#[test]
fn bindgen_test_layout_iconv_allocation_t() {
    assert_eq!(
        ::std::mem::size_of::<iconv_allocation_t>(),
        232usize,
        concat!("Size of: ", stringify!(iconv_allocation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iconv_allocation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iconv_allocation_t))
    );
    fn test_field_dummy1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iconv_allocation_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iconv_allocation_t),
                "::",
                stringify!(dummy1)
            )
        );
    }
    test_field_dummy1();
    fn test_field_dummy2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iconv_allocation_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy2) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(iconv_allocation_t),
                "::",
                stringify!(dummy2)
            )
        );
    }
    test_field_dummy2();
}
extern "C" {
    pub fn libiconv_open_into(
        tocode: *const ::std::os::raw::c_char,
        fromcode: *const ::std::os::raw::c_char,
        resultp: *mut iconv_allocation_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libiconvctl(
        cd: libiconv_t,
        request: ::std::os::raw::c_int,
        argument: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type iconv_unicode_char_hook = ::std::option::Option<
    unsafe extern "C" fn(uc: ::std::os::raw::c_uint, data: *mut ::std::os::raw::c_void),
>;
pub type iconv_wide_char_hook =
    ::std::option::Option<unsafe extern "C" fn(wc: wchar_t, data: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iconv_hooks {
    pub uc_hook: iconv_unicode_char_hook,
    pub wc_hook: iconv_wide_char_hook,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_iconv_hooks() {
    assert_eq!(
        ::std::mem::size_of::<iconv_hooks>(),
        24usize,
        concat!("Size of: ", stringify!(iconv_hooks))
    );
    assert_eq!(
        ::std::mem::align_of::<iconv_hooks>(),
        8usize,
        concat!("Alignment of ", stringify!(iconv_hooks))
    );
    fn test_field_uc_hook() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iconv_hooks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_hook) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iconv_hooks),
                "::",
                stringify!(uc_hook)
            )
        );
    }
    test_field_uc_hook();
    fn test_field_wc_hook() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iconv_hooks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wc_hook) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iconv_hooks),
                "::",
                stringify!(wc_hook)
            )
        );
    }
    test_field_wc_hook();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iconv_hooks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(iconv_hooks),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
pub type iconv_unicode_mb_to_uc_fallback = ::std::option::Option<
    unsafe extern "C" fn(
        inbuf: *const ::std::os::raw::c_char,
        inbufsize: size_t,
        write_replacement: ::std::option::Option<
            unsafe extern "C" fn(
                buf: *const ::std::os::raw::c_uint,
                buflen: size_t,
                callback_arg: *mut ::std::os::raw::c_void,
            ),
        >,
        callback_arg: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ),
>;
pub type iconv_unicode_uc_to_mb_fallback = ::std::option::Option<
    unsafe extern "C" fn(
        code: ::std::os::raw::c_uint,
        write_replacement: ::std::option::Option<
            unsafe extern "C" fn(
                buf: *const ::std::os::raw::c_char,
                buflen: size_t,
                callback_arg: *mut ::std::os::raw::c_void,
            ),
        >,
        callback_arg: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ),
>;
pub type iconv_wchar_mb_to_wc_fallback = ::std::option::Option<
    unsafe extern "C" fn(
        inbuf: *const ::std::os::raw::c_char,
        inbufsize: size_t,
        write_replacement: ::std::option::Option<
            unsafe extern "C" fn(
                buf: *const wchar_t,
                buflen: size_t,
                callback_arg: *mut ::std::os::raw::c_void,
            ),
        >,
        callback_arg: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ),
>;
pub type iconv_wchar_wc_to_mb_fallback = ::std::option::Option<
    unsafe extern "C" fn(
        code: wchar_t,
        write_replacement: ::std::option::Option<
            unsafe extern "C" fn(
                buf: *const ::std::os::raw::c_char,
                buflen: size_t,
                callback_arg: *mut ::std::os::raw::c_void,
            ),
        >,
        callback_arg: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iconv_fallbacks {
    pub mb_to_uc_fallback: iconv_unicode_mb_to_uc_fallback,
    pub uc_to_mb_fallback: iconv_unicode_uc_to_mb_fallback,
    pub mb_to_wc_fallback: iconv_wchar_mb_to_wc_fallback,
    pub wc_to_mb_fallback: iconv_wchar_wc_to_mb_fallback,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_iconv_fallbacks() {
    assert_eq!(
        ::std::mem::size_of::<iconv_fallbacks>(),
        40usize,
        concat!("Size of: ", stringify!(iconv_fallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<iconv_fallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(iconv_fallbacks))
    );
    fn test_field_mb_to_uc_fallback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iconv_fallbacks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mb_to_uc_fallback) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iconv_fallbacks),
                "::",
                stringify!(mb_to_uc_fallback)
            )
        );
    }
    test_field_mb_to_uc_fallback();
    fn test_field_uc_to_mb_fallback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iconv_fallbacks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_to_mb_fallback) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iconv_fallbacks),
                "::",
                stringify!(uc_to_mb_fallback)
            )
        );
    }
    test_field_uc_to_mb_fallback();
    fn test_field_mb_to_wc_fallback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iconv_fallbacks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mb_to_wc_fallback) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(iconv_fallbacks),
                "::",
                stringify!(mb_to_wc_fallback)
            )
        );
    }
    test_field_mb_to_wc_fallback();
    fn test_field_wc_to_mb_fallback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iconv_fallbacks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wc_to_mb_fallback) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(iconv_fallbacks),
                "::",
                stringify!(wc_to_mb_fallback)
            )
        );
    }
    test_field_wc_to_mb_fallback();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iconv_fallbacks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(iconv_fallbacks),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
extern "C" {
    pub fn libiconvlist(
        do_one: ::std::option::Option<
            unsafe extern "C" fn(
                namescount: ::std::os::raw::c_uint,
                names: *const *const ::std::os::raw::c_char,
                data: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn iconv_canonicalize(name: *const ::std::os::raw::c_char)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn libiconv_set_relocation_prefix(
        orig_prefix: *const ::std::os::raw::c_char,
        curr_prefix: *const ::std::os::raw::c_char,
    );
}
pub const xmlCharEncoding_XML_CHAR_ENCODING_ERROR: xmlCharEncoding = -1;
pub const xmlCharEncoding_XML_CHAR_ENCODING_NONE: xmlCharEncoding = 0;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UTF8: xmlCharEncoding = 1;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UTF16LE: xmlCharEncoding = 2;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UTF16BE: xmlCharEncoding = 3;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4LE: xmlCharEncoding = 4;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4BE: xmlCharEncoding = 5;
pub const xmlCharEncoding_XML_CHAR_ENCODING_EBCDIC: xmlCharEncoding = 6;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4_2143: xmlCharEncoding = 7;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4_3412: xmlCharEncoding = 8;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS2: xmlCharEncoding = 9;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_1: xmlCharEncoding = 10;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_2: xmlCharEncoding = 11;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_3: xmlCharEncoding = 12;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_4: xmlCharEncoding = 13;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_5: xmlCharEncoding = 14;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_6: xmlCharEncoding = 15;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_7: xmlCharEncoding = 16;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_8: xmlCharEncoding = 17;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_9: xmlCharEncoding = 18;
pub const xmlCharEncoding_XML_CHAR_ENCODING_2022_JP: xmlCharEncoding = 19;
pub const xmlCharEncoding_XML_CHAR_ENCODING_SHIFT_JIS: xmlCharEncoding = 20;
pub const xmlCharEncoding_XML_CHAR_ENCODING_EUC_JP: xmlCharEncoding = 21;
pub const xmlCharEncoding_XML_CHAR_ENCODING_ASCII: xmlCharEncoding = 22;
pub type xmlCharEncoding = ::std::os::raw::c_int;
#[doc = " xmlCharEncodingInputFunc:"]
#[doc = " @out:  a pointer to an array of bytes to store the UTF-8 result"]
#[doc = " @outlen:  the length of @out"]
#[doc = " @in:  a pointer to an array of chars in the original encoding"]
#[doc = " @inlen:  the length of @in"]
#[doc = ""]
#[doc = " Take a block of chars in the original encoding and try to convert"]
#[doc = " it to an UTF-8 block of chars out."]
#[doc = ""]
#[doc = " Returns the number of bytes written, -1 if lack of space, or -2"]
#[doc = "     if the transcoding failed."]
#[doc = " The value of @inlen after return is the number of octets consumed"]
#[doc = "     if the return value is positive, else unpredictiable."]
#[doc = " The value of @outlen after return is the number of octets consumed."]
pub type xmlCharEncodingInputFunc = ::std::option::Option<
    unsafe extern "C" fn(
        out: *mut ::std::os::raw::c_uchar,
        outlen: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_uchar,
        inlen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlCharEncodingOutputFunc:"]
#[doc = " @out:  a pointer to an array of bytes to store the result"]
#[doc = " @outlen:  the length of @out"]
#[doc = " @in:  a pointer to an array of UTF-8 chars"]
#[doc = " @inlen:  the length of @in"]
#[doc = ""]
#[doc = " Take a block of UTF-8 chars in and try to convert it to another"]
#[doc = " encoding."]
#[doc = " Note: a first call designed to produce heading info is called with"]
#[doc = " in = NULL. If stateful this should also initialize the encoder state."]
#[doc = ""]
#[doc = " Returns the number of bytes written, -1 if lack of space, or -2"]
#[doc = "     if the transcoding failed."]
#[doc = " The value of @inlen after return is the number of octets consumed"]
#[doc = "     if the return value is positive, else unpredictiable."]
#[doc = " The value of @outlen after return is the number of octets produced."]
pub type xmlCharEncodingOutputFunc = ::std::option::Option<
    unsafe extern "C" fn(
        out: *mut ::std::os::raw::c_uchar,
        outlen: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_uchar,
        inlen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type xmlCharEncodingHandler = _xmlCharEncodingHandler;
pub type xmlCharEncodingHandlerPtr = *mut xmlCharEncodingHandler;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlCharEncodingHandler {
    pub name: *mut ::std::os::raw::c_char,
    pub input: xmlCharEncodingInputFunc,
    pub output: xmlCharEncodingOutputFunc,
    pub iconv_in: libiconv_t,
    pub iconv_out: libiconv_t,
}
#[test]
fn bindgen_test_layout__xmlCharEncodingHandler() {
    assert_eq!(
        ::std::mem::size_of::<_xmlCharEncodingHandler>(),
        40usize,
        concat!("Size of: ", stringify!(_xmlCharEncodingHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlCharEncodingHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlCharEncodingHandler))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlCharEncodingHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlCharEncodingHandler),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_input() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlCharEncodingHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlCharEncodingHandler),
                "::",
                stringify!(input)
            )
        );
    }
    test_field_input();
    fn test_field_output() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlCharEncodingHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).output) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlCharEncodingHandler),
                "::",
                stringify!(output)
            )
        );
    }
    test_field_output();
    fn test_field_iconv_in() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlCharEncodingHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iconv_in) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlCharEncodingHandler),
                "::",
                stringify!(iconv_in)
            )
        );
    }
    test_field_iconv_in();
    fn test_field_iconv_out() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlCharEncodingHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iconv_out) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlCharEncodingHandler),
                "::",
                stringify!(iconv_out)
            )
        );
    }
    test_field_iconv_out();
}
extern "C" {
    pub fn xmlInitCharEncodingHandlers();
}
extern "C" {
    pub fn xmlCleanupCharEncodingHandlers();
}
extern "C" {
    pub fn xmlRegisterCharEncodingHandler(handler: xmlCharEncodingHandlerPtr);
}
extern "C" {
    pub fn xmlGetCharEncodingHandler(enc: xmlCharEncoding) -> xmlCharEncodingHandlerPtr;
}
extern "C" {
    pub fn xmlFindCharEncodingHandler(
        name: *const ::std::os::raw::c_char,
    ) -> xmlCharEncodingHandlerPtr;
}
extern "C" {
    pub fn xmlNewCharEncodingHandler(
        name: *const ::std::os::raw::c_char,
        input: xmlCharEncodingInputFunc,
        output: xmlCharEncodingOutputFunc,
    ) -> xmlCharEncodingHandlerPtr;
}
extern "C" {
    pub fn xmlAddEncodingAlias(
        name: *const ::std::os::raw::c_char,
        alias: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlDelEncodingAlias(alias: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlGetEncodingAlias(
        alias: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn xmlCleanupEncodingAliases();
}
extern "C" {
    pub fn xmlParseCharEncoding(name: *const ::std::os::raw::c_char) -> xmlCharEncoding;
}
extern "C" {
    pub fn xmlGetCharEncodingName(enc: xmlCharEncoding) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn xmlDetectCharEncoding(
        in_: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> xmlCharEncoding;
}
extern "C" {
    pub fn xmlCharEncOutFunc(
        handler: *mut xmlCharEncodingHandler,
        out: xmlBufferPtr,
        in_: xmlBufferPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlCharEncInFunc(
        handler: *mut xmlCharEncodingHandler,
        out: xmlBufferPtr,
        in_: xmlBufferPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlCharEncFirstLine(
        handler: *mut xmlCharEncodingHandler,
        out: xmlBufferPtr,
        in_: xmlBufferPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlCharEncCloseFunc(handler: *mut xmlCharEncodingHandler) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn UTF8Toisolat1(
        out: *mut ::std::os::raw::c_uchar,
        outlen: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_uchar,
        inlen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isolat1ToUTF8(
        out: *mut ::std::os::raw::c_uchar,
        outlen: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_uchar,
        inlen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " xmlInputMatchCallback:"]
#[doc = " @filename: the filename or URI"]
#[doc = ""]
#[doc = " Callback used in the I/O Input API to detect if the current handler"]
#[doc = " can provide input functionality for this resource."]
#[doc = ""]
#[doc = " Returns 1 if yes and 0 if another Input module should be used"]
pub type xmlInputMatchCallback = ::std::option::Option<
    unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
>;
#[doc = " xmlInputOpenCallback:"]
#[doc = " @filename: the filename or URI"]
#[doc = ""]
#[doc = " Callback used in the I/O Input API to open the resource"]
#[doc = ""]
#[doc = " Returns an Input context or NULL in case or error"]
pub type xmlInputOpenCallback = ::std::option::Option<
    unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void,
>;
#[doc = " xmlInputReadCallback:"]
#[doc = " @context:  an Input context"]
#[doc = " @buffer:  the buffer to store data read"]
#[doc = " @len:  the length of the buffer in bytes"]
#[doc = ""]
#[doc = " Callback used in the I/O Input API to read the resource"]
#[doc = ""]
#[doc = " Returns the number of bytes read or -1 in case of error"]
pub type xmlInputReadCallback = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlInputCloseCallback:"]
#[doc = " @context:  an Input context"]
#[doc = ""]
#[doc = " Callback used in the I/O Input API to close the resource"]
#[doc = ""]
#[doc = " Returns 0 or -1 in case of error"]
pub type xmlInputCloseCallback = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " xmlOutputMatchCallback:"]
#[doc = " @filename: the filename or URI"]
#[doc = ""]
#[doc = " Callback used in the I/O Output API to detect if the current handler"]
#[doc = " can provide output functionality for this resource."]
#[doc = ""]
#[doc = " Returns 1 if yes and 0 if another Output module should be used"]
pub type xmlOutputMatchCallback = ::std::option::Option<
    unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
>;
#[doc = " xmlOutputOpenCallback:"]
#[doc = " @filename: the filename or URI"]
#[doc = ""]
#[doc = " Callback used in the I/O Output API to open the resource"]
#[doc = ""]
#[doc = " Returns an Output context or NULL in case or error"]
pub type xmlOutputOpenCallback = ::std::option::Option<
    unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void,
>;
#[doc = " xmlOutputWriteCallback:"]
#[doc = " @context:  an Output context"]
#[doc = " @buffer:  the buffer of data to write"]
#[doc = " @len:  the length of the buffer in bytes"]
#[doc = ""]
#[doc = " Callback used in the I/O Output API to write to the resource"]
#[doc = ""]
#[doc = " Returns the number of bytes written or -1 in case of error"]
pub type xmlOutputWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        buffer: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlOutputCloseCallback:"]
#[doc = " @context:  an Output context"]
#[doc = ""]
#[doc = " Callback used in the I/O Output API to close the resource"]
#[doc = ""]
#[doc = " Returns 0 or -1 in case of error"]
pub type xmlOutputCloseCallback = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserInputBuffer {
    pub context: *mut ::std::os::raw::c_void,
    pub readcallback: xmlInputReadCallback,
    pub closecallback: xmlInputCloseCallback,
    pub encoder: xmlCharEncodingHandlerPtr,
    pub buffer: xmlBufPtr,
    pub raw: xmlBufPtr,
    pub compressed: ::std::os::raw::c_int,
    pub error: ::std::os::raw::c_int,
    pub rawconsumed: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__xmlParserInputBuffer() {
    assert_eq!(
        ::std::mem::size_of::<_xmlParserInputBuffer>(),
        64usize,
        concat!("Size of: ", stringify!(_xmlParserInputBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlParserInputBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlParserInputBuffer))
    );
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInputBuffer),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_readcallback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).readcallback) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInputBuffer),
                "::",
                stringify!(readcallback)
            )
        );
    }
    test_field_readcallback();
    fn test_field_closecallback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).closecallback) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInputBuffer),
                "::",
                stringify!(closecallback)
            )
        );
    }
    test_field_closecallback();
    fn test_field_encoder() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).encoder) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInputBuffer),
                "::",
                stringify!(encoder)
            )
        );
    }
    test_field_encoder();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInputBuffer),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInputBuffer),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_compressed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compressed) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInputBuffer),
                "::",
                stringify!(compressed)
            )
        );
    }
    test_field_compressed();
    fn test_field_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInputBuffer),
                "::",
                stringify!(error)
            )
        );
    }
    test_field_error();
    fn test_field_rawconsumed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlParserInputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rawconsumed) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlParserInputBuffer),
                "::",
                stringify!(rawconsumed)
            )
        );
    }
    test_field_rawconsumed();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlOutputBuffer {
    pub context: *mut ::std::os::raw::c_void,
    pub writecallback: xmlOutputWriteCallback,
    pub closecallback: xmlOutputCloseCallback,
    pub encoder: xmlCharEncodingHandlerPtr,
    pub buffer: xmlBufPtr,
    pub conv: xmlBufPtr,
    pub written: ::std::os::raw::c_int,
    pub error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlOutputBuffer() {
    assert_eq!(
        ::std::mem::size_of::<_xmlOutputBuffer>(),
        56usize,
        concat!("Size of: ", stringify!(_xmlOutputBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlOutputBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlOutputBuffer))
    );
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlOutputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlOutputBuffer),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_writecallback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlOutputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).writecallback) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlOutputBuffer),
                "::",
                stringify!(writecallback)
            )
        );
    }
    test_field_writecallback();
    fn test_field_closecallback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlOutputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).closecallback) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlOutputBuffer),
                "::",
                stringify!(closecallback)
            )
        );
    }
    test_field_closecallback();
    fn test_field_encoder() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlOutputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).encoder) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlOutputBuffer),
                "::",
                stringify!(encoder)
            )
        );
    }
    test_field_encoder();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlOutputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlOutputBuffer),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_conv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlOutputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).conv) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlOutputBuffer),
                "::",
                stringify!(conv)
            )
        );
    }
    test_field_conv();
    fn test_field_written() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlOutputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).written) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlOutputBuffer),
                "::",
                stringify!(written)
            )
        );
    }
    test_field_written();
    fn test_field_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlOutputBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlOutputBuffer),
                "::",
                stringify!(error)
            )
        );
    }
    test_field_error();
}
extern "C" {
    pub fn xmlCleanupInputCallbacks();
}
extern "C" {
    pub fn xmlPopInputCallbacks() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlRegisterDefaultInputCallbacks();
}
extern "C" {
    pub fn xmlAllocParserInputBuffer(enc: xmlCharEncoding) -> xmlParserInputBufferPtr;
}
extern "C" {
    pub fn xmlParserInputBufferCreateFilename(
        URI: *const ::std::os::raw::c_char,
        enc: xmlCharEncoding,
    ) -> xmlParserInputBufferPtr;
}
extern "C" {
    pub fn xmlParserInputBufferCreateFile(
        file: *mut FILE,
        enc: xmlCharEncoding,
    ) -> xmlParserInputBufferPtr;
}
extern "C" {
    pub fn xmlParserInputBufferCreateFd(
        fd: ::std::os::raw::c_int,
        enc: xmlCharEncoding,
    ) -> xmlParserInputBufferPtr;
}
extern "C" {
    pub fn xmlParserInputBufferCreateMem(
        mem: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        enc: xmlCharEncoding,
    ) -> xmlParserInputBufferPtr;
}
extern "C" {
    pub fn xmlParserInputBufferCreateStatic(
        mem: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        enc: xmlCharEncoding,
    ) -> xmlParserInputBufferPtr;
}
extern "C" {
    pub fn xmlParserInputBufferCreateIO(
        ioread: xmlInputReadCallback,
        ioclose: xmlInputCloseCallback,
        ioctx: *mut ::std::os::raw::c_void,
        enc: xmlCharEncoding,
    ) -> xmlParserInputBufferPtr;
}
extern "C" {
    pub fn xmlParserInputBufferRead(
        in_: xmlParserInputBufferPtr,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlParserInputBufferGrow(
        in_: xmlParserInputBufferPtr,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlParserInputBufferPush(
        in_: xmlParserInputBufferPtr,
        len: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlFreeParserInputBuffer(in_: xmlParserInputBufferPtr);
}
extern "C" {
    pub fn xmlParserGetDirectory(
        filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xmlRegisterInputCallbacks(
        matchFunc: xmlInputMatchCallback,
        openFunc: xmlInputOpenCallback,
        readFunc: xmlInputReadCallback,
        closeFunc: xmlInputCloseCallback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmlParserInputBufferCreateFilename(
        URI: *const ::std::os::raw::c_char,
        enc: xmlCharEncoding,
    ) -> xmlParserInputBufferPtr;
}
extern "C" {
    pub fn xmlCleanupOutputCallbacks();
}
extern "C" {
    pub fn xmlPopOutputCallbacks() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlRegisterDefaultOutputCallbacks();
}
extern "C" {
    pub fn xmlAllocOutputBuffer(encoder: xmlCharEncodingHandlerPtr) -> xmlOutputBufferPtr;
}
extern "C" {
    pub fn xmlOutputBufferCreateFilename(
        URI: *const ::std::os::raw::c_char,
        encoder: xmlCharEncodingHandlerPtr,
        compression: ::std::os::raw::c_int,
    ) -> xmlOutputBufferPtr;
}
extern "C" {
    pub fn xmlOutputBufferCreateFile(
        file: *mut FILE,
        encoder: xmlCharEncodingHandlerPtr,
    ) -> xmlOutputBufferPtr;
}
extern "C" {
    pub fn xmlOutputBufferCreateBuffer(
        buffer: xmlBufferPtr,
        encoder: xmlCharEncodingHandlerPtr,
    ) -> xmlOutputBufferPtr;
}
extern "C" {
    pub fn xmlOutputBufferCreateFd(
        fd: ::std::os::raw::c_int,
        encoder: xmlCharEncodingHandlerPtr,
    ) -> xmlOutputBufferPtr;
}
extern "C" {
    pub fn xmlOutputBufferCreateIO(
        iowrite: xmlOutputWriteCallback,
        ioclose: xmlOutputCloseCallback,
        ioctx: *mut ::std::os::raw::c_void,
        encoder: xmlCharEncodingHandlerPtr,
    ) -> xmlOutputBufferPtr;
}
extern "C" {
    pub fn xmlOutputBufferGetContent(out: xmlOutputBufferPtr) -> *const xmlChar;
}
extern "C" {
    pub fn xmlOutputBufferGetSize(out: xmlOutputBufferPtr) -> size_t;
}
extern "C" {
    pub fn xmlOutputBufferWrite(
        out: xmlOutputBufferPtr,
        len: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlOutputBufferWriteString(
        out: xmlOutputBufferPtr,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlOutputBufferWriteEscape(
        out: xmlOutputBufferPtr,
        str_: *const xmlChar,
        escaping: xmlCharEncodingOutputFunc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlOutputBufferFlush(out: xmlOutputBufferPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlOutputBufferClose(out: xmlOutputBufferPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlRegisterOutputCallbacks(
        matchFunc: xmlOutputMatchCallback,
        openFunc: xmlOutputOpenCallback,
        writeFunc: xmlOutputWriteCallback,
        closeFunc: xmlOutputCloseCallback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmlOutputBufferCreateFilename(
        URI: *const ::std::os::raw::c_char,
        encoder: xmlCharEncodingHandlerPtr,
        compression: ::std::os::raw::c_int,
    ) -> xmlOutputBufferPtr;
}
extern "C" {
    pub fn xmlRegisterHTTPPostCallbacks();
}
extern "C" {
    pub fn xmlCheckHTTPInput(ctxt: xmlParserCtxtPtr, ret: xmlParserInputPtr) -> xmlParserInputPtr;
}
extern "C" {
    pub fn xmlNoNetExternalEntityLoader(
        URL: *const ::std::os::raw::c_char,
        ID: *const ::std::os::raw::c_char,
        ctxt: xmlParserCtxtPtr,
    ) -> xmlParserInputPtr;
}
extern "C" {
    pub fn xmlNormalizeWindowsPath(path: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlCheckFilename(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Default 'file://' protocol callbacks"]
    pub fn xmlFileMatch(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlFileOpen(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlFileRead(
        context: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlFileClose(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlIOHTTPMatch(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlIOHTTPOpen(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlIOHTTPOpenW(
        post_uri: *const ::std::os::raw::c_char,
        compression: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlIOHTTPRead(
        context: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlIOHTTPClose(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlIOFTPMatch(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlIOFTPOpen(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xmlIOFTPRead(
        context: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlIOFTPClose(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlInitParser();
}
extern "C" {
    pub fn xmlCleanupParser();
}
extern "C" {
    pub fn xmlParserInputRead(
        in_: xmlParserInputPtr,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlParserInputGrow(
        in_: xmlParserInputPtr,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlParseDoc(cur: *const xmlChar) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlParseFile(filename: *const ::std::os::raw::c_char) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlParseMemory(
        buffer: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlSubstituteEntitiesDefault(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlKeepBlanksDefault(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlStopParser(ctxt: xmlParserCtxtPtr);
}
extern "C" {
    pub fn xmlPedanticParserDefault(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlLineNumbersDefault(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlRecoverDoc(cur: *const xmlChar) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlRecoverMemory(
        buffer: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlRecoverFile(filename: *const ::std::os::raw::c_char) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlParseDocument(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlParseExtParsedEnt(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSAXUserParseFile(
        sax: xmlSAXHandlerPtr,
        user_data: *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSAXUserParseMemory(
        sax: xmlSAXHandlerPtr,
        user_data: *mut ::std::os::raw::c_void,
        buffer: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSAXParseDoc(
        sax: xmlSAXHandlerPtr,
        cur: *const xmlChar,
        recovery: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlSAXParseMemory(
        sax: xmlSAXHandlerPtr,
        buffer: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        recovery: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlSAXParseMemoryWithData(
        sax: xmlSAXHandlerPtr,
        buffer: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        recovery: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlSAXParseFile(
        sax: xmlSAXHandlerPtr,
        filename: *const ::std::os::raw::c_char,
        recovery: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlSAXParseFileWithData(
        sax: xmlSAXHandlerPtr,
        filename: *const ::std::os::raw::c_char,
        recovery: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlSAXParseEntity(
        sax: xmlSAXHandlerPtr,
        filename: *const ::std::os::raw::c_char,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlParseEntity(filename: *const ::std::os::raw::c_char) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlSAXParseDTD(
        sax: xmlSAXHandlerPtr,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
    ) -> xmlDtdPtr;
}
extern "C" {
    pub fn xmlParseDTD(ExternalID: *const xmlChar, SystemID: *const xmlChar) -> xmlDtdPtr;
}
extern "C" {
    pub fn xmlIOParseDTD(
        sax: xmlSAXHandlerPtr,
        input: xmlParserInputBufferPtr,
        enc: xmlCharEncoding,
    ) -> xmlDtdPtr;
}
extern "C" {
    pub fn xmlParseBalancedChunkMemory(
        doc: xmlDocPtr,
        sax: xmlSAXHandlerPtr,
        user_data: *mut ::std::os::raw::c_void,
        depth: ::std::os::raw::c_int,
        string: *const xmlChar,
        lst: *mut xmlNodePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlParseInNodeContext(
        node: xmlNodePtr,
        data: *const ::std::os::raw::c_char,
        datalen: ::std::os::raw::c_int,
        options: ::std::os::raw::c_int,
        lst: *mut xmlNodePtr,
    ) -> xmlParserErrors;
}
extern "C" {
    pub fn xmlParseBalancedChunkMemoryRecover(
        doc: xmlDocPtr,
        sax: xmlSAXHandlerPtr,
        user_data: *mut ::std::os::raw::c_void,
        depth: ::std::os::raw::c_int,
        string: *const xmlChar,
        lst: *mut xmlNodePtr,
        recover: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlParseExternalEntity(
        doc: xmlDocPtr,
        sax: xmlSAXHandlerPtr,
        user_data: *mut ::std::os::raw::c_void,
        depth: ::std::os::raw::c_int,
        URL: *const xmlChar,
        ID: *const xmlChar,
        lst: *mut xmlNodePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlParseCtxtExternalEntity(
        ctx: xmlParserCtxtPtr,
        URL: *const xmlChar,
        ID: *const xmlChar,
        lst: *mut xmlNodePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlNewParserCtxt() -> xmlParserCtxtPtr;
}
extern "C" {
    pub fn xmlInitParserCtxt(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlClearParserCtxt(ctxt: xmlParserCtxtPtr);
}
extern "C" {
    pub fn xmlFreeParserCtxt(ctxt: xmlParserCtxtPtr);
}
extern "C" {
    pub fn xmlSetupParserForBuffer(
        ctxt: xmlParserCtxtPtr,
        buffer: *const xmlChar,
        filename: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn xmlCreateDocParserCtxt(cur: *const xmlChar) -> xmlParserCtxtPtr;
}
extern "C" {
    pub fn xmlGetFeaturesList(
        len: *mut ::std::os::raw::c_int,
        result: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlGetFeature(
        ctxt: xmlParserCtxtPtr,
        name: *const ::std::os::raw::c_char,
        result: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSetFeature(
        ctxt: xmlParserCtxtPtr,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlCreatePushParserCtxt(
        sax: xmlSAXHandlerPtr,
        user_data: *mut ::std::os::raw::c_void,
        chunk: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
    ) -> xmlParserCtxtPtr;
}
extern "C" {
    pub fn xmlParseChunk(
        ctxt: xmlParserCtxtPtr,
        chunk: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        terminate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlCreateIOParserCtxt(
        sax: xmlSAXHandlerPtr,
        user_data: *mut ::std::os::raw::c_void,
        ioread: xmlInputReadCallback,
        ioclose: xmlInputCloseCallback,
        ioctx: *mut ::std::os::raw::c_void,
        enc: xmlCharEncoding,
    ) -> xmlParserCtxtPtr;
}
extern "C" {
    pub fn xmlNewIOInputStream(
        ctxt: xmlParserCtxtPtr,
        input: xmlParserInputBufferPtr,
        enc: xmlCharEncoding,
    ) -> xmlParserInputPtr;
}
extern "C" {
    pub fn xmlParserFindNodeInfo(
        ctxt: xmlParserCtxtPtr,
        node: xmlNodePtr,
    ) -> *const xmlParserNodeInfo;
}
extern "C" {
    pub fn xmlInitNodeInfoSeq(seq: xmlParserNodeInfoSeqPtr);
}
extern "C" {
    pub fn xmlClearNodeInfoSeq(seq: xmlParserNodeInfoSeqPtr);
}
extern "C" {
    pub fn xmlParserFindNodeInfoIndex(
        seq: xmlParserNodeInfoSeqPtr,
        node: xmlNodePtr,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn xmlParserAddNodeInfo(ctxt: xmlParserCtxtPtr, info: xmlParserNodeInfoPtr);
}
extern "C" {
    pub fn xmlSetExternalEntityLoader(f: xmlExternalEntityLoader);
}
extern "C" {
    pub fn xmlGetExternalEntityLoader() -> xmlExternalEntityLoader;
}
extern "C" {
    pub fn xmlLoadExternalEntity(
        URL: *const ::std::os::raw::c_char,
        ID: *const ::std::os::raw::c_char,
        ctxt: xmlParserCtxtPtr,
    ) -> xmlParserInputPtr;
}
extern "C" {
    pub fn xmlByteConsumed(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_long;
}
pub const xmlParserOption_XML_PARSE_RECOVER: xmlParserOption = 1;
pub const xmlParserOption_XML_PARSE_NOENT: xmlParserOption = 2;
pub const xmlParserOption_XML_PARSE_DTDLOAD: xmlParserOption = 4;
pub const xmlParserOption_XML_PARSE_DTDATTR: xmlParserOption = 8;
pub const xmlParserOption_XML_PARSE_DTDVALID: xmlParserOption = 16;
pub const xmlParserOption_XML_PARSE_NOERROR: xmlParserOption = 32;
pub const xmlParserOption_XML_PARSE_NOWARNING: xmlParserOption = 64;
pub const xmlParserOption_XML_PARSE_PEDANTIC: xmlParserOption = 128;
pub const xmlParserOption_XML_PARSE_NOBLANKS: xmlParserOption = 256;
pub const xmlParserOption_XML_PARSE_SAX1: xmlParserOption = 512;
pub const xmlParserOption_XML_PARSE_XINCLUDE: xmlParserOption = 1024;
pub const xmlParserOption_XML_PARSE_NONET: xmlParserOption = 2048;
pub const xmlParserOption_XML_PARSE_NODICT: xmlParserOption = 4096;
pub const xmlParserOption_XML_PARSE_NSCLEAN: xmlParserOption = 8192;
pub const xmlParserOption_XML_PARSE_NOCDATA: xmlParserOption = 16384;
pub const xmlParserOption_XML_PARSE_NOXINCNODE: xmlParserOption = 32768;
pub const xmlParserOption_XML_PARSE_COMPACT: xmlParserOption = 65536;
pub const xmlParserOption_XML_PARSE_OLD10: xmlParserOption = 131072;
pub const xmlParserOption_XML_PARSE_NOBASEFIX: xmlParserOption = 262144;
pub const xmlParserOption_XML_PARSE_HUGE: xmlParserOption = 524288;
pub const xmlParserOption_XML_PARSE_OLDSAX: xmlParserOption = 1048576;
pub const xmlParserOption_XML_PARSE_IGNORE_ENC: xmlParserOption = 2097152;
pub const xmlParserOption_XML_PARSE_BIG_LINES: xmlParserOption = 4194304;
#[doc = " xmlParserOption:"]
#[doc = ""]
#[doc = " This is the set of XML parser options that can be passed down"]
#[doc = " to the xmlReadDoc() and similar calls."]
pub type xmlParserOption = ::std::os::raw::c_int;
extern "C" {
    pub fn xmlCtxtReset(ctxt: xmlParserCtxtPtr);
}
extern "C" {
    pub fn xmlCtxtResetPush(
        ctxt: xmlParserCtxtPtr,
        chunk: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        encoding: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlCtxtUseOptions(
        ctxt: xmlParserCtxtPtr,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlReadDoc(
        cur: *const xmlChar,
        URL: *const ::std::os::raw::c_char,
        encoding: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlReadFile(
        URL: *const ::std::os::raw::c_char,
        encoding: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlReadMemory(
        buffer: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        URL: *const ::std::os::raw::c_char,
        encoding: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlReadFd(
        fd: ::std::os::raw::c_int,
        URL: *const ::std::os::raw::c_char,
        encoding: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlReadIO(
        ioread: xmlInputReadCallback,
        ioclose: xmlInputCloseCallback,
        ioctx: *mut ::std::os::raw::c_void,
        URL: *const ::std::os::raw::c_char,
        encoding: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlCtxtReadDoc(
        ctxt: xmlParserCtxtPtr,
        cur: *const xmlChar,
        URL: *const ::std::os::raw::c_char,
        encoding: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlCtxtReadFile(
        ctxt: xmlParserCtxtPtr,
        filename: *const ::std::os::raw::c_char,
        encoding: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlCtxtReadMemory(
        ctxt: xmlParserCtxtPtr,
        buffer: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        URL: *const ::std::os::raw::c_char,
        encoding: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlCtxtReadFd(
        ctxt: xmlParserCtxtPtr,
        fd: ::std::os::raw::c_int,
        URL: *const ::std::os::raw::c_char,
        encoding: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlCtxtReadIO(
        ctxt: xmlParserCtxtPtr,
        ioread: xmlInputReadCallback,
        ioclose: xmlInputCloseCallback,
        ioctx: *mut ::std::os::raw::c_void,
        URL: *const ::std::os::raw::c_char,
        encoding: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
    ) -> xmlDocPtr;
}
pub const xmlFeature_XML_WITH_THREAD: xmlFeature = 1;
pub const xmlFeature_XML_WITH_TREE: xmlFeature = 2;
pub const xmlFeature_XML_WITH_OUTPUT: xmlFeature = 3;
pub const xmlFeature_XML_WITH_PUSH: xmlFeature = 4;
pub const xmlFeature_XML_WITH_READER: xmlFeature = 5;
pub const xmlFeature_XML_WITH_PATTERN: xmlFeature = 6;
pub const xmlFeature_XML_WITH_WRITER: xmlFeature = 7;
pub const xmlFeature_XML_WITH_SAX1: xmlFeature = 8;
pub const xmlFeature_XML_WITH_FTP: xmlFeature = 9;
pub const xmlFeature_XML_WITH_HTTP: xmlFeature = 10;
pub const xmlFeature_XML_WITH_VALID: xmlFeature = 11;
pub const xmlFeature_XML_WITH_HTML: xmlFeature = 12;
pub const xmlFeature_XML_WITH_LEGACY: xmlFeature = 13;
pub const xmlFeature_XML_WITH_C14N: xmlFeature = 14;
pub const xmlFeature_XML_WITH_CATALOG: xmlFeature = 15;
pub const xmlFeature_XML_WITH_XPATH: xmlFeature = 16;
pub const xmlFeature_XML_WITH_XPTR: xmlFeature = 17;
pub const xmlFeature_XML_WITH_XINCLUDE: xmlFeature = 18;
pub const xmlFeature_XML_WITH_ICONV: xmlFeature = 19;
pub const xmlFeature_XML_WITH_ISO8859X: xmlFeature = 20;
pub const xmlFeature_XML_WITH_UNICODE: xmlFeature = 21;
pub const xmlFeature_XML_WITH_REGEXP: xmlFeature = 22;
pub const xmlFeature_XML_WITH_AUTOMATA: xmlFeature = 23;
pub const xmlFeature_XML_WITH_EXPR: xmlFeature = 24;
pub const xmlFeature_XML_WITH_SCHEMAS: xmlFeature = 25;
pub const xmlFeature_XML_WITH_SCHEMATRON: xmlFeature = 26;
pub const xmlFeature_XML_WITH_MODULES: xmlFeature = 27;
pub const xmlFeature_XML_WITH_DEBUG: xmlFeature = 28;
pub const xmlFeature_XML_WITH_DEBUG_MEM: xmlFeature = 29;
pub const xmlFeature_XML_WITH_DEBUG_RUN: xmlFeature = 30;
pub const xmlFeature_XML_WITH_ZLIB: xmlFeature = 31;
pub const xmlFeature_XML_WITH_ICU: xmlFeature = 32;
pub const xmlFeature_XML_WITH_LZMA: xmlFeature = 33;
pub const xmlFeature_XML_WITH_NONE: xmlFeature = 99999;
#[doc = " xmlFeature:"]
#[doc = ""]
#[doc = " Used to examine the existence of features that can be enabled"]
#[doc = " or disabled at compile-time."]
#[doc = " They used to be called XML_FEATURE_xxx but this clashed with Expat"]
pub type xmlFeature = ::std::os::raw::c_int;
extern "C" {
    pub fn xmlHasFeature(feature: xmlFeature) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _calloc_base(_Count: size_t, _Size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> size_t;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> size_t;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: size_t,
        _Size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: size_t,
        _Size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: size_t, _Alignment: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: size_t,
        _Alignment: size_t,
        _Offset: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: size_t,
        _Offset: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: size_t,
        _Alignment: size_t,
        _Offset: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: size_t,
        _Size: size_t,
        _Alignment: size_t,
        _Offset: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: size_t,
        _Alignment: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: size_t,
        _Size: size_t,
        _Alignment: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: size_t,
        _SizeOfElements: size_t,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: size_t,
        _SizeOfElements: size_t,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: size_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: size_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_div_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_div_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_ldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_lldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_lldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn abs(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    fn test_field_ld() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LDOUBLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LDOUBLE),
                "::",
                stringify!(ld)
            )
        );
    }
    test_field_ld();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_CRT_DOUBLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_CRT_DOUBLE),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    fn test_field_f() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_CRT_FLOAT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_CRT_FLOAT),
                "::",
                stringify!(f)
            )
        );
    }
    test_field_f();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LONGDOUBLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LONGDOUBLE),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    fn test_field_ld12() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LDBL12>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LDBL12),
                "::",
                stringify!(ld12)
            )
        );
    }
    test_field_ld12();
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> size_t;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: size_t) -> size_t;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut size_t,
        _DstBuf: *mut wchar_t,
        _SizeInWords: size_t,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut size_t,
        _DstBuf: *mut wchar_t,
        _SizeInWords: size_t,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut size_t,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: size_t,
        _Src: *const wchar_t,
        _MaxCountInBytes: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut size_t,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: size_t,
        _Src: *const wchar_t,
        _MaxCountInBytes: size_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: size_t,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: size_t,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: size_t,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut size_t,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut size_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
#[doc = " Various defines for the various Link properties."]
#[doc = ""]
#[doc = " NOTE: the link detection layer will try to resolve QName expansion"]
#[doc = "       of namespaces. If \"foo\" is the prefix for \"http://foo.com/\""]
#[doc = "       then the link detection layer will expand role=\"foo:myrole\""]
#[doc = "       to \"http://foo.com/:myrole\"."]
#[doc = " NOTE: the link detection layer will expand URI-References found on"]
#[doc = "       href attributes by using the base mechanism if found."]
pub type xlinkHRef = *mut xmlChar;
pub type xlinkRole = *mut xmlChar;
pub type xlinkTitle = *mut xmlChar;
pub const xlinkType_XLINK_TYPE_NONE: xlinkType = 0;
pub const xlinkType_XLINK_TYPE_SIMPLE: xlinkType = 1;
pub const xlinkType_XLINK_TYPE_EXTENDED: xlinkType = 2;
pub const xlinkType_XLINK_TYPE_EXTENDED_SET: xlinkType = 3;
pub type xlinkType = ::std::os::raw::c_int;
pub const xlinkShow_XLINK_SHOW_NONE: xlinkShow = 0;
pub const xlinkShow_XLINK_SHOW_NEW: xlinkShow = 1;
pub const xlinkShow_XLINK_SHOW_EMBED: xlinkShow = 2;
pub const xlinkShow_XLINK_SHOW_REPLACE: xlinkShow = 3;
pub type xlinkShow = ::std::os::raw::c_int;
pub const xlinkActuate_XLINK_ACTUATE_NONE: xlinkActuate = 0;
pub const xlinkActuate_XLINK_ACTUATE_AUTO: xlinkActuate = 1;
pub const xlinkActuate_XLINK_ACTUATE_ONREQUEST: xlinkActuate = 2;
pub type xlinkActuate = ::std::os::raw::c_int;
#[doc = " xlinkNodeDetectFunc:"]
#[doc = " @ctx:  user data pointer"]
#[doc = " @node:  the node to check"]
#[doc = ""]
#[doc = " This is the prototype for the link detection routine."]
#[doc = " It calls the default link detection callbacks upon link detection."]
pub type xlinkNodeDetectFunc =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, node: xmlNodePtr)>;
#[doc = " xlinkSimpleLinkFunk:"]
#[doc = " @ctx:  user data pointer"]
#[doc = " @node:  the node carrying the link"]
#[doc = " @href:  the target of the link"]
#[doc = " @role:  the role string"]
#[doc = " @title:  the link title"]
#[doc = ""]
#[doc = " This is the prototype for a simple link detection callback."]
pub type xlinkSimpleLinkFunk = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        node: xmlNodePtr,
        href: xlinkHRef,
        role: xlinkRole,
        title: xlinkTitle,
    ),
>;
#[doc = " xlinkExtendedLinkFunk:"]
#[doc = " @ctx:  user data pointer"]
#[doc = " @node:  the node carrying the link"]
#[doc = " @nbLocators: the number of locators detected on the link"]
#[doc = " @hrefs:  pointer to the array of locator hrefs"]
#[doc = " @roles:  pointer to the array of locator roles"]
#[doc = " @nbArcs: the number of arcs detected on the link"]
#[doc = " @from:  pointer to the array of source roles found on the arcs"]
#[doc = " @to:  pointer to the array of target roles found on the arcs"]
#[doc = " @show:  array of values for the show attributes found on the arcs"]
#[doc = " @actuate:  array of values for the actuate attributes found on the arcs"]
#[doc = " @nbTitles: the number of titles detected on the link"]
#[doc = " @title:  array of titles detected on the link"]
#[doc = " @langs:  array of xml:lang values for the titles"]
#[doc = ""]
#[doc = " This is the prototype for a extended link detection callback."]
pub type xlinkExtendedLinkFunk = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        node: xmlNodePtr,
        nbLocators: ::std::os::raw::c_int,
        hrefs: *const xlinkHRef,
        roles: *const xlinkRole,
        nbArcs: ::std::os::raw::c_int,
        from: *const xlinkRole,
        to: *const xlinkRole,
        show: *mut xlinkShow,
        actuate: *mut xlinkActuate,
        nbTitles: ::std::os::raw::c_int,
        titles: *const xlinkTitle,
        langs: *mut *const xmlChar,
    ),
>;
#[doc = " xlinkExtendedLinkSetFunk:"]
#[doc = " @ctx:  user data pointer"]
#[doc = " @node:  the node carrying the link"]
#[doc = " @nbLocators: the number of locators detected on the link"]
#[doc = " @hrefs:  pointer to the array of locator hrefs"]
#[doc = " @roles:  pointer to the array of locator roles"]
#[doc = " @nbTitles: the number of titles detected on the link"]
#[doc = " @title:  array of titles detected on the link"]
#[doc = " @langs:  array of xml:lang values for the titles"]
#[doc = ""]
#[doc = " This is the prototype for a extended link set detection callback."]
pub type xlinkExtendedLinkSetFunk = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        node: xmlNodePtr,
        nbLocators: ::std::os::raw::c_int,
        hrefs: *const xlinkHRef,
        roles: *const xlinkRole,
        nbTitles: ::std::os::raw::c_int,
        titles: *const xlinkTitle,
        langs: *mut *const xmlChar,
    ),
>;
#[doc = " This is the structure containing a set of Links detection callbacks."]
#[doc = ""]
#[doc = " There is no default xlink callbacks, if one want to get link"]
#[doc = " recognition activated, those call backs must be provided before parsing."]
pub type xlinkHandler = _xlinkHandler;
pub type xlinkHandlerPtr = *mut xlinkHandler;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xlinkHandler {
    pub simple: xlinkSimpleLinkFunk,
    pub extended: xlinkExtendedLinkFunk,
    pub set: xlinkExtendedLinkSetFunk,
}
#[test]
fn bindgen_test_layout__xlinkHandler() {
    assert_eq!(
        ::std::mem::size_of::<_xlinkHandler>(),
        24usize,
        concat!("Size of: ", stringify!(_xlinkHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<_xlinkHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(_xlinkHandler))
    );
    fn test_field_simple() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xlinkHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).simple) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xlinkHandler),
                "::",
                stringify!(simple)
            )
        );
    }
    test_field_simple();
    fn test_field_extended() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xlinkHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extended) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xlinkHandler),
                "::",
                stringify!(extended)
            )
        );
    }
    test_field_extended();
    fn test_field_set() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xlinkHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xlinkHandler),
                "::",
                stringify!(set)
            )
        );
    }
    test_field_set();
}
extern "C" {
    pub fn xlinkGetDefaultDetect() -> xlinkNodeDetectFunc;
}
extern "C" {
    pub fn xlinkSetDefaultDetect(func: xlinkNodeDetectFunc);
}
extern "C" {
    pub fn xlinkGetDefaultHandler() -> xlinkHandlerPtr;
}
extern "C" {
    pub fn xlinkSetDefaultHandler(handler: xlinkHandlerPtr);
}
extern "C" {
    pub fn xlinkIsLink(doc: xmlDocPtr, node: xmlNodePtr) -> xlinkType;
}
extern "C" {
    pub fn xmlSAX2GetPublicId(ctx: *mut ::std::os::raw::c_void) -> *const xmlChar;
}
extern "C" {
    pub fn xmlSAX2GetSystemId(ctx: *mut ::std::os::raw::c_void) -> *const xmlChar;
}
extern "C" {
    pub fn xmlSAX2SetDocumentLocator(ctx: *mut ::std::os::raw::c_void, loc: xmlSAXLocatorPtr);
}
extern "C" {
    pub fn xmlSAX2GetLineNumber(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSAX2GetColumnNumber(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSAX2IsStandalone(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSAX2HasInternalSubset(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSAX2HasExternalSubset(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSAX2InternalSubset(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
    );
}
extern "C" {
    pub fn xmlSAX2ExternalSubset(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
    );
}
extern "C" {
    pub fn xmlSAX2GetEntity(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar)
        -> xmlEntityPtr;
}
extern "C" {
    pub fn xmlSAX2GetParameterEntity(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
    ) -> xmlEntityPtr;
}
extern "C" {
    pub fn xmlSAX2ResolveEntity(
        ctx: *mut ::std::os::raw::c_void,
        publicId: *const xmlChar,
        systemId: *const xmlChar,
    ) -> xmlParserInputPtr;
}
extern "C" {
    pub fn xmlSAX2EntityDecl(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        type_: ::std::os::raw::c_int,
        publicId: *const xmlChar,
        systemId: *const xmlChar,
        content: *mut xmlChar,
    );
}
extern "C" {
    pub fn xmlSAX2AttributeDecl(
        ctx: *mut ::std::os::raw::c_void,
        elem: *const xmlChar,
        fullname: *const xmlChar,
        type_: ::std::os::raw::c_int,
        def: ::std::os::raw::c_int,
        defaultValue: *const xmlChar,
        tree: xmlEnumerationPtr,
    );
}
extern "C" {
    pub fn xmlSAX2ElementDecl(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        type_: ::std::os::raw::c_int,
        content: xmlElementContentPtr,
    );
}
extern "C" {
    pub fn xmlSAX2NotationDecl(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        publicId: *const xmlChar,
        systemId: *const xmlChar,
    );
}
extern "C" {
    pub fn xmlSAX2UnparsedEntityDecl(
        ctx: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        publicId: *const xmlChar,
        systemId: *const xmlChar,
        notationName: *const xmlChar,
    );
}
extern "C" {
    pub fn xmlSAX2StartDocument(ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn xmlSAX2EndDocument(ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn xmlSAX2StartElement(
        ctx: *mut ::std::os::raw::c_void,
        fullname: *const xmlChar,
        atts: *mut *const xmlChar,
    );
}
extern "C" {
    pub fn xmlSAX2EndElement(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar);
}
extern "C" {
    pub fn xmlSAX2StartElementNs(
        ctx: *mut ::std::os::raw::c_void,
        localname: *const xmlChar,
        prefix: *const xmlChar,
        URI: *const xmlChar,
        nb_namespaces: ::std::os::raw::c_int,
        namespaces: *mut *const xmlChar,
        nb_attributes: ::std::os::raw::c_int,
        nb_defaulted: ::std::os::raw::c_int,
        attributes: *mut *const xmlChar,
    );
}
extern "C" {
    pub fn xmlSAX2EndElementNs(
        ctx: *mut ::std::os::raw::c_void,
        localname: *const xmlChar,
        prefix: *const xmlChar,
        URI: *const xmlChar,
    );
}
extern "C" {
    pub fn xmlSAX2Reference(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar);
}
extern "C" {
    pub fn xmlSAX2Characters(
        ctx: *mut ::std::os::raw::c_void,
        ch: *const xmlChar,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn xmlSAX2IgnorableWhitespace(
        ctx: *mut ::std::os::raw::c_void,
        ch: *const xmlChar,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn xmlSAX2ProcessingInstruction(
        ctx: *mut ::std::os::raw::c_void,
        target: *const xmlChar,
        data: *const xmlChar,
    );
}
extern "C" {
    pub fn xmlSAX2Comment(ctx: *mut ::std::os::raw::c_void, value: *const xmlChar);
}
extern "C" {
    pub fn xmlSAX2CDataBlock(
        ctx: *mut ::std::os::raw::c_void,
        value: *const xmlChar,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn xmlSAXDefaultVersion(version: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSAXVersion(
        hdlr: *mut xmlSAXHandler,
        version: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSAX2InitDefaultSAXHandler(hdlr: *mut xmlSAXHandler, warning: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xmlSAX2InitHtmlDefaultSAXHandler(hdlr: *mut xmlSAXHandler);
}
extern "C" {
    pub fn htmlDefaultSAXHandlerInit();
}
extern "C" {
    pub fn xmlSAX2InitDocbDefaultSAXHandler(hdlr: *mut xmlSAXHandler);
}
extern "C" {
    pub fn docbDefaultSAXHandlerInit();
}
extern "C" {
    pub fn xmlDefaultSAXHandlerInit();
}
extern "C" {
    pub fn xmlInitGlobals();
}
extern "C" {
    pub fn xmlCleanupGlobals();
}
#[doc = " xmlParserInputBufferCreateFilenameFunc:"]
#[doc = " @URI: the URI to read from"]
#[doc = " @enc: the requested source encoding"]
#[doc = ""]
#[doc = " Signature for the function doing the lookup for a suitable input method"]
#[doc = " corresponding to an URI."]
#[doc = ""]
#[doc = " Returns the new xmlParserInputBufferPtr in case of success or NULL if no"]
#[doc = "         method was found."]
pub type xmlParserInputBufferCreateFilenameFunc = ::std::option::Option<
    unsafe extern "C" fn(
        URI: *const ::std::os::raw::c_char,
        enc: xmlCharEncoding,
    ) -> xmlParserInputBufferPtr,
>;
#[doc = " xmlOutputBufferCreateFilenameFunc:"]
#[doc = " @URI: the URI to write to"]
#[doc = " @enc: the requested target encoding"]
#[doc = ""]
#[doc = " Signature for the function doing the lookup for a suitable output method"]
#[doc = " corresponding to an URI."]
#[doc = ""]
#[doc = " Returns the new xmlOutputBufferPtr in case of success or NULL if no"]
#[doc = "         method was found."]
pub type xmlOutputBufferCreateFilenameFunc = ::std::option::Option<
    unsafe extern "C" fn(
        URI: *const ::std::os::raw::c_char,
        encoder: xmlCharEncodingHandlerPtr,
        compression: ::std::os::raw::c_int,
    ) -> xmlOutputBufferPtr,
>;
extern "C" {
    pub fn xmlParserInputBufferCreateFilenameDefault(
        func: xmlParserInputBufferCreateFilenameFunc,
    ) -> xmlParserInputBufferCreateFilenameFunc;
}
extern "C" {
    pub fn xmlOutputBufferCreateFilenameDefault(
        func: xmlOutputBufferCreateFilenameFunc,
    ) -> xmlOutputBufferCreateFilenameFunc;
}
#[doc = " xmlRegisterNodeFunc:"]
#[doc = " @node: the current node"]
#[doc = ""]
#[doc = " Signature for the registration callback of a created node"]
pub type xmlRegisterNodeFunc = ::std::option::Option<unsafe extern "C" fn(node: xmlNodePtr)>;
#[doc = " xmlDeregisterNodeFunc:"]
#[doc = " @node: the current node"]
#[doc = ""]
#[doc = " Signature for the deregistration callback of a discarded node"]
pub type xmlDeregisterNodeFunc = ::std::option::Option<unsafe extern "C" fn(node: xmlNodePtr)>;
pub type xmlGlobalState = _xmlGlobalState;
pub type xmlGlobalStatePtr = *mut xmlGlobalState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlGlobalState {
    pub xmlParserVersion: *const ::std::os::raw::c_char,
    pub xmlDefaultSAXLocator: xmlSAXLocator,
    pub xmlDefaultSAXHandler: xmlSAXHandlerV1,
    pub docbDefaultSAXHandler: xmlSAXHandlerV1,
    pub htmlDefaultSAXHandler: xmlSAXHandlerV1,
    pub xmlFree: xmlFreeFunc,
    pub xmlMalloc: xmlMallocFunc,
    pub xmlMemStrdup: xmlStrdupFunc,
    pub xmlRealloc: xmlReallocFunc,
    pub xmlGenericError: xmlGenericErrorFunc,
    pub xmlStructuredError: xmlStructuredErrorFunc,
    pub xmlGenericErrorContext: *mut ::std::os::raw::c_void,
    pub oldXMLWDcompatibility: ::std::os::raw::c_int,
    pub xmlBufferAllocScheme: xmlBufferAllocationScheme,
    pub xmlDefaultBufferSize: ::std::os::raw::c_int,
    pub xmlSubstituteEntitiesDefaultValue: ::std::os::raw::c_int,
    pub xmlDoValidityCheckingDefaultValue: ::std::os::raw::c_int,
    pub xmlGetWarningsDefaultValue: ::std::os::raw::c_int,
    pub xmlKeepBlanksDefaultValue: ::std::os::raw::c_int,
    pub xmlLineNumbersDefaultValue: ::std::os::raw::c_int,
    pub xmlLoadExtDtdDefaultValue: ::std::os::raw::c_int,
    pub xmlParserDebugEntities: ::std::os::raw::c_int,
    pub xmlPedanticParserDefaultValue: ::std::os::raw::c_int,
    pub xmlSaveNoEmptyTags: ::std::os::raw::c_int,
    pub xmlIndentTreeOutput: ::std::os::raw::c_int,
    pub xmlTreeIndentString: *const ::std::os::raw::c_char,
    pub xmlRegisterNodeDefaultValue: xmlRegisterNodeFunc,
    pub xmlDeregisterNodeDefaultValue: xmlDeregisterNodeFunc,
    pub xmlMallocAtomic: xmlMallocFunc,
    pub xmlLastError: xmlError,
    pub xmlParserInputBufferCreateFilenameValue: xmlParserInputBufferCreateFilenameFunc,
    pub xmlOutputBufferCreateFilenameValue: xmlOutputBufferCreateFilenameFunc,
    pub xmlStructuredErrorContext: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlGlobalState() {
    assert_eq!(
        ::std::mem::size_of::<_xmlGlobalState>(),
        968usize,
        concat!("Size of: ", stringify!(_xmlGlobalState))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlGlobalState>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlGlobalState))
    );
    fn test_field_xmlParserVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlParserVersion) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlParserVersion)
            )
        );
    }
    test_field_xmlParserVersion();
    fn test_field_xmlDefaultSAXLocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlDefaultSAXLocator) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlDefaultSAXLocator)
            )
        );
    }
    test_field_xmlDefaultSAXLocator();
    fn test_field_xmlDefaultSAXHandler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlDefaultSAXHandler) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlDefaultSAXHandler)
            )
        );
    }
    test_field_xmlDefaultSAXHandler();
    fn test_field_docbDefaultSAXHandler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).docbDefaultSAXHandler) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(docbDefaultSAXHandler)
            )
        );
    }
    test_field_docbDefaultSAXHandler();
    fn test_field_htmlDefaultSAXHandler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).htmlDefaultSAXHandler) as usize - ptr as usize
            },
            488usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(htmlDefaultSAXHandler)
            )
        );
    }
    test_field_htmlDefaultSAXHandler();
    fn test_field_xmlFree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlFree) as usize - ptr as usize
            },
            712usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlFree)
            )
        );
    }
    test_field_xmlFree();
    fn test_field_xmlMalloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlMalloc) as usize - ptr as usize
            },
            720usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlMalloc)
            )
        );
    }
    test_field_xmlMalloc();
    fn test_field_xmlMemStrdup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlMemStrdup) as usize - ptr as usize
            },
            728usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlMemStrdup)
            )
        );
    }
    test_field_xmlMemStrdup();
    fn test_field_xmlRealloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlRealloc) as usize - ptr as usize
            },
            736usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlRealloc)
            )
        );
    }
    test_field_xmlRealloc();
    fn test_field_xmlGenericError() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlGenericError) as usize - ptr as usize
            },
            744usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlGenericError)
            )
        );
    }
    test_field_xmlGenericError();
    fn test_field_xmlStructuredError() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlStructuredError) as usize - ptr as usize
            },
            752usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlStructuredError)
            )
        );
    }
    test_field_xmlStructuredError();
    fn test_field_xmlGenericErrorContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlGenericErrorContext) as usize - ptr as usize
            },
            760usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlGenericErrorContext)
            )
        );
    }
    test_field_xmlGenericErrorContext();
    fn test_field_oldXMLWDcompatibility() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).oldXMLWDcompatibility) as usize - ptr as usize
            },
            768usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(oldXMLWDcompatibility)
            )
        );
    }
    test_field_oldXMLWDcompatibility();
    fn test_field_xmlBufferAllocScheme() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlBufferAllocScheme) as usize - ptr as usize
            },
            772usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlBufferAllocScheme)
            )
        );
    }
    test_field_xmlBufferAllocScheme();
    fn test_field_xmlDefaultBufferSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlDefaultBufferSize) as usize - ptr as usize
            },
            776usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlDefaultBufferSize)
            )
        );
    }
    test_field_xmlDefaultBufferSize();
    fn test_field_xmlSubstituteEntitiesDefaultValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlSubstituteEntitiesDefaultValue) as usize
                    - ptr as usize
            },
            780usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlSubstituteEntitiesDefaultValue)
            )
        );
    }
    test_field_xmlSubstituteEntitiesDefaultValue();
    fn test_field_xmlDoValidityCheckingDefaultValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlDoValidityCheckingDefaultValue) as usize
                    - ptr as usize
            },
            784usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlDoValidityCheckingDefaultValue)
            )
        );
    }
    test_field_xmlDoValidityCheckingDefaultValue();
    fn test_field_xmlGetWarningsDefaultValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlGetWarningsDefaultValue) as usize - ptr as usize
            },
            788usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlGetWarningsDefaultValue)
            )
        );
    }
    test_field_xmlGetWarningsDefaultValue();
    fn test_field_xmlKeepBlanksDefaultValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlKeepBlanksDefaultValue) as usize - ptr as usize
            },
            792usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlKeepBlanksDefaultValue)
            )
        );
    }
    test_field_xmlKeepBlanksDefaultValue();
    fn test_field_xmlLineNumbersDefaultValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlLineNumbersDefaultValue) as usize - ptr as usize
            },
            796usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlLineNumbersDefaultValue)
            )
        );
    }
    test_field_xmlLineNumbersDefaultValue();
    fn test_field_xmlLoadExtDtdDefaultValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlLoadExtDtdDefaultValue) as usize - ptr as usize
            },
            800usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlLoadExtDtdDefaultValue)
            )
        );
    }
    test_field_xmlLoadExtDtdDefaultValue();
    fn test_field_xmlParserDebugEntities() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlParserDebugEntities) as usize - ptr as usize
            },
            804usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlParserDebugEntities)
            )
        );
    }
    test_field_xmlParserDebugEntities();
    fn test_field_xmlPedanticParserDefaultValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlPedanticParserDefaultValue) as usize - ptr as usize
            },
            808usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlPedanticParserDefaultValue)
            )
        );
    }
    test_field_xmlPedanticParserDefaultValue();
    fn test_field_xmlSaveNoEmptyTags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlSaveNoEmptyTags) as usize - ptr as usize
            },
            812usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlSaveNoEmptyTags)
            )
        );
    }
    test_field_xmlSaveNoEmptyTags();
    fn test_field_xmlIndentTreeOutput() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlIndentTreeOutput) as usize - ptr as usize
            },
            816usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlIndentTreeOutput)
            )
        );
    }
    test_field_xmlIndentTreeOutput();
    fn test_field_xmlTreeIndentString() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlTreeIndentString) as usize - ptr as usize
            },
            824usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlTreeIndentString)
            )
        );
    }
    test_field_xmlTreeIndentString();
    fn test_field_xmlRegisterNodeDefaultValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlRegisterNodeDefaultValue) as usize - ptr as usize
            },
            832usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlRegisterNodeDefaultValue)
            )
        );
    }
    test_field_xmlRegisterNodeDefaultValue();
    fn test_field_xmlDeregisterNodeDefaultValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlDeregisterNodeDefaultValue) as usize - ptr as usize
            },
            840usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlDeregisterNodeDefaultValue)
            )
        );
    }
    test_field_xmlDeregisterNodeDefaultValue();
    fn test_field_xmlMallocAtomic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlMallocAtomic) as usize - ptr as usize
            },
            848usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlMallocAtomic)
            )
        );
    }
    test_field_xmlMallocAtomic();
    fn test_field_xmlLastError() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlLastError) as usize - ptr as usize
            },
            856usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlLastError)
            )
        );
    }
    test_field_xmlLastError();
    fn test_field_xmlParserInputBufferCreateFilenameValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlParserInputBufferCreateFilenameValue) as usize
                    - ptr as usize
            },
            944usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlParserInputBufferCreateFilenameValue)
            )
        );
    }
    test_field_xmlParserInputBufferCreateFilenameValue();
    fn test_field_xmlOutputBufferCreateFilenameValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlOutputBufferCreateFilenameValue) as usize
                    - ptr as usize
            },
            952usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlOutputBufferCreateFilenameValue)
            )
        );
    }
    test_field_xmlOutputBufferCreateFilenameValue();
    fn test_field_xmlStructuredErrorContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlGlobalState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlStructuredErrorContext) as usize - ptr as usize
            },
            960usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlGlobalState),
                "::",
                stringify!(xmlStructuredErrorContext)
            )
        );
    }
    test_field_xmlStructuredErrorContext();
}
extern "C" {
    pub fn xmlInitializeGlobalState(gs: xmlGlobalStatePtr);
}
extern "C" {
    pub fn xmlThrDefSetGenericErrorFunc(
        ctx: *mut ::std::os::raw::c_void,
        handler: xmlGenericErrorFunc,
    );
}
extern "C" {
    pub fn xmlThrDefSetStructuredErrorFunc(
        ctx: *mut ::std::os::raw::c_void,
        handler: xmlStructuredErrorFunc,
    );
}
extern "C" {
    pub fn xmlRegisterNodeDefault(func: xmlRegisterNodeFunc) -> xmlRegisterNodeFunc;
}
extern "C" {
    pub fn xmlThrDefRegisterNodeDefault(func: xmlRegisterNodeFunc) -> xmlRegisterNodeFunc;
}
extern "C" {
    pub fn xmlDeregisterNodeDefault(func: xmlDeregisterNodeFunc) -> xmlDeregisterNodeFunc;
}
extern "C" {
    pub fn xmlThrDefDeregisterNodeDefault(func: xmlDeregisterNodeFunc) -> xmlDeregisterNodeFunc;
}
extern "C" {
    pub fn xmlThrDefOutputBufferCreateFilenameDefault(
        func: xmlOutputBufferCreateFilenameFunc,
    ) -> xmlOutputBufferCreateFilenameFunc;
}
extern "C" {
    pub fn xmlThrDefParserInputBufferCreateFilenameDefault(
        func: xmlParserInputBufferCreateFilenameFunc,
    ) -> xmlParserInputBufferCreateFilenameFunc;
}
extern "C" {
    pub static mut xmlMalloc: xmlMallocFunc;
}
extern "C" {
    pub static mut xmlMallocAtomic: xmlMallocFunc;
}
extern "C" {
    pub static mut xmlRealloc: xmlReallocFunc;
}
extern "C" {
    pub static mut xmlFree: xmlFreeFunc;
}
extern "C" {
    pub static mut xmlMemStrdup: xmlStrdupFunc;
}
extern "C" {
    pub fn __docbDefaultSAXHandler() -> *mut xmlSAXHandlerV1;
}
extern "C" {
    pub fn __htmlDefaultSAXHandler() -> *mut xmlSAXHandlerV1;
}
extern "C" {
    pub fn __xmlLastError() -> *mut xmlError;
}
extern "C" {
    pub fn __oldXMLWDcompatibility() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmlBufferAllocScheme() -> *mut xmlBufferAllocationScheme;
}
extern "C" {
    pub fn xmlThrDefBufferAllocScheme(v: xmlBufferAllocationScheme) -> xmlBufferAllocationScheme;
}
extern "C" {
    pub fn __xmlDefaultBufferSize() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlThrDefDefaultBufferSize(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmlDefaultSAXHandler() -> *mut xmlSAXHandlerV1;
}
extern "C" {
    pub fn __xmlDefaultSAXLocator() -> *mut xmlSAXLocator;
}
extern "C" {
    pub fn __xmlDoValidityCheckingDefaultValue() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlThrDefDoValidityCheckingDefaultValue(
        v: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmlGenericError() -> *mut xmlGenericErrorFunc;
}
extern "C" {
    pub fn __xmlStructuredError() -> *mut xmlStructuredErrorFunc;
}
extern "C" {
    pub fn __xmlGenericErrorContext() -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __xmlStructuredErrorContext() -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __xmlGetWarningsDefaultValue() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlThrDefGetWarningsDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmlIndentTreeOutput() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlThrDefIndentTreeOutput(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmlTreeIndentString() -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn xmlThrDefTreeIndentString(
        v: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn __xmlKeepBlanksDefaultValue() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlThrDefKeepBlanksDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmlLineNumbersDefaultValue() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlThrDefLineNumbersDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmlLoadExtDtdDefaultValue() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlThrDefLoadExtDtdDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmlParserDebugEntities() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlThrDefParserDebugEntities(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmlParserVersion() -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn __xmlPedanticParserDefaultValue() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlThrDefPedanticParserDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmlSaveNoEmptyTags() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlThrDefSaveNoEmptyTags(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmlSubstituteEntitiesDefaultValue() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlThrDefSubstituteEntitiesDefaultValue(
        v: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmlRegisterNodeDefaultValue() -> *mut xmlRegisterNodeFunc;
}
extern "C" {
    pub fn __xmlDeregisterNodeDefaultValue() -> *mut xmlDeregisterNodeFunc;
}
extern "C" {
    pub fn __xmlParserInputBufferCreateFilenameValue() -> *mut xmlParserInputBufferCreateFilenameFunc;
}
extern "C" {
    pub fn __xmlOutputBufferCreateFilenameValue() -> *mut xmlOutputBufferCreateFilenameFunc;
}
extern "C" {
    pub fn xmlNewMutex() -> xmlMutexPtr;
}
extern "C" {
    pub fn xmlMutexLock(tok: xmlMutexPtr);
}
extern "C" {
    pub fn xmlMutexUnlock(tok: xmlMutexPtr);
}
extern "C" {
    pub fn xmlFreeMutex(tok: xmlMutexPtr);
}
extern "C" {
    pub fn xmlNewRMutex() -> xmlRMutexPtr;
}
extern "C" {
    pub fn xmlRMutexLock(tok: xmlRMutexPtr);
}
extern "C" {
    pub fn xmlRMutexUnlock(tok: xmlRMutexPtr);
}
extern "C" {
    pub fn xmlFreeRMutex(tok: xmlRMutexPtr);
}
extern "C" {
    pub fn xmlInitThreads();
}
extern "C" {
    pub fn xmlLockLibrary();
}
extern "C" {
    pub fn xmlUnlockLibrary();
}
extern "C" {
    pub fn xmlGetThreadId() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlIsMainThread() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlCleanupThreads();
}
extern "C" {
    pub fn xmlGetGlobalState() -> xmlGlobalStatePtr;
}
extern "C" {
    #[doc = " Global Namespaces"]
    #[doc = ""]
    pub static mut xmlSecNs: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecDSigNs: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecEncNs: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecXPathNs: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecXPath2Ns: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecXPointerNs: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecSoap11Ns: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecSoap12Ns: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " DSig Nodes"]
    #[doc = ""]
    pub static mut xmlSecNodeSignature: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeSignedInfo: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeSignatureValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeCanonicalizationMethod: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeSignatureMethod: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeDigestMethod: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeDigestValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeObject: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeManifest: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeSignatureProperties: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " Encryption Nodes"]
    #[doc = ""]
    pub static mut xmlSecNodeEncryptedData: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeEncryptionMethod: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeEncryptionProperties: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeEncryptionProperty: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeCipherData: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeCipherValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeCipherReference: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeReferenceList: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeDataReference: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeKeyReference: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeCarriedKeyName: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecTypeEncContent: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecTypeEncElement: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " KeyInfo and Transform Nodes"]
    #[doc = ""]
    pub static mut xmlSecNodeKeyInfo: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeReference: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeTransforms: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeTransform: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " Attributes"]
    #[doc = ""]
    pub static mut xmlSecAttrId: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecAttrURI: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecAttrType: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecAttrMimeType: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecAttrEncoding: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecAttrAlgorithm: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecAttrTarget: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecAttrFilter: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecAttrRecipient: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " AES strings"]
    #[doc = ""]
    pub static mut xmlSecNameAESKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeAESKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefAESKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameAes128Cbc: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefAes128Cbc: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameAes192Cbc: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefAes192Cbc: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameAes256Cbc: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefAes256Cbc: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameAes128Gcm: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefAes128Gcm: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameAes192Gcm: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefAes192Gcm: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameAes256Gcm: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefAes256Gcm: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameKWAes128: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefKWAes128: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameKWAes192: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefKWAes192: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameKWAes256: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefKWAes256: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " BASE64 strings"]
    #[doc = ""]
    pub static mut xmlSecNameBase64: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefBase64: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " C14N strings"]
    #[doc = ""]
    pub static mut xmlSecNameC14N: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefC14N: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameC14NWithComments: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefC14NWithComments: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameC14N11: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefC14N11: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameC14N11WithComments: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefC14N11WithComments: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameExcC14N: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefExcC14N: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameExcC14NWithComments: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefExcC14NWithComments: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNsExcC14N: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNsExcC14NWithComments: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeInclusiveNamespaces: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecAttrPrefixList: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " DES strings"]
    #[doc = ""]
    pub static mut xmlSecNameDESKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeDESKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefDESKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameDes3Cbc: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefDes3Cbc: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameKWDes3: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefKWDes3: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " DSA strings"]
    #[doc = ""]
    pub static mut xmlSecNameDSAKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeDSAKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefDSAKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeDSAP: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeDSAQ: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeDSAG: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeDSAJ: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeDSAX: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeDSAY: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeDSASeed: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeDSAPgenCounter: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameDsaSha1: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefDsaSha1: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameDsaSha256: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefDsaSha256: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " ECDSA strings"]
    #[doc = ""]
    pub static mut xmlSecNameECDSAKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeECDSAKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefECDSAKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeECDSAP: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeECDSAQ: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeECDSAG: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeECDSAJ: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeECDSAX: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeECDSAY: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeECDSASeed: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeECDSAPgenCounter: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameEcdsaSha1: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefEcdsaSha1: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameEcdsaSha224: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefEcdsaSha224: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameEcdsaSha256: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefEcdsaSha256: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameEcdsaSha384: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefEcdsaSha384: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameEcdsaSha512: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefEcdsaSha512: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " GOST2001 strings"]
    #[doc = ""]
    pub static mut xmlSecNameGOST2001KeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeGOST2001KeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefGOST2001KeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameGost2001GostR3411_94: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefGost2001GostR3411_94: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " GOST R 34.10-2012 strings"]
    #[doc = ""]
    pub static mut xmlSecNameGostR3410_2012_256KeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeGostR3410_2012_256KeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefGostR3410_2012_256KeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameGostR3410_2012_512KeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeGostR3410_2012_512KeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefGostR3410_2012_512KeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameGostR3410_2012GostR3411_2012_256: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefGostR3410_2012GostR3411_2012_256: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameGostR3410_2012GostR3411_2012_512: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefGostR3410_2012GostR3411_2012_512: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " EncryptedKey"]
    #[doc = ""]
    pub static mut xmlSecNameEncryptedKey: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeEncryptedKey: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefEncryptedKey: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " Enveloped transform strings"]
    #[doc = ""]
    pub static mut xmlSecNameEnveloped: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefEnveloped: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " HMAC strings"]
    #[doc = ""]
    pub static mut xmlSecNameHMACKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeHMACKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefHMACKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeHMACOutputLength: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameHmacMd5: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefHmacMd5: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameHmacRipemd160: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefHmacRipemd160: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameHmacSha1: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefHmacSha1: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameHmacSha224: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefHmacSha224: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameHmacSha256: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefHmacSha256: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameHmacSha384: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefHmacSha384: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameHmacSha512: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefHmacSha512: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " KeyName strings"]
    #[doc = ""]
    pub static mut xmlSecNameKeyName: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeKeyName: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " KeyValue strings"]
    #[doc = ""]
    pub static mut xmlSecNameKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeKeyValue: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " Memory Buffer strings"]
    #[doc = ""]
    pub static mut xmlSecNameMemBuf: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " MD5 strings"]
    #[doc = ""]
    pub static mut xmlSecNameMd5: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefMd5: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " RetrievalMethod"]
    #[doc = ""]
    pub static mut xmlSecNameRetrievalMethod: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeRetrievalMethod: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " RIPEMD160 strings"]
    #[doc = ""]
    pub static mut xmlSecNameRipemd160: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefRipemd160: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " RSA strings"]
    #[doc = ""]
    pub static mut xmlSecNameRSAKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeRSAKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefRSAKeyValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeRSAModulus: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeRSAExponent: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeRSAPrivateExponent: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameRsaMd5: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefRsaMd5: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameRsaRipemd160: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefRsaRipemd160: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameRsaSha1: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefRsaSha1: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameRsaSha224: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefRsaSha224: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameRsaSha256: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefRsaSha256: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameRsaSha384: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefRsaSha384: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameRsaSha512: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefRsaSha512: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameRsaPkcs1: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefRsaPkcs1: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameRsaOaep: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefRsaOaep: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeRsaOAEPparams: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " GOSTR3411_94 strings"]
    #[doc = ""]
    pub static mut xmlSecNameGostR3411_94: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefGostR3411_94: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " GOST R 34.11-2012 strings"]
    #[doc = ""]
    pub static mut xmlSecNameGostR3411_2012_256: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefGostR3411_2012_256: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameGostR3411_2012_512: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefGostR3411_2012_512: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " SHA1 strings"]
    #[doc = ""]
    pub static mut xmlSecNameSha1: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefSha1: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameSha224: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefSha224: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameSha256: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefSha256: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameSha384: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefSha384: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameSha512: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefSha512: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " X509 strings"]
    #[doc = ""]
    pub static mut xmlSecNameX509Data: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeX509Data: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefX509Data: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeX509Certificate: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeX509CRL: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeX509SubjectName: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeX509IssuerSerial: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeX509IssuerName: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeX509SerialNumber: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeX509SKI: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameRawX509Cert: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefRawX509Cert: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameX509Store: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " PGP strings"]
    #[doc = ""]
    pub static mut xmlSecNamePGPData: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodePGPData: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefPGPData: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " SPKI strings"]
    #[doc = ""]
    pub static mut xmlSecNameSPKIData: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeSPKIData: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefSPKIData: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " XPath/XPointer strings"]
    #[doc = ""]
    pub static mut xmlSecNameXPath: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeXPath: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameXPath2: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeXPath2: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecXPath2FilterIntersect: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecXPath2FilterSubtract: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecXPath2FilterUnion: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNameXPointer: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeXPointer: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " RelationshipTransform strings"]
    #[doc = ""]
    pub static mut xmlSecNameRelationship: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefRelationship: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeRelationship: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeRelationshipReference: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecRelationshipsNs: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecRelationshipReferenceNs: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecRelationshipAttrId: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecRelationshipAttrSourceId: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecRelationshipAttrTargetMode: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " Xslt strings"]
    #[doc = ""]
    pub static mut xmlSecNameXslt: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecHrefXslt: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " SOAP 1.1/1.2 strings"]
    #[doc = ""]
    pub static mut xmlSecNodeEnvelope: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeHeader: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeBody: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeFault: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeFaultCode: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeFaultString: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeFaultActor: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeFaultDetail: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeCode: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeReason: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeNode: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeRole: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeDetail: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeValue: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeSubcode: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecNodeText: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecSoapFaultCodeVersionMismatch: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecSoapFaultCodeMustUnderstand: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecSoapFaultCodeClient: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecSoapFaultCodeServer: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecSoapFaultCodeReceiver: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecSoapFaultCodeSender: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecSoapFaultDataEncodningUnknown: [xmlChar; 0usize];
}
extern "C" {
    #[doc = " Utility strings"]
    #[doc = ""]
    pub static mut xmlSecStringEmpty: [xmlChar; 0usize];
}
extern "C" {
    pub static mut xmlSecStringCR: [xmlChar; 0usize];
}
#[doc = " Basic types to make ports to exotic platforms easier"]
#[doc = ""]
#[doc = " xmlSecPtr:"]
#[doc = ""]
#[doc = " Void pointer."]
pub type xmlSecPtr = *mut ::std::os::raw::c_void;
#[doc = " xmlSecKeyData"]
#[doc = ""]
#[doc = " xmlSecKeyData:"]
#[doc = " @id:                 the data id (#xmlSecKeyDataId)."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The key data: key value (crypto material), x509 data, pgp data, etc."]
pub type xmlSecKeyData = _xmlSecKeyData;
#[doc = " Forward declarations"]
#[doc = ""]
pub type xmlSecKeyDataPtr = *mut _xmlSecKeyData;
#[doc = " xmlSecKeyDataStore"]
#[doc = ""]
#[doc = " xmlSecKeyDataStore:"]
#[doc = " @id:                 the store id (#xmlSecKeyDataStoreId)."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The key data store. Key data store holds common key data specific information"]
#[doc = " required for key data processing. For example, X509 data store may hold"]
#[doc = " information about trusted (root) certificates."]
pub type xmlSecKeyDataStore = _xmlSecKeyDataStore;
pub type xmlSecKeyDataStorePtr = *mut _xmlSecKeyDataStore;
#[doc = " xmlSecKeyInfoCtx:"]
#[doc = " @userData:           the pointer to user data (xmlsec and xmlsec-crypto"]
#[doc = "                      never touch this)."]
#[doc = " @flags:              the bit mask for flags that control processin."]
#[doc = " @flags2:             reserved for future."]
#[doc = " @mode:               do we read or write <dsig:KeyInfo /> element."]
#[doc = " @keysMngr:           the pointer to current keys manager."]
#[doc = " @enabledKeyData:     the list of enabled @xmlSecKeyDataId (if list is"]
#[doc = "                      empty then all data ids are enabled)."]
#[doc = " @base64LineSize:     the max columns size for base64 encoding."]
#[doc = " @retrievalMethodCtx: the transforms context for <dsig:RetrievalMethod />"]
#[doc = "                      element processing."]
#[doc = " @maxRetrievalMethodLevel: the max recursion level when processing"]
#[doc = "                      <dsig:RetrievalMethod /> element; default level is 1"]
#[doc = "                      (see also @curRetrievalMethodLevel)."]
#[doc = " @encCtx:             the encryption context for <dsig:EncryptedKey /> element"]
#[doc = "                      processing."]
#[doc = " @maxEncryptedKeyLevel: the max recursion level when processing"]
#[doc = "                      <enc:EncryptedKey /> element; default level is 1"]
#[doc = "                      (see @curEncryptedKeyLevel)."]
#[doc = " @certsVerificationTime: the time to use for X509 certificates verification"]
#[doc = "                      (\"not valid before\" and \"not valid after\" checks);"]
#[doc = "                      if @certsVerificationTime is equal to 0 (default)"]
#[doc = "                      then we verify certificates against the system's"]
#[doc = "                      clock \"now\"."]
#[doc = " @certsVerificationDepth: the max certifications chain length (default is 9)."]
#[doc = " @pgpReserved:        reserved for PGP."]
#[doc = " @curRetrievalMethodLevel: the current <dsig:RetrievalMethod /> element"]
#[doc = "                      processing level (see @maxRetrievalMethodLevel)."]
#[doc = " @curEncryptedKeyLevel: the current <enc:EncryptedKey /> element"]
#[doc = "                      processing level (see @maxEncryptedKeyLevel)."]
#[doc = " @keyReq:             the current key requirements."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The <dsig:KeyInfo /> reading or writing context."]
pub type xmlSecKeyInfoCtx = _xmlSecKeyInfoCtx;
pub type xmlSecKeyInfoCtxPtr = *mut _xmlSecKeyInfoCtx;
#[doc = " xmlSecKey:"]
#[doc = " @name:               the key name."]
#[doc = " @value:              the key value."]
#[doc = " @dataList:           the key data list."]
#[doc = " @usage:              the key usage."]
#[doc = " @notValidBefore:     the start key validity interval."]
#[doc = " @notValidAfter:      the end key validity interval."]
#[doc = ""]
#[doc = " The key."]
pub type xmlSecKey = _xmlSecKey;
pub type xmlSecKeyPtr = *mut _xmlSecKey;
#[doc = " xmlSecKeyStore"]
#[doc = ""]
#[doc = " xmlSecKeyStore:"]
#[doc = " @id:                 the store id (#xmlSecKeyStoreId)."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The keys store."]
pub type xmlSecKeyStore = _xmlSecKeyStore;
pub type xmlSecKeyStorePtr = *mut _xmlSecKeyStore;
#[doc = " xmlSecKeysMngr:"]
#[doc = " @keysStore:                  the key store (list of keys known to keys manager)."]
#[doc = " @storesList:                 the list of key data stores known to keys manager."]
#[doc = " @getKey:                     the callback used to read <dsig:KeyInfo/> node."]
#[doc = ""]
#[doc = " The keys manager structure."]
pub type xmlSecKeysMngr = _xmlSecKeysMngr;
pub type xmlSecKeysMngrPtr = *mut _xmlSecKeysMngr;
#[doc = " xmlSecTransform"]
#[doc = ""]
#[doc = " xmlSecTransform:"]
#[doc = " @id:                 the transform id (pointer to #xmlSecTransformId)."]
#[doc = " @operation:          the transform's operation."]
#[doc = " @status:             the current status."]
#[doc = " @hereNode:           the pointer to transform's <dsig:Transform /> node."]
#[doc = " @next:               the pointer to next transform in the chain."]
#[doc = " @prev:               the pointer to previous transform in the chain."]
#[doc = " @inBuf:              the input binary data buffer."]
#[doc = " @outBuf:             the output binary data buffer."]
#[doc = " @inNodes:            the input XML nodes."]
#[doc = " @outNodes:           the output XML nodes."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The transform structure."]
pub type xmlSecTransform = _xmlSecTransform;
pub type xmlSecTransformPtr = *mut _xmlSecTransform;
#[doc = " xmlSecTransformCtx:"]
#[doc = " @userData:           the pointer to user data (xmlsec and xmlsec-crypto never"]
#[doc = "                      touch this)."]
#[doc = " @flags:              the bit mask flags to control transforms execution"]
#[doc = "                      (reserved for the future)."]
#[doc = " @flags2:             the bit mask flags to control transforms execution"]
#[doc = "                      (reserved for the future)."]
#[doc = " @enabledUris:        the allowed transform data source uri types."]
#[doc = " @enabledTransforms:  the list of enabled transforms; if list is empty (default)"]
#[doc = "                      then all registered transforms are enabled."]
#[doc = " @preExecCallback:    the callback called after preparing transform chain"]
#[doc = "                      and right before actual data processing; application"]
#[doc = "                      can use this callback to change transforms parameters,"]
#[doc = "                      insert additional transforms in the chain or do"]
#[doc = "                      additional validation (and abort transform execution"]
#[doc = "                      if needed)."]
#[doc = " @result:             the pointer to transforms result buffer."]
#[doc = " @status:             the transforms chain processing status."]
#[doc = " @uri:                the data source URI without xpointer expression."]
#[doc = " @xptrExpr:           the xpointer expression from data source URI (if any)."]
#[doc = " @first:              the first transform in the chain."]
#[doc = " @last:               the last transform in the chain."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The transform execution context."]
pub type xmlSecTransformCtx = _xmlSecTransformCtx;
pub type xmlSecTransformCtxPtr = *mut _xmlSecTransformCtx;
#[doc = " xmlSecDSigCtx:"]
#[doc = " @userData:                   the pointer to user data (xmlsec and xmlsec-crypto libraries"]
#[doc = "                              never touches this)."]
#[doc = " @flags:                      the XML Digital Signature processing flags."]
#[doc = " @flags2:                     the XML Digital Signature processing flags."]
#[doc = " @keyInfoReadCtx:             the reading key context."]
#[doc = " @keyInfoWriteCtx:            the writing key context (not used for signature verification)."]
#[doc = " @transformCtx:               the <dsig:SignedInfo/> node processing context."]
#[doc = " @enabledReferenceUris:       the URI types allowed for <dsig:Reference/> node."]
#[doc = " @enabledReferenceTransforms: the list of transforms allowed in <dsig:Reference/> node."]
#[doc = " @referencePreExecuteCallback:the callback for <dsig:Reference/> node processing."]
#[doc = " @defSignMethodId:            the default signing method klass."]
#[doc = " @defC14NMethodId:            the default c14n method klass."]
#[doc = " @defDigestMethodId:          the default digest method klass."]
#[doc = " @signKey:                    the signature key; application may set #signKey"]
#[doc = "                              before calling #xmlSecDSigCtxSign or #xmlSecDSigCtxVerify"]
#[doc = "                              functions."]
#[doc = " @operation:                  the operation: sign or verify."]
#[doc = " @result:                     the pointer to signature (not valid for signature verification)."]
#[doc = " @status:                     the <dsig:Signature/> processing status."]
#[doc = " @signMethod:                 the pointer to signature transform."]
#[doc = " @c14nMethod:                 the pointer to c14n transform."]
#[doc = " @preSignMemBufMethod:        the pointer to binary buffer right before signature"]
#[doc = "                              (valid only if #XMLSEC_DSIG_FLAGS_STORE_SIGNATURE flag is set)."]
#[doc = " @signValueNode:              the pointer to <dsig:SignatureValue/> node."]
#[doc = " @id:                         the pointer to Id attribute of <dsig:Signature/> node."]
#[doc = " @signedInfoReferences:       the list of references in <dsig:SignedInfo/> node."]
#[doc = " @manifestReferences:         the list of references in <dsig:Manifest/> nodes."]
#[doc = " @reserved0:                  reserved for the future."]
#[doc = " @reserved1:                  reserved for the future."]
#[doc = ""]
#[doc = " XML DSig processing context."]
pub type xmlSecDSigCtx = _xmlSecDSigCtx;
pub type xmlSecDSigCtxPtr = *mut _xmlSecDSigCtx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecEncCtx {
    _unused: [u8; 0],
}
pub type xmlSecEncCtx = _xmlSecEncCtx;
pub type xmlSecEncCtxPtr = *mut _xmlSecEncCtx;
extern "C" {
    pub fn xmlSecInit() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecShutdown() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecGetDefaultCrypto() -> *const xmlChar;
}
extern "C" {
    pub fn xmlSecSetExternalEntityLoader(arg1: xmlExternalEntityLoader);
}
pub const xmlSecCheckVersionMode_xmlSecCheckVersionExactMatch: xmlSecCheckVersionMode = 0;
pub const xmlSecCheckVersionMode_xmlSecCheckVersionABICompatible: xmlSecCheckVersionMode = 1;
#[doc = " xmlSecCheckVersionMode:"]
#[doc = " @xmlSecCheckVersionExactMatch:       the version should match exactly."]
#[doc = " @xmlSecCheckVersionABICompatible:    the version should be ABI compatible."]
#[doc = ""]
#[doc = " The xmlsec library version mode."]
pub type xmlSecCheckVersionMode = ::std::os::raw::c_int;
extern "C" {
    pub fn xmlSecCheckVersionExt(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
        subminor: ::std::os::raw::c_int,
        mode: xmlSecCheckVersionMode,
    ) -> ::std::os::raw::c_int;
}
#[doc = " xmlSecBuffer:"]
#[doc = " @data: the pointer to buffer data."]
#[doc = " @size: the current data size."]
#[doc = " @maxSize: the max data size (allocated buffer size)."]
#[doc = " @allocMode: the buffer memory allocation mode."]
#[doc = ""]
#[doc = " Binary data buffer."]
pub type xmlSecBuffer = _xmlSecBuffer;
pub type xmlSecBufferPtr = *mut _xmlSecBuffer;
pub const xmlSecAllocMode_xmlSecAllocModeExact: xmlSecAllocMode = 0;
pub const xmlSecAllocMode_xmlSecAllocModeDouble: xmlSecAllocMode = 1;
#[doc = " xmlSecAllocMode:"]
#[doc = " @xmlSecAllocModeExact:       the memory allocation mode that minimizes total"]
#[doc = "                              allocated memory size."]
#[doc = " @xmlSecAllocModeDouble:      the memory allocation mode that tries to minimize"]
#[doc = "                              the number of malloc calls."]
#[doc = ""]
#[doc = " The memory allocation mode (used by @xmlSecBuffer and @xmlSecList)."]
pub type xmlSecAllocMode = ::std::os::raw::c_int;
#[doc = " xmlSecBuffer:"]
#[doc = " @data: the pointer to buffer data."]
#[doc = " @size: the current data size."]
#[doc = " @maxSize: the max data size (allocated buffer size)."]
#[doc = " @allocMode: the buffer memory allocation mode."]
#[doc = ""]
#[doc = " Binary data buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecBuffer {
    pub data: *mut ::std::os::raw::c_uchar,
    pub size: size_t,
    pub maxSize: size_t,
    pub allocMode: xmlSecAllocMode,
}
#[test]
fn bindgen_test_layout__xmlSecBuffer() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecBuffer>(),
        32usize,
        concat!("Size of: ", stringify!(_xmlSecBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecBuffer))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecBuffer),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecBuffer),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_maxSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecBuffer),
                "::",
                stringify!(maxSize)
            )
        );
    }
    test_field_maxSize();
    fn test_field_allocMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocMode) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecBuffer),
                "::",
                stringify!(allocMode)
            )
        );
    }
    test_field_allocMode();
}
extern "C" {
    pub fn xmlSecBufferSetDefaultAllocMode(defAllocMode: xmlSecAllocMode, defInitialSize: size_t);
}
extern "C" {
    pub fn xmlSecBufferCreate(size: size_t) -> xmlSecBufferPtr;
}
extern "C" {
    pub fn xmlSecBufferDestroy(buf: xmlSecBufferPtr);
}
extern "C" {
    pub fn xmlSecBufferInitialize(buf: xmlSecBufferPtr, size: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecBufferFinalize(buf: xmlSecBufferPtr);
}
extern "C" {
    pub fn xmlSecBufferGetData(buf: xmlSecBufferPtr) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn xmlSecBufferSetData(
        buf: xmlSecBufferPtr,
        data: *const ::std::os::raw::c_uchar,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecBufferGetSize(buf: xmlSecBufferPtr) -> size_t;
}
extern "C" {
    pub fn xmlSecBufferSetSize(buf: xmlSecBufferPtr, size: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecBufferGetMaxSize(buf: xmlSecBufferPtr) -> size_t;
}
extern "C" {
    pub fn xmlSecBufferSetMaxSize(buf: xmlSecBufferPtr, size: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecBufferEmpty(buf: xmlSecBufferPtr);
}
extern "C" {
    pub fn xmlSecBufferAppend(
        buf: xmlSecBufferPtr,
        data: *const ::std::os::raw::c_uchar,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecBufferPrepend(
        buf: xmlSecBufferPtr,
        data: *const ::std::os::raw::c_uchar,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecBufferRemoveHead(buf: xmlSecBufferPtr, size: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecBufferRemoveTail(buf: xmlSecBufferPtr, size: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecBufferReadFile(
        buf: xmlSecBufferPtr,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecBufferBase64NodeContentRead(
        buf: xmlSecBufferPtr,
        node: xmlNodePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecBufferBase64NodeContentWrite(
        buf: xmlSecBufferPtr,
        node: xmlNodePtr,
        columns: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecBufferCreateOutputBuffer(buf: xmlSecBufferPtr) -> xmlOutputBufferPtr;
}
#[doc = " xmlSecPtrListKlass:"]
#[doc = " @name:               the list klass name."]
#[doc = " @duplicateItem:      the duplicate item method."]
#[doc = " @destroyItem:        the destroy item method."]
#[doc = " @debugDumpItem:      the debug dump item method."]
#[doc = " @debugXmlDumpItem:   the debug dump item in xml format method."]
#[doc = ""]
#[doc = " List klass."]
pub type xmlSecPtrListKlass = _xmlSecPtrListKlass;
pub type xmlSecPtrListId = *const _xmlSecPtrListKlass;
#[doc = " xmlSecPtrList:"]
#[doc = " @id:                         the list items description."]
#[doc = " @data:                       the list data."]
#[doc = " @use:                        the current list size."]
#[doc = " @max:                        the max (allocated) list size."]
#[doc = " @allocMode:                  the memory allocation mode."]
#[doc = ""]
#[doc = " The pointers list."]
pub type xmlSecPtrList = _xmlSecPtrList;
pub type xmlSecPtrListPtr = *mut _xmlSecPtrList;
#[doc = " xmlSecPtrList:"]
#[doc = " @id:                         the list items description."]
#[doc = " @data:                       the list data."]
#[doc = " @use:                        the current list size."]
#[doc = " @max:                        the max (allocated) list size."]
#[doc = " @allocMode:                  the memory allocation mode."]
#[doc = ""]
#[doc = " The pointers list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecPtrList {
    pub id: xmlSecPtrListId,
    pub data: *mut xmlSecPtr,
    pub use_: size_t,
    pub max: size_t,
    pub allocMode: xmlSecAllocMode,
}
#[test]
fn bindgen_test_layout__xmlSecPtrList() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecPtrList>(),
        40usize,
        concat!("Size of: ", stringify!(_xmlSecPtrList))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecPtrList>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecPtrList))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecPtrList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecPtrList),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecPtrList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecPtrList),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_use() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecPtrList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).use_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecPtrList),
                "::",
                stringify!(use_)
            )
        );
    }
    test_field_use();
    fn test_field_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecPtrList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecPtrList),
                "::",
                stringify!(max)
            )
        );
    }
    test_field_max();
    fn test_field_allocMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecPtrList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocMode) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecPtrList),
                "::",
                stringify!(allocMode)
            )
        );
    }
    test_field_allocMode();
}
extern "C" {
    pub fn xmlSecPtrListSetDefaultAllocMode(defAllocMode: xmlSecAllocMode, defInitialSize: size_t);
}
extern "C" {
    pub fn xmlSecPtrListInitialize(
        list: xmlSecPtrListPtr,
        id: xmlSecPtrListId,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecPtrListFinalize(list: xmlSecPtrListPtr);
}
extern "C" {
    pub fn xmlSecPtrListCreate(id: xmlSecPtrListId) -> xmlSecPtrListPtr;
}
extern "C" {
    pub fn xmlSecPtrListDestroy(list: xmlSecPtrListPtr);
}
extern "C" {
    pub fn xmlSecPtrListEmpty(list: xmlSecPtrListPtr);
}
extern "C" {
    pub fn xmlSecPtrListCopy(dst: xmlSecPtrListPtr, src: xmlSecPtrListPtr)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecPtrListDuplicate(list: xmlSecPtrListPtr) -> xmlSecPtrListPtr;
}
extern "C" {
    pub fn xmlSecPtrListGetSize(list: xmlSecPtrListPtr) -> size_t;
}
extern "C" {
    pub fn xmlSecPtrListGetItem(list: xmlSecPtrListPtr, pos: size_t) -> xmlSecPtr;
}
extern "C" {
    pub fn xmlSecPtrListAdd(list: xmlSecPtrListPtr, item: xmlSecPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecPtrListSet(
        list: xmlSecPtrListPtr,
        item: xmlSecPtr,
        pos: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecPtrListRemove(list: xmlSecPtrListPtr, pos: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecPtrListRemoveAndReturn(list: xmlSecPtrListPtr, pos: size_t) -> xmlSecPtr;
}
extern "C" {
    pub fn xmlSecPtrListDebugDump(list: xmlSecPtrListPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecPtrListDebugXmlDump(list: xmlSecPtrListPtr, output: *mut FILE);
}
#[doc = " xmlSecPtrDuplicateItemMethod:"]
#[doc = " @ptr:                the poinetr to list item."]
#[doc = ""]
#[doc = " Duplicates item @ptr."]
#[doc = ""]
#[doc = " Returns: pointer to new item copy or NULL if an error occurs."]
pub type xmlSecPtrDuplicateItemMethod =
    ::std::option::Option<unsafe extern "C" fn(ptr: xmlSecPtr) -> xmlSecPtr>;
#[doc = " xmlSecPtrDestroyItemMethod:"]
#[doc = " @ptr:                the poinetr to list item."]
#[doc = ""]
#[doc = " Destroys list item @ptr."]
pub type xmlSecPtrDestroyItemMethod = ::std::option::Option<unsafe extern "C" fn(ptr: xmlSecPtr)>;
#[doc = " xmlSecPtrDebugDumpItemMethod:"]
#[doc = " @ptr:                the poinetr to list item."]
#[doc = " @output:             the output FILE."]
#[doc = ""]
#[doc = " Prints debug information about @item to @output."]
pub type xmlSecPtrDebugDumpItemMethod =
    ::std::option::Option<unsafe extern "C" fn(ptr: xmlSecPtr, output: *mut FILE)>;
#[doc = " xmlSecPtrListKlass:"]
#[doc = " @name:               the list klass name."]
#[doc = " @duplicateItem:      the duplicate item method."]
#[doc = " @destroyItem:        the destroy item method."]
#[doc = " @debugDumpItem:      the debug dump item method."]
#[doc = " @debugXmlDumpItem:   the debug dump item in xml format method."]
#[doc = ""]
#[doc = " List klass."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecPtrListKlass {
    pub name: *const xmlChar,
    pub duplicateItem: xmlSecPtrDuplicateItemMethod,
    pub destroyItem: xmlSecPtrDestroyItemMethod,
    pub debugDumpItem: xmlSecPtrDebugDumpItemMethod,
    pub debugXmlDumpItem: xmlSecPtrDebugDumpItemMethod,
}
#[test]
fn bindgen_test_layout__xmlSecPtrListKlass() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecPtrListKlass>(),
        40usize,
        concat!("Size of: ", stringify!(_xmlSecPtrListKlass))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecPtrListKlass>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecPtrListKlass))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecPtrListKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecPtrListKlass),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_duplicateItem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecPtrListKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).duplicateItem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecPtrListKlass),
                "::",
                stringify!(duplicateItem)
            )
        );
    }
    test_field_duplicateItem();
    fn test_field_destroyItem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecPtrListKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destroyItem) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecPtrListKlass),
                "::",
                stringify!(destroyItem)
            )
        );
    }
    test_field_destroyItem();
    fn test_field_debugDumpItem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecPtrListKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).debugDumpItem) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecPtrListKlass),
                "::",
                stringify!(debugDumpItem)
            )
        );
    }
    test_field_debugDumpItem();
    fn test_field_debugXmlDumpItem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecPtrListKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).debugXmlDumpItem) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecPtrListKlass),
                "::",
                stringify!(debugXmlDumpItem)
            )
        );
    }
    test_field_debugXmlDumpItem();
}
extern "C" {
    pub fn xmlSecStringListGetKlass() -> xmlSecPtrListId;
}
#[doc = " xmlSecKeyDataKlass:"]
#[doc = " @klassSize:          the klass size."]
#[doc = " @objSize:            the object size."]
#[doc = " @name:               the object name."]
#[doc = " @usage:              the allowed data usage."]
#[doc = " @href:               the identification string (href)."]
#[doc = " @dataNodeName:       the data's XML node name."]
#[doc = " @dataNodeNs:         the data's XML node namespace."]
#[doc = " @initialize:         the initialization method."]
#[doc = " @duplicate:          the duplicate (copy) method."]
#[doc = " @finalize:           the finalization (destroy) method."]
#[doc = " @generate:           the new data generation method."]
#[doc = " @getType:            the method to access data's type information."]
#[doc = " @getSize:            the method to access data's size."]
#[doc = " @getIdentifier:      the method to access data's string identifier."]
#[doc = " @xmlRead:            the method for reading data from XML node."]
#[doc = " @xmlWrite:           the method for writing data to XML node."]
#[doc = " @binRead:            the method for reading data from a binary buffer."]
#[doc = " @binWrite:           the method for writing data to binary buffer."]
#[doc = " @debugDump:          the method for printing debug data information."]
#[doc = " @debugXmlDump:       the method for printing debug data information in XML format."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The data id (klass)."]
pub type xmlSecKeyDataKlass = _xmlSecKeyDataKlass;
#[doc = " Forward declarations"]
#[doc = ""]
pub type xmlSecKeyDataId = *const _xmlSecKeyDataKlass;
#[doc = " xmlSecKeyDataStoreKlass:"]
#[doc = " @klassSize:          the data store klass size."]
#[doc = " @objSize:            the data store obj size."]
#[doc = " @name:               the store's name."]
#[doc = " @initialize:         the store's initialization method."]
#[doc = " @finalize:           the store's finalization (destroy) method."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The data store id (klass)."]
pub type xmlSecKeyDataStoreKlass = _xmlSecKeyDataStoreKlass;
pub type xmlSecKeyDataStoreId = *const _xmlSecKeyDataStoreKlass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecKeyDataList {
    _unused: [u8; 0],
}
pub type xmlSecKeyDataList = _xmlSecKeyDataList;
pub type xmlSecKeyDataListPtr = *mut _xmlSecKeyDataList;
#[doc = " xmlSecKeyDataUsage"]
#[doc = ""]
#[doc = " xmlSecKeyDataUsage:"]
#[doc = ""]
#[doc = " The bits mask that determines possible keys data usage."]
pub type xmlSecKeyDataUsage = ::std::os::raw::c_uint;
#[doc = " xmlSecKeyDataType"]
#[doc = ""]
#[doc = " xmlSecKeyDataType:"]
#[doc = ""]
#[doc = " The key data type (public/private, session/permanent, etc.)."]
pub type xmlSecKeyDataType = ::std::os::raw::c_uint;
pub const xmlSecKeyDataFormat_xmlSecKeyDataFormatUnknown: xmlSecKeyDataFormat = 0;
pub const xmlSecKeyDataFormat_xmlSecKeyDataFormatBinary: xmlSecKeyDataFormat = 1;
pub const xmlSecKeyDataFormat_xmlSecKeyDataFormatPem: xmlSecKeyDataFormat = 2;
pub const xmlSecKeyDataFormat_xmlSecKeyDataFormatDer: xmlSecKeyDataFormat = 3;
pub const xmlSecKeyDataFormat_xmlSecKeyDataFormatPkcs8Pem: xmlSecKeyDataFormat = 4;
pub const xmlSecKeyDataFormat_xmlSecKeyDataFormatPkcs8Der: xmlSecKeyDataFormat = 5;
pub const xmlSecKeyDataFormat_xmlSecKeyDataFormatPkcs12: xmlSecKeyDataFormat = 6;
pub const xmlSecKeyDataFormat_xmlSecKeyDataFormatCertPem: xmlSecKeyDataFormat = 7;
pub const xmlSecKeyDataFormat_xmlSecKeyDataFormatCertDer: xmlSecKeyDataFormat = 8;
#[doc = " xmlSecKeyDataFormat"]
#[doc = ""]
#[doc = " xmlSecKeyDataFormat:"]
#[doc = " @xmlSecKeyDataFormatUnknown:         the key data format is unknown."]
#[doc = " @xmlSecKeyDataFormatBinary:          the binary key data."]
#[doc = " @xmlSecKeyDataFormatPem:             the PEM key data (cert or public/private key)."]
#[doc = " @xmlSecKeyDataFormatDer:             the DER key data (cert or public/private key)."]
#[doc = " @xmlSecKeyDataFormatPkcs8Pem:        the PKCS8 PEM private key."]
#[doc = " @xmlSecKeyDataFormatPkcs8Der:        the PKCS8 DER private key."]
#[doc = " @xmlSecKeyDataFormatPkcs12:          the PKCS12 format (bag of keys and certs)"]
#[doc = " @xmlSecKeyDataFormatCertPem:         the PEM cert."]
#[doc = " @xmlSecKeyDataFormatCertDer:         the DER cert."]
#[doc = ""]
#[doc = " The key data format (binary, der, pem, etc.)."]
pub type xmlSecKeyDataFormat = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Global xmlSecKeyDataIds methods"]
    #[doc = ""]
    pub fn xmlSecKeyDataIdsGet() -> xmlSecPtrListPtr;
}
extern "C" {
    pub fn xmlSecKeyDataIdsInit() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDataIdsShutdown();
}
extern "C" {
    pub fn xmlSecKeyDataIdsRegisterDefault() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDataIdsRegister(id: xmlSecKeyDataId) -> ::std::os::raw::c_int;
}
#[doc = " xmlSecKeyData"]
#[doc = ""]
#[doc = " xmlSecKeyData:"]
#[doc = " @id:                 the data id (#xmlSecKeyDataId)."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The key data: key value (crypto material), x509 data, pgp data, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecKeyData {
    pub id: xmlSecKeyDataId,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSecKeyData() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecKeyData>(),
        24usize,
        concat!("Size of: ", stringify!(_xmlSecKeyData))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecKeyData>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecKeyData))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyData),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyData),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyData),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
extern "C" {
    pub fn xmlSecKeyDataCreate(id: xmlSecKeyDataId) -> xmlSecKeyDataPtr;
}
extern "C" {
    pub fn xmlSecKeyDataDuplicate(data: xmlSecKeyDataPtr) -> xmlSecKeyDataPtr;
}
extern "C" {
    pub fn xmlSecKeyDataDestroy(data: xmlSecKeyDataPtr);
}
extern "C" {
    pub fn xmlSecKeyDataGenerate(
        data: xmlSecKeyDataPtr,
        sizeBits: size_t,
        type_: xmlSecKeyDataType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDataGetType(data: xmlSecKeyDataPtr) -> xmlSecKeyDataType;
}
extern "C" {
    pub fn xmlSecKeyDataGetSize(data: xmlSecKeyDataPtr) -> size_t;
}
extern "C" {
    pub fn xmlSecKeyDataGetIdentifier(data: xmlSecKeyDataPtr) -> *const xmlChar;
}
extern "C" {
    pub fn xmlSecKeyDataDebugDump(data: xmlSecKeyDataPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecKeyDataDebugXmlDump(data: xmlSecKeyDataPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecKeyDataXmlRead(
        id: xmlSecKeyDataId,
        key: xmlSecKeyPtr,
        node: xmlNodePtr,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDataXmlWrite(
        id: xmlSecKeyDataId,
        key: xmlSecKeyPtr,
        node: xmlNodePtr,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDataBinRead(
        id: xmlSecKeyDataId,
        key: xmlSecKeyPtr,
        buf: *const ::std::os::raw::c_uchar,
        bufSize: size_t,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDataBinWrite(
        id: xmlSecKeyDataId,
        key: xmlSecKeyPtr,
        buf: *mut *mut ::std::os::raw::c_uchar,
        bufSize: *mut size_t,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int;
}
#[doc = " xmlSecKeyDataInitMethod:"]
#[doc = " @data:               the pointer to key data."]
#[doc = ""]
#[doc = " Key data specific initialization method."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value if an error occurs."]
pub type xmlSecKeyDataInitMethod =
    ::std::option::Option<unsafe extern "C" fn(data: xmlSecKeyDataPtr) -> ::std::os::raw::c_int>;
#[doc = " xmlSecKeyDataDuplicateMethod:"]
#[doc = " @dst:                the pointer to destination key data."]
#[doc = " @src:                the pointer to source key data."]
#[doc = ""]
#[doc = " Key data specific duplication (copy) method."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value if an error occurs."]
pub type xmlSecKeyDataDuplicateMethod = ::std::option::Option<
    unsafe extern "C" fn(dst: xmlSecKeyDataPtr, src: xmlSecKeyDataPtr) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecKeyDataFinalizeMethod:"]
#[doc = " @data:               the data."]
#[doc = ""]
#[doc = " Key data specific finalization method. All the objects and resources allocated"]
#[doc = " by the key data object must be freed inside this method."]
pub type xmlSecKeyDataFinalizeMethod =
    ::std::option::Option<unsafe extern "C" fn(data: xmlSecKeyDataPtr)>;
#[doc = " xmlSecKeyDataXmlReadMethod:"]
#[doc = " @id:                 the data id."]
#[doc = " @key:                the key."]
#[doc = " @node:               the pointer to data's value XML node."]
#[doc = " @keyInfoCtx:         the <dsig:KeyInfo/> node processing context."]
#[doc = ""]
#[doc = " Key data specific method for reading XML node."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value if an error occurs."]
pub type xmlSecKeyDataXmlReadMethod = ::std::option::Option<
    unsafe extern "C" fn(
        id: xmlSecKeyDataId,
        key: xmlSecKeyPtr,
        node: xmlNodePtr,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecKeyDataXmlWriteMethod:"]
#[doc = " @id:                 the data id."]
#[doc = " @key:                the key."]
#[doc = " @node:               the pointer to data's value XML node."]
#[doc = " @keyInfoCtx:         the <dsig:KeyInfo> node processing context."]
#[doc = ""]
#[doc = " Key data specific method for writing XML node."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value if an error occurs."]
pub type xmlSecKeyDataXmlWriteMethod = ::std::option::Option<
    unsafe extern "C" fn(
        id: xmlSecKeyDataId,
        key: xmlSecKeyPtr,
        node: xmlNodePtr,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecKeyDataBinReadMethod:"]
#[doc = " @id:                 the data id."]
#[doc = " @key:                the key."]
#[doc = " @buf:                the input buffer."]
#[doc = " @bufSize:            the buffer size."]
#[doc = " @keyInfoCtx:         the <dsig:KeyInfo/> node processing context."]
#[doc = ""]
#[doc = " Key data specific method for reading binary buffer."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value if an error occurs."]
pub type xmlSecKeyDataBinReadMethod = ::std::option::Option<
    unsafe extern "C" fn(
        id: xmlSecKeyDataId,
        key: xmlSecKeyPtr,
        buf: *const ::std::os::raw::c_uchar,
        bufSize: size_t,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecKeyDataBinWriteMethod:"]
#[doc = " @id:                 the data id."]
#[doc = " @key:                the key."]
#[doc = " @buf:                the output buffer."]
#[doc = " @bufSize:            the buffer size."]
#[doc = " @keyInfoCtx:         the <dsig:KeyInfo/> node processing context."]
#[doc = ""]
#[doc = " Key data specific method for reading binary buffer."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value if an error occurs."]
pub type xmlSecKeyDataBinWriteMethod = ::std::option::Option<
    unsafe extern "C" fn(
        id: xmlSecKeyDataId,
        key: xmlSecKeyPtr,
        buf: *mut *mut ::std::os::raw::c_uchar,
        bufSize: *mut size_t,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecKeyDataGenerateMethod:"]
#[doc = " @data:               the pointer to key data."]
#[doc = " @sizeBits:           the key data specific size."]
#[doc = " @type:               the required key type (session/permanent, etc.)"]
#[doc = ""]
#[doc = " Key data specific method for generating new key data."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value if an error occurs."]
pub type xmlSecKeyDataGenerateMethod = ::std::option::Option<
    unsafe extern "C" fn(
        data: xmlSecKeyDataPtr,
        sizeBits: size_t,
        type_: xmlSecKeyDataType,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecKeyDataGetTypeMethod:"]
#[doc = " @data:                the data."]
#[doc = ""]
#[doc = " Key data specific method to get the key type."]
#[doc = ""]
#[doc = " Returns: the key type."]
pub type xmlSecKeyDataGetTypeMethod =
    ::std::option::Option<unsafe extern "C" fn(data: xmlSecKeyDataPtr) -> xmlSecKeyDataType>;
#[doc = " xmlSecKeyDataGetSizeMethod:"]
#[doc = " @data:               the pointer to key data."]
#[doc = ""]
#[doc = " Key data specific method to get the key size."]
#[doc = ""]
#[doc = " Returns: the key size in bits."]
pub type xmlSecKeyDataGetSizeMethod =
    ::std::option::Option<unsafe extern "C" fn(data: xmlSecKeyDataPtr) -> size_t>;
#[doc = " xmlSecKeyDataGetIdentifierMethod:"]
#[doc = " @data:               the pointer to key data."]
#[doc = ""]
#[doc = " Key data specific method to get the key data identifier string (for example,"]
#[doc = " X509 data identifier is the subject of the verified cert)."]
#[doc = ""]
#[doc = " Returns: the identifier string or NULL if an error occurs."]
pub type xmlSecKeyDataGetIdentifierMethod =
    ::std::option::Option<unsafe extern "C" fn(data: xmlSecKeyDataPtr) -> *const xmlChar>;
#[doc = " xmlSecKeyDataDebugDumpMethod:"]
#[doc = " @data:               the data."]
#[doc = " @output:             the FILE to print debug info (should be open for writing)."]
#[doc = ""]
#[doc = " Key data specific method for printing debug info."]
pub type xmlSecKeyDataDebugDumpMethod =
    ::std::option::Option<unsafe extern "C" fn(data: xmlSecKeyDataPtr, output: *mut FILE)>;
#[doc = " xmlSecKeyDataKlass:"]
#[doc = " @klassSize:          the klass size."]
#[doc = " @objSize:            the object size."]
#[doc = " @name:               the object name."]
#[doc = " @usage:              the allowed data usage."]
#[doc = " @href:               the identification string (href)."]
#[doc = " @dataNodeName:       the data's XML node name."]
#[doc = " @dataNodeNs:         the data's XML node namespace."]
#[doc = " @initialize:         the initialization method."]
#[doc = " @duplicate:          the duplicate (copy) method."]
#[doc = " @finalize:           the finalization (destroy) method."]
#[doc = " @generate:           the new data generation method."]
#[doc = " @getType:            the method to access data's type information."]
#[doc = " @getSize:            the method to access data's size."]
#[doc = " @getIdentifier:      the method to access data's string identifier."]
#[doc = " @xmlRead:            the method for reading data from XML node."]
#[doc = " @xmlWrite:           the method for writing data to XML node."]
#[doc = " @binRead:            the method for reading data from a binary buffer."]
#[doc = " @binWrite:           the method for writing data to binary buffer."]
#[doc = " @debugDump:          the method for printing debug data information."]
#[doc = " @debugXmlDump:       the method for printing debug data information in XML format."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The data id (klass)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecKeyDataKlass {
    pub klassSize: size_t,
    pub objSize: size_t,
    pub name: *const xmlChar,
    pub usage: xmlSecKeyDataUsage,
    pub href: *const xmlChar,
    pub dataNodeName: *const xmlChar,
    pub dataNodeNs: *const xmlChar,
    pub initialize: xmlSecKeyDataInitMethod,
    pub duplicate: xmlSecKeyDataDuplicateMethod,
    pub finalize: xmlSecKeyDataFinalizeMethod,
    pub generate: xmlSecKeyDataGenerateMethod,
    pub getType: xmlSecKeyDataGetTypeMethod,
    pub getSize: xmlSecKeyDataGetSizeMethod,
    pub getIdentifier: xmlSecKeyDataGetIdentifierMethod,
    pub xmlRead: xmlSecKeyDataXmlReadMethod,
    pub xmlWrite: xmlSecKeyDataXmlWriteMethod,
    pub binRead: xmlSecKeyDataBinReadMethod,
    pub binWrite: xmlSecKeyDataBinWriteMethod,
    pub debugDump: xmlSecKeyDataDebugDumpMethod,
    pub debugXmlDump: xmlSecKeyDataDebugDumpMethod,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSecKeyDataKlass() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecKeyDataKlass>(),
        176usize,
        concat!("Size of: ", stringify!(_xmlSecKeyDataKlass))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecKeyDataKlass>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecKeyDataKlass))
    );
    fn test_field_klassSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).klassSize) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(klassSize)
            )
        );
    }
    test_field_klassSize();
    fn test_field_objSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objSize) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(objSize)
            )
        );
    }
    test_field_objSize();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_usage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(usage)
            )
        );
    }
    test_field_usage();
    fn test_field_href() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).href) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(href)
            )
        );
    }
    test_field_href();
    fn test_field_dataNodeName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataNodeName) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(dataNodeName)
            )
        );
    }
    test_field_dataNodeName();
    fn test_field_dataNodeNs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataNodeNs) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(dataNodeNs)
            )
        );
    }
    test_field_dataNodeNs();
    fn test_field_initialize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initialize) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(initialize)
            )
        );
    }
    test_field_initialize();
    fn test_field_duplicate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).duplicate) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(duplicate)
            )
        );
    }
    test_field_duplicate();
    fn test_field_finalize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(finalize)
            )
        );
    }
    test_field_finalize();
    fn test_field_generate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).generate) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(generate)
            )
        );
    }
    test_field_generate();
    fn test_field_getType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getType) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(getType)
            )
        );
    }
    test_field_getType();
    fn test_field_getSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getSize) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(getSize)
            )
        );
    }
    test_field_getSize();
    fn test_field_getIdentifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getIdentifier) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(getIdentifier)
            )
        );
    }
    test_field_getIdentifier();
    fn test_field_xmlRead() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlRead) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(xmlRead)
            )
        );
    }
    test_field_xmlRead();
    fn test_field_xmlWrite() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xmlWrite) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(xmlWrite)
            )
        );
    }
    test_field_xmlWrite();
    fn test_field_binRead() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binRead) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(binRead)
            )
        );
    }
    test_field_binRead();
    fn test_field_binWrite() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binWrite) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(binWrite)
            )
        );
    }
    test_field_binWrite();
    fn test_field_debugDump() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).debugDump) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(debugDump)
            )
        );
    }
    test_field_debugDump();
    fn test_field_debugXmlDump() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).debugXmlDump) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(debugXmlDump)
            )
        );
    }
    test_field_debugXmlDump();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataKlass),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
extern "C" {
    pub fn xmlSecKeyDataListGetKlass() -> xmlSecPtrListId;
}
extern "C" {
    pub fn xmlSecKeyDataIdListGetKlass() -> xmlSecPtrListId;
}
extern "C" {
    pub fn xmlSecKeyDataIdListFind(
        list: xmlSecPtrListPtr,
        dataId: xmlSecKeyDataId,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDataIdListFindByNode(
        list: xmlSecPtrListPtr,
        nodeName: *const xmlChar,
        nodeNs: *const xmlChar,
        usage: xmlSecKeyDataUsage,
    ) -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataIdListFindByHref(
        list: xmlSecPtrListPtr,
        href: *const xmlChar,
        usage: xmlSecKeyDataUsage,
    ) -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataIdListFindByName(
        list: xmlSecPtrListPtr,
        name: *const xmlChar,
        usage: xmlSecKeyDataUsage,
    ) -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataIdListDebugDump(list: xmlSecPtrListPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecKeyDataIdListDebugXmlDump(list: xmlSecPtrListPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecKeyDataBinaryValueInitialize(data: xmlSecKeyDataPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDataBinaryValueDuplicate(
        dst: xmlSecKeyDataPtr,
        src: xmlSecKeyDataPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDataBinaryValueFinalize(data: xmlSecKeyDataPtr);
}
extern "C" {
    pub fn xmlSecKeyDataBinaryValueXmlRead(
        id: xmlSecKeyDataId,
        key: xmlSecKeyPtr,
        node: xmlNodePtr,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDataBinaryValueXmlWrite(
        id: xmlSecKeyDataId,
        key: xmlSecKeyPtr,
        node: xmlNodePtr,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDataBinaryValueBinRead(
        id: xmlSecKeyDataId,
        key: xmlSecKeyPtr,
        buf: *const ::std::os::raw::c_uchar,
        bufSize: size_t,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDataBinaryValueBinWrite(
        id: xmlSecKeyDataId,
        key: xmlSecKeyPtr,
        buf: *mut *mut ::std::os::raw::c_uchar,
        bufSize: *mut size_t,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDataBinaryValueDebugDump(data: xmlSecKeyDataPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecKeyDataBinaryValueDebugXmlDump(data: xmlSecKeyDataPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecKeyDataBinaryValueGetSize(data: xmlSecKeyDataPtr) -> size_t;
}
extern "C" {
    pub fn xmlSecKeyDataBinaryValueGetBuffer(data: xmlSecKeyDataPtr) -> xmlSecBufferPtr;
}
extern "C" {
    pub fn xmlSecKeyDataBinaryValueSetBuffer(
        data: xmlSecKeyDataPtr,
        buf: *const ::std::os::raw::c_uchar,
        bufSize: size_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " xmlSecKeyDataStore"]
#[doc = ""]
#[doc = " xmlSecKeyDataStore:"]
#[doc = " @id:                 the store id (#xmlSecKeyDataStoreId)."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The key data store. Key data store holds common key data specific information"]
#[doc = " required for key data processing. For example, X509 data store may hold"]
#[doc = " information about trusted (root) certificates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecKeyDataStore {
    pub id: xmlSecKeyDataStoreId,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSecKeyDataStore() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecKeyDataStore>(),
        24usize,
        concat!("Size of: ", stringify!(_xmlSecKeyDataStore))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecKeyDataStore>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecKeyDataStore))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataStore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataStore),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataStore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataStore),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataStore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataStore),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
extern "C" {
    pub fn xmlSecKeyDataStoreCreate(id: xmlSecKeyDataStoreId) -> xmlSecKeyDataStorePtr;
}
extern "C" {
    pub fn xmlSecKeyDataStoreDestroy(store: xmlSecKeyDataStorePtr);
}
#[doc = " xmlSecKeyDataStoreInitializeMethod:"]
#[doc = " @store:              the data store."]
#[doc = ""]
#[doc = " Key data store specific initialization method."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value if an error occurs."]
pub type xmlSecKeyDataStoreInitializeMethod = ::std::option::Option<
    unsafe extern "C" fn(store: xmlSecKeyDataStorePtr) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecKeyDataStoreFinalizeMethod:"]
#[doc = " @store:              the data store."]
#[doc = ""]
#[doc = " Key data store specific finalization (destroy) method."]
pub type xmlSecKeyDataStoreFinalizeMethod =
    ::std::option::Option<unsafe extern "C" fn(store: xmlSecKeyDataStorePtr)>;
#[doc = " xmlSecKeyDataStoreKlass:"]
#[doc = " @klassSize:          the data store klass size."]
#[doc = " @objSize:            the data store obj size."]
#[doc = " @name:               the store's name."]
#[doc = " @initialize:         the store's initialization method."]
#[doc = " @finalize:           the store's finalization (destroy) method."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The data store id (klass)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecKeyDataStoreKlass {
    pub klassSize: size_t,
    pub objSize: size_t,
    pub name: *const xmlChar,
    pub initialize: xmlSecKeyDataStoreInitializeMethod,
    pub finalize: xmlSecKeyDataStoreFinalizeMethod,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSecKeyDataStoreKlass() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecKeyDataStoreKlass>(),
        56usize,
        concat!("Size of: ", stringify!(_xmlSecKeyDataStoreKlass))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecKeyDataStoreKlass>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecKeyDataStoreKlass))
    );
    fn test_field_klassSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).klassSize) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataStoreKlass),
                "::",
                stringify!(klassSize)
            )
        );
    }
    test_field_klassSize();
    fn test_field_objSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objSize) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataStoreKlass),
                "::",
                stringify!(objSize)
            )
        );
    }
    test_field_objSize();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataStoreKlass),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_initialize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initialize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataStoreKlass),
                "::",
                stringify!(initialize)
            )
        );
    }
    test_field_initialize();
    fn test_field_finalize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataStoreKlass),
                "::",
                stringify!(finalize)
            )
        );
    }
    test_field_finalize();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataStoreKlass),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyDataStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyDataStoreKlass),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
extern "C" {
    pub fn xmlSecKeyDataStorePtrListGetKlass() -> xmlSecPtrListId;
}
pub type clock_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _timespec32 {
    pub tv_sec: __time32_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__timespec32() {
    assert_eq!(
        ::std::mem::size_of::<_timespec32>(),
        8usize,
        concat!("Size of: ", stringify!(_timespec32))
    );
    assert_eq!(
        ::std::mem::align_of::<_timespec32>(),
        4usize,
        concat!("Alignment of ", stringify!(_timespec32))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_timespec32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_timespec32),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_timespec32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_timespec32),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _timespec64 {
    pub tv_sec: __time64_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__timespec64() {
    assert_eq!(
        ::std::mem::size_of::<_timespec64>(),
        16usize,
        concat!("Size of: ", stringify!(_timespec64))
    );
    assert_eq!(
        ::std::mem::align_of::<_timespec64>(),
        8usize,
        concat!("Alignment of ", stringify!(_timespec64))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_timespec64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_timespec64),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_timespec64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_timespec64),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
extern "C" {
    pub fn __daylight() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __dstbias() -> *mut ::std::os::raw::c_long;
}
extern "C" {
    pub fn __timezone() -> *mut ::std::os::raw::c_long;
}
extern "C" {
    pub fn __tzname() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _get_daylight(_Daylight: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_dstbias(_DaylightSavingsBias: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_timezone(_TimeZone: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_tzname(
        _ReturnValue: *mut size_t,
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _Index: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn asctime(_Tm: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _Tm: *const tm,
    ) -> errno_t;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn _ctime32(_Time: *const __time32_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime32_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _ctime64(_Time: *const __time64_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime64_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _difftime32(_Time1: __time32_t, _Time2: __time32_t) -> f64;
}
extern "C" {
    pub fn _difftime64(_Time1: __time64_t, _Time2: __time64_t) -> f64;
}
extern "C" {
    pub fn _gmtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _gmtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _localtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _localtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _mkgmtime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mkgmtime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn _mktime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mktime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn strftime(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _Format: *const ::std::os::raw::c_char,
        _Tm: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn _strftime_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxSize: size_t,
        _Format: *const ::std::os::raw::c_char,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn _strdate_s(_Buffer: *mut ::std::os::raw::c_char, _SizeInBytes: size_t) -> errno_t;
}
extern "C" {
    pub fn _strdate(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strtime_s(_Buffer: *mut ::std::os::raw::c_char, _SizeInBytes: size_t) -> errno_t;
}
extern "C" {
    pub fn _strtime(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _time32(_Time: *mut __time32_t) -> __time32_t;
}
extern "C" {
    pub fn _time64(_Time: *mut __time64_t) -> __time64_t;
}
extern "C" {
    pub fn _timespec32_get(
        _Ts: *mut _timespec32,
        _Base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _timespec64_get(
        _Ts: *mut _timespec64,
        _Base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tzset();
}
extern "C" {
    pub fn _getsystime(_Tm: *mut tm) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _setsystime(
        _Tm: *mut tm,
        _Milliseconds: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn tzset();
}
#[doc = " xmlSecKeyUsage:"]
#[doc = ""]
#[doc = " The key usage."]
pub type xmlSecKeyUsage = ::std::os::raw::c_uint;
#[doc = " xmlSecKeyUseWith:"]
#[doc = " @application:        the application."]
#[doc = " @identifier:         the identifier."]
#[doc = " @reserved1:          reserved for future use."]
#[doc = " @reserved2:          reserved for future use."]
#[doc = ""]
#[doc = " Information about application and user of the key."]
pub type xmlSecKeyUseWith = _xmlSecKeyUseWith;
#[doc = " xmlSecKeyUseWith"]
#[doc = ""]
pub type xmlSecKeyUseWithPtr = *mut _xmlSecKeyUseWith;
extern "C" {
    pub fn xmlSecKeyUseWithInitialize(keyUseWith: xmlSecKeyUseWithPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyUseWithFinalize(keyUseWith: xmlSecKeyUseWithPtr);
}
extern "C" {
    pub fn xmlSecKeyUseWithReset(keyUseWith: xmlSecKeyUseWithPtr);
}
extern "C" {
    pub fn xmlSecKeyUseWithCopy(
        dst: xmlSecKeyUseWithPtr,
        src: xmlSecKeyUseWithPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyUseWithCreate(
        application: *const xmlChar,
        identifier: *const xmlChar,
    ) -> xmlSecKeyUseWithPtr;
}
extern "C" {
    pub fn xmlSecKeyUseWithDuplicate(keyUseWith: xmlSecKeyUseWithPtr) -> xmlSecKeyUseWithPtr;
}
extern "C" {
    pub fn xmlSecKeyUseWithDestroy(keyUseWith: xmlSecKeyUseWithPtr);
}
extern "C" {
    pub fn xmlSecKeyUseWithSet(
        keyUseWith: xmlSecKeyUseWithPtr,
        application: *const xmlChar,
        identifier: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyUseWithDebugDump(keyUseWith: xmlSecKeyUseWithPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecKeyUseWithDebugXmlDump(keyUseWith: xmlSecKeyUseWithPtr, output: *mut FILE);
}
#[doc = " xmlSecKeyUseWith:"]
#[doc = " @application:        the application."]
#[doc = " @identifier:         the identifier."]
#[doc = " @reserved1:          reserved for future use."]
#[doc = " @reserved2:          reserved for future use."]
#[doc = ""]
#[doc = " Information about application and user of the key."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecKeyUseWith {
    pub application: *mut xmlChar,
    pub identifier: *mut xmlChar,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub reserved2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSecKeyUseWith() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecKeyUseWith>(),
        32usize,
        concat!("Size of: ", stringify!(_xmlSecKeyUseWith))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecKeyUseWith>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecKeyUseWith))
    );
    fn test_field_application() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyUseWith>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).application) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyUseWith),
                "::",
                stringify!(application)
            )
        );
    }
    test_field_application();
    fn test_field_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyUseWith>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyUseWith),
                "::",
                stringify!(identifier)
            )
        );
    }
    test_field_identifier();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyUseWith>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyUseWith),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyUseWith>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyUseWith),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
}
extern "C" {
    pub fn xmlSecKeyUseWithPtrListGetKlass() -> xmlSecPtrListId;
}
#[doc = " xmlSecKeyReq:"]
#[doc = " @keyId:              the desired key value klass."]
#[doc = " @keyType:            the desired key type."]
#[doc = " @keyUsage:           the desired key usage."]
#[doc = " @keyBitsSize:        the desired key size (in bits!)."]
#[doc = " @keyUseWithList:     the desired key use with application/identifier information."]
#[doc = " @reserved1:          reserved for future use."]
#[doc = " @reserved2:          reserved for future use."]
#[doc = ""]
#[doc = " The key requirements information."]
pub type xmlSecKeyReq = _xmlSecKeyReq;
#[doc = " xmlSecKeyReq - what key are we looking for?"]
#[doc = ""]
pub type xmlSecKeyReqPtr = *mut _xmlSecKeyReq;
#[doc = " xmlSecKeyReq:"]
#[doc = " @keyId:              the desired key value klass."]
#[doc = " @keyType:            the desired key type."]
#[doc = " @keyUsage:           the desired key usage."]
#[doc = " @keyBitsSize:        the desired key size (in bits!)."]
#[doc = " @keyUseWithList:     the desired key use with application/identifier information."]
#[doc = " @reserved1:          reserved for future use."]
#[doc = " @reserved2:          reserved for future use."]
#[doc = ""]
#[doc = " The key requirements information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecKeyReq {
    pub keyId: xmlSecKeyDataId,
    pub keyType: xmlSecKeyDataType,
    pub keyUsage: xmlSecKeyUsage,
    pub keyBitsSize: size_t,
    pub keyUseWithList: xmlSecPtrList,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub reserved2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSecKeyReq() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecKeyReq>(),
        80usize,
        concat!("Size of: ", stringify!(_xmlSecKeyReq))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecKeyReq>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecKeyReq))
    );
    fn test_field_keyId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyId) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyReq),
                "::",
                stringify!(keyId)
            )
        );
    }
    test_field_keyId();
    fn test_field_keyType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyType) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyReq),
                "::",
                stringify!(keyType)
            )
        );
    }
    test_field_keyType();
    fn test_field_keyUsage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyUsage) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyReq),
                "::",
                stringify!(keyUsage)
            )
        );
    }
    test_field_keyUsage();
    fn test_field_keyBitsSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyBitsSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyReq),
                "::",
                stringify!(keyBitsSize)
            )
        );
    }
    test_field_keyBitsSize();
    fn test_field_keyUseWithList() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyUseWithList) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyReq),
                "::",
                stringify!(keyUseWithList)
            )
        );
    }
    test_field_keyUseWithList();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyReq),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyReq),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
}
extern "C" {
    pub fn xmlSecKeyReqInitialize(keyReq: xmlSecKeyReqPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyReqFinalize(keyReq: xmlSecKeyReqPtr);
}
extern "C" {
    pub fn xmlSecKeyReqReset(keyReq: xmlSecKeyReqPtr);
}
extern "C" {
    pub fn xmlSecKeyReqCopy(dst: xmlSecKeyReqPtr, src: xmlSecKeyReqPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyReqMatchKey(
        keyReq: xmlSecKeyReqPtr,
        key: xmlSecKeyPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyReqMatchKeyValue(
        keyReq: xmlSecKeyReqPtr,
        value: xmlSecKeyDataPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyReqDebugDump(keyReq: xmlSecKeyReqPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecKeyReqDebugXmlDump(keyReq: xmlSecKeyReqPtr, output: *mut FILE);
}
#[doc = " xmlSecKey:"]
#[doc = " @name:               the key name."]
#[doc = " @value:              the key value."]
#[doc = " @dataList:           the key data list."]
#[doc = " @usage:              the key usage."]
#[doc = " @notValidBefore:     the start key validity interval."]
#[doc = " @notValidAfter:      the end key validity interval."]
#[doc = ""]
#[doc = " The key."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecKey {
    pub name: *mut xmlChar,
    pub value: xmlSecKeyDataPtr,
    pub dataList: xmlSecPtrListPtr,
    pub usage: xmlSecKeyUsage,
    pub notValidBefore: time_t,
    pub notValidAfter: time_t,
}
#[test]
fn bindgen_test_layout__xmlSecKey() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecKey>(),
        48usize,
        concat!("Size of: ", stringify!(_xmlSecKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecKey>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecKey))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKey>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKey),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKey>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKey),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_dataList() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKey>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataList) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKey),
                "::",
                stringify!(dataList)
            )
        );
    }
    test_field_dataList();
    fn test_field_usage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKey>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKey),
                "::",
                stringify!(usage)
            )
        );
    }
    test_field_usage();
    fn test_field_notValidBefore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKey>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).notValidBefore) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKey),
                "::",
                stringify!(notValidBefore)
            )
        );
    }
    test_field_notValidBefore();
    fn test_field_notValidAfter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKey>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).notValidAfter) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKey),
                "::",
                stringify!(notValidAfter)
            )
        );
    }
    test_field_notValidAfter();
}
extern "C" {
    pub fn xmlSecKeyCreate() -> xmlSecKeyPtr;
}
extern "C" {
    pub fn xmlSecKeyDestroy(key: xmlSecKeyPtr);
}
extern "C" {
    pub fn xmlSecKeyEmpty(key: xmlSecKeyPtr);
}
extern "C" {
    pub fn xmlSecKeyDuplicate(key: xmlSecKeyPtr) -> xmlSecKeyPtr;
}
extern "C" {
    pub fn xmlSecKeyCopy(keyDst: xmlSecKeyPtr, keySrc: xmlSecKeyPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyGetName(key: xmlSecKeyPtr) -> *const xmlChar;
}
extern "C" {
    pub fn xmlSecKeySetName(key: xmlSecKeyPtr, name: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyGetType(key: xmlSecKeyPtr) -> xmlSecKeyDataType;
}
extern "C" {
    pub fn xmlSecKeyGetValue(key: xmlSecKeyPtr) -> xmlSecKeyDataPtr;
}
extern "C" {
    pub fn xmlSecKeySetValue(key: xmlSecKeyPtr, value: xmlSecKeyDataPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyGetData(key: xmlSecKeyPtr, dataId: xmlSecKeyDataId) -> xmlSecKeyDataPtr;
}
extern "C" {
    pub fn xmlSecKeyEnsureData(key: xmlSecKeyPtr, dataId: xmlSecKeyDataId) -> xmlSecKeyDataPtr;
}
extern "C" {
    pub fn xmlSecKeyAdoptData(key: xmlSecKeyPtr, data: xmlSecKeyDataPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDebugDump(key: xmlSecKeyPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecKeyDebugXmlDump(key: xmlSecKeyPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecKeyGenerate(
        dataId: xmlSecKeyDataId,
        sizeBits: size_t,
        type_: xmlSecKeyDataType,
    ) -> xmlSecKeyPtr;
}
extern "C" {
    pub fn xmlSecKeyGenerateByName(
        name: *const xmlChar,
        sizeBits: size_t,
        type_: xmlSecKeyDataType,
    ) -> xmlSecKeyPtr;
}
extern "C" {
    pub fn xmlSecKeyMatch(
        key: xmlSecKeyPtr,
        name: *const xmlChar,
        keyReq: xmlSecKeyReqPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyReadBuffer(dataId: xmlSecKeyDataId, buffer: *mut xmlSecBuffer) -> xmlSecKeyPtr;
}
extern "C" {
    pub fn xmlSecKeyReadBinaryFile(
        dataId: xmlSecKeyDataId,
        filename: *const ::std::os::raw::c_char,
    ) -> xmlSecKeyPtr;
}
extern "C" {
    pub fn xmlSecKeyReadMemory(
        dataId: xmlSecKeyDataId,
        data: *const ::std::os::raw::c_uchar,
        dataSize: size_t,
    ) -> xmlSecKeyPtr;
}
extern "C" {
    pub fn xmlSecKeyPtrListGetKlass() -> xmlSecPtrListId;
}
#[doc = " xmlXPathContext:"]
#[doc = ""]
#[doc = " Expression evaluation occurs with respect to a context."]
#[doc = " he context consists of:"]
#[doc = "    - a node (the context node)"]
#[doc = "    - a node list (the context node list)"]
#[doc = "    - a set of variable bindings"]
#[doc = "    - a function library"]
#[doc = "    - the set of namespace declarations in scope for the expression"]
#[doc = " Following the switch to hash tables, this need to be trimmed up at"]
#[doc = " the next binary incompatible release."]
#[doc = " The node may be modified when the context is passed to libxml2"]
#[doc = " for an XPath evaluation so you may need to initialize it again"]
#[doc = " before the next call."]
pub type xmlXPathContext = _xmlXPathContext;
pub type xmlXPathContextPtr = *mut xmlXPathContext;
#[doc = " xmlXPathParserContext:"]
#[doc = ""]
#[doc = " An XPath parser context. It contains pure parsing information,"]
#[doc = " an xmlXPathContext, and the stack of objects."]
pub type xmlXPathParserContext = _xmlXPathParserContext;
pub type xmlXPathParserContextPtr = *mut xmlXPathParserContext;
pub const xmlXPathError_XPATH_EXPRESSION_OK: xmlXPathError = 0;
pub const xmlXPathError_XPATH_NUMBER_ERROR: xmlXPathError = 1;
pub const xmlXPathError_XPATH_UNFINISHED_LITERAL_ERROR: xmlXPathError = 2;
pub const xmlXPathError_XPATH_START_LITERAL_ERROR: xmlXPathError = 3;
pub const xmlXPathError_XPATH_VARIABLE_REF_ERROR: xmlXPathError = 4;
pub const xmlXPathError_XPATH_UNDEF_VARIABLE_ERROR: xmlXPathError = 5;
pub const xmlXPathError_XPATH_INVALID_PREDICATE_ERROR: xmlXPathError = 6;
pub const xmlXPathError_XPATH_EXPR_ERROR: xmlXPathError = 7;
pub const xmlXPathError_XPATH_UNCLOSED_ERROR: xmlXPathError = 8;
pub const xmlXPathError_XPATH_UNKNOWN_FUNC_ERROR: xmlXPathError = 9;
pub const xmlXPathError_XPATH_INVALID_OPERAND: xmlXPathError = 10;
pub const xmlXPathError_XPATH_INVALID_TYPE: xmlXPathError = 11;
pub const xmlXPathError_XPATH_INVALID_ARITY: xmlXPathError = 12;
pub const xmlXPathError_XPATH_INVALID_CTXT_SIZE: xmlXPathError = 13;
pub const xmlXPathError_XPATH_INVALID_CTXT_POSITION: xmlXPathError = 14;
pub const xmlXPathError_XPATH_MEMORY_ERROR: xmlXPathError = 15;
pub const xmlXPathError_XPTR_SYNTAX_ERROR: xmlXPathError = 16;
pub const xmlXPathError_XPTR_RESOURCE_ERROR: xmlXPathError = 17;
pub const xmlXPathError_XPTR_SUB_RESOURCE_ERROR: xmlXPathError = 18;
pub const xmlXPathError_XPATH_UNDEF_PREFIX_ERROR: xmlXPathError = 19;
pub const xmlXPathError_XPATH_ENCODING_ERROR: xmlXPathError = 20;
pub const xmlXPathError_XPATH_INVALID_CHAR_ERROR: xmlXPathError = 21;
pub const xmlXPathError_XPATH_INVALID_CTXT: xmlXPathError = 22;
pub const xmlXPathError_XPATH_STACK_ERROR: xmlXPathError = 23;
pub const xmlXPathError_XPATH_FORBID_VARIABLE_ERROR: xmlXPathError = 24;
pub const xmlXPathError_XPATH_OP_LIMIT_EXCEEDED: xmlXPathError = 25;
pub const xmlXPathError_XPATH_RECURSION_LIMIT_EXCEEDED: xmlXPathError = 26;
#[doc = " The set of XPath error codes."]
pub type xmlXPathError = ::std::os::raw::c_int;
pub type xmlNodeSet = _xmlNodeSet;
pub type xmlNodeSetPtr = *mut xmlNodeSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlNodeSet {
    pub nodeNr: ::std::os::raw::c_int,
    pub nodeMax: ::std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
}
#[test]
fn bindgen_test_layout__xmlNodeSet() {
    assert_eq!(
        ::std::mem::size_of::<_xmlNodeSet>(),
        16usize,
        concat!("Size of: ", stringify!(_xmlNodeSet))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlNodeSet>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlNodeSet))
    );
    fn test_field_nodeNr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNodeSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeNr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNodeSet),
                "::",
                stringify!(nodeNr)
            )
        );
    }
    test_field_nodeNr();
    fn test_field_nodeMax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNodeSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeMax) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNodeSet),
                "::",
                stringify!(nodeMax)
            )
        );
    }
    test_field_nodeMax();
    fn test_field_nodeTab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlNodeSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeTab) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlNodeSet),
                "::",
                stringify!(nodeTab)
            )
        );
    }
    test_field_nodeTab();
}
pub const xmlXPathObjectType_XPATH_UNDEFINED: xmlXPathObjectType = 0;
pub const xmlXPathObjectType_XPATH_NODESET: xmlXPathObjectType = 1;
pub const xmlXPathObjectType_XPATH_BOOLEAN: xmlXPathObjectType = 2;
pub const xmlXPathObjectType_XPATH_NUMBER: xmlXPathObjectType = 3;
pub const xmlXPathObjectType_XPATH_STRING: xmlXPathObjectType = 4;
pub const xmlXPathObjectType_XPATH_POINT: xmlXPathObjectType = 5;
pub const xmlXPathObjectType_XPATH_RANGE: xmlXPathObjectType = 6;
pub const xmlXPathObjectType_XPATH_LOCATIONSET: xmlXPathObjectType = 7;
pub const xmlXPathObjectType_XPATH_USERS: xmlXPathObjectType = 8;
pub const xmlXPathObjectType_XPATH_XSLT_TREE: xmlXPathObjectType = 9;
pub type xmlXPathObjectType = ::std::os::raw::c_int;
pub type xmlXPathObject = _xmlXPathObject;
pub type xmlXPathObjectPtr = *mut xmlXPathObject;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathObject {
    pub type_: xmlXPathObjectType,
    pub nodesetval: xmlNodeSetPtr,
    pub boolval: ::std::os::raw::c_int,
    pub floatval: f64,
    pub stringval: *mut xmlChar,
    pub user: *mut ::std::os::raw::c_void,
    pub index: ::std::os::raw::c_int,
    pub user2: *mut ::std::os::raw::c_void,
    pub index2: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlXPathObject() {
    assert_eq!(
        ::std::mem::size_of::<_xmlXPathObject>(),
        72usize,
        concat!("Size of: ", stringify!(_xmlXPathObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlXPathObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlXPathObject))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathObject),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_nodesetval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodesetval) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathObject),
                "::",
                stringify!(nodesetval)
            )
        );
    }
    test_field_nodesetval();
    fn test_field_boolval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).boolval) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathObject),
                "::",
                stringify!(boolval)
            )
        );
    }
    test_field_boolval();
    fn test_field_floatval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).floatval) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathObject),
                "::",
                stringify!(floatval)
            )
        );
    }
    test_field_floatval();
    fn test_field_stringval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stringval) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathObject),
                "::",
                stringify!(stringval)
            )
        );
    }
    test_field_stringval();
    fn test_field_user() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathObject),
                "::",
                stringify!(user)
            )
        );
    }
    test_field_user();
    fn test_field_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathObject),
                "::",
                stringify!(index)
            )
        );
    }
    test_field_index();
    fn test_field_user2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user2) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathObject),
                "::",
                stringify!(user2)
            )
        );
    }
    test_field_user2();
    fn test_field_index2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).index2) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathObject),
                "::",
                stringify!(index2)
            )
        );
    }
    test_field_index2();
}
#[doc = " xmlXPathConvertFunc:"]
#[doc = " @obj:  an XPath object"]
#[doc = " @type:  the number of the target type"]
#[doc = ""]
#[doc = " A conversion function is associated to a type and used to cast"]
#[doc = " the new type to primitive values."]
#[doc = ""]
#[doc = " Returns -1 in case of error, 0 otherwise"]
pub type xmlXPathConvertFunc = ::std::option::Option<
    unsafe extern "C" fn(
        obj: xmlXPathObjectPtr,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type xmlXPathType = _xmlXPathType;
pub type xmlXPathTypePtr = *mut xmlXPathType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathType {
    pub name: *const xmlChar,
    pub func: xmlXPathConvertFunc,
}
#[test]
fn bindgen_test_layout__xmlXPathType() {
    assert_eq!(
        ::std::mem::size_of::<_xmlXPathType>(),
        16usize,
        concat!("Size of: ", stringify!(_xmlXPathType))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlXPathType>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlXPathType))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathType>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathType),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathType>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathType),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
}
pub type xmlXPathVariable = _xmlXPathVariable;
pub type xmlXPathVariablePtr = *mut xmlXPathVariable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathVariable {
    pub name: *const xmlChar,
    pub value: xmlXPathObjectPtr,
}
#[test]
fn bindgen_test_layout__xmlXPathVariable() {
    assert_eq!(
        ::std::mem::size_of::<_xmlXPathVariable>(),
        16usize,
        concat!("Size of: ", stringify!(_xmlXPathVariable))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlXPathVariable>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlXPathVariable))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathVariable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathVariable),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathVariable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathVariable),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[doc = " xmlXPathEvalFunc:"]
#[doc = " @ctxt: an XPath parser context"]
#[doc = " @nargs: the number of arguments passed to the function"]
#[doc = ""]
#[doc = " An XPath evaluation function, the parameters are on the XPath context stack."]
pub type xmlXPathEvalFunc = ::std::option::Option<
    unsafe extern "C" fn(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int),
>;
pub type xmlXPathFunct = _xmlXPathFunct;
pub type xmlXPathFuncPtr = *mut xmlXPathFunct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathFunct {
    pub name: *const xmlChar,
    pub func: xmlXPathEvalFunc,
}
#[test]
fn bindgen_test_layout__xmlXPathFunct() {
    assert_eq!(
        ::std::mem::size_of::<_xmlXPathFunct>(),
        16usize,
        concat!("Size of: ", stringify!(_xmlXPathFunct))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlXPathFunct>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlXPathFunct))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathFunct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathFunct),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathFunct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathFunct),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
}
#[doc = " xmlXPathAxisFunc:"]
#[doc = " @ctxt:  the XPath interpreter context"]
#[doc = " @cur:  the previous node being explored on that axis"]
#[doc = ""]
#[doc = " An axis traversal function. To traverse an axis, the engine calls"]
#[doc = " the first time with cur == NULL and repeat until the function returns"]
#[doc = " NULL indicating the end of the axis traversal."]
#[doc = ""]
#[doc = " Returns the next node in that axis or NULL if at the end of the axis."]
pub type xmlXPathAxisFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: xmlXPathParserContextPtr,
        cur: xmlXPathObjectPtr,
    ) -> xmlXPathObjectPtr,
>;
pub type xmlXPathAxis = _xmlXPathAxis;
pub type xmlXPathAxisPtr = *mut xmlXPathAxis;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathAxis {
    pub name: *const xmlChar,
    pub func: xmlXPathAxisFunc,
}
#[test]
fn bindgen_test_layout__xmlXPathAxis() {
    assert_eq!(
        ::std::mem::size_of::<_xmlXPathAxis>(),
        16usize,
        concat!("Size of: ", stringify!(_xmlXPathAxis))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlXPathAxis>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlXPathAxis))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathAxis>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathAxis),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathAxis>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathAxis),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
}
#[doc = " xmlXPathFunction:"]
#[doc = " @ctxt:  the XPath interprestation context"]
#[doc = " @nargs:  the number of arguments"]
#[doc = ""]
#[doc = " An XPath function."]
#[doc = " The arguments (if any) are popped out from the context stack"]
#[doc = " and the result is pushed on the stack."]
pub type xmlXPathFunction = ::std::option::Option<
    unsafe extern "C" fn(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int),
>;
#[doc = " xmlXPathVariableLookupFunc:"]
#[doc = " @ctxt:  an XPath context"]
#[doc = " @name:  name of the variable"]
#[doc = " @ns_uri:  the namespace name hosting this variable"]
#[doc = ""]
#[doc = " Prototype for callbacks used to plug variable lookup in the XPath"]
#[doc = " engine."]
#[doc = ""]
#[doc = " Returns the XPath object value or NULL if not found."]
pub type xmlXPathVariableLookupFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        ns_uri: *const xmlChar,
    ) -> xmlXPathObjectPtr,
>;
#[doc = " xmlXPathFuncLookupFunc:"]
#[doc = " @ctxt:  an XPath context"]
#[doc = " @name:  name of the function"]
#[doc = " @ns_uri:  the namespace name hosting this function"]
#[doc = ""]
#[doc = " Prototype for callbacks used to plug function lookup in the XPath"]
#[doc = " engine."]
#[doc = ""]
#[doc = " Returns the XPath function or NULL if not found."]
pub type xmlXPathFuncLookupFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: *mut ::std::os::raw::c_void,
        name: *const xmlChar,
        ns_uri: *const xmlChar,
    ) -> xmlXPathFunction,
>;
#[doc = " xmlXPathContext:"]
#[doc = ""]
#[doc = " Expression evaluation occurs with respect to a context."]
#[doc = " he context consists of:"]
#[doc = "    - a node (the context node)"]
#[doc = "    - a node list (the context node list)"]
#[doc = "    - a set of variable bindings"]
#[doc = "    - a function library"]
#[doc = "    - the set of namespace declarations in scope for the expression"]
#[doc = " Following the switch to hash tables, this need to be trimmed up at"]
#[doc = " the next binary incompatible release."]
#[doc = " The node may be modified when the context is passed to libxml2"]
#[doc = " for an XPath evaluation so you may need to initialize it again"]
#[doc = " before the next call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathContext {
    pub doc: xmlDocPtr,
    pub node: xmlNodePtr,
    pub nb_variables_unused: ::std::os::raw::c_int,
    pub max_variables_unused: ::std::os::raw::c_int,
    pub varHash: xmlHashTablePtr,
    pub nb_types: ::std::os::raw::c_int,
    pub max_types: ::std::os::raw::c_int,
    pub types: xmlXPathTypePtr,
    pub nb_funcs_unused: ::std::os::raw::c_int,
    pub max_funcs_unused: ::std::os::raw::c_int,
    pub funcHash: xmlHashTablePtr,
    pub nb_axis: ::std::os::raw::c_int,
    pub max_axis: ::std::os::raw::c_int,
    pub axis: xmlXPathAxisPtr,
    pub namespaces: *mut xmlNsPtr,
    pub nsNr: ::std::os::raw::c_int,
    pub user: *mut ::std::os::raw::c_void,
    pub contextSize: ::std::os::raw::c_int,
    pub proximityPosition: ::std::os::raw::c_int,
    pub xptr: ::std::os::raw::c_int,
    pub here: xmlNodePtr,
    pub origin: xmlNodePtr,
    pub nsHash: xmlHashTablePtr,
    pub varLookupFunc: xmlXPathVariableLookupFunc,
    pub varLookupData: *mut ::std::os::raw::c_void,
    pub extra: *mut ::std::os::raw::c_void,
    pub function: *const xmlChar,
    pub functionURI: *const xmlChar,
    pub funcLookupFunc: xmlXPathFuncLookupFunc,
    pub funcLookupData: *mut ::std::os::raw::c_void,
    pub tmpNsList: *mut xmlNsPtr,
    pub tmpNsNr: ::std::os::raw::c_int,
    pub userData: *mut ::std::os::raw::c_void,
    pub error: xmlStructuredErrorFunc,
    pub lastError: xmlError,
    pub debugNode: xmlNodePtr,
    pub dict: xmlDictPtr,
    pub flags: ::std::os::raw::c_int,
    pub cache: *mut ::std::os::raw::c_void,
    pub opLimit: ::std::os::raw::c_ulong,
    pub opCount: ::std::os::raw::c_ulong,
    pub depth: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlXPathContext() {
    assert_eq!(
        ::std::mem::size_of::<_xmlXPathContext>(),
        368usize,
        concat!("Size of: ", stringify!(_xmlXPathContext))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlXPathContext>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlXPathContext))
    );
    fn test_field_doc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(doc)
            )
        );
    }
    test_field_doc();
    fn test_field_node() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(node)
            )
        );
    }
    test_field_node();
    fn test_field_nb_variables_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nb_variables_unused) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(nb_variables_unused)
            )
        );
    }
    test_field_nb_variables_unused();
    fn test_field_max_variables_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_variables_unused) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(max_variables_unused)
            )
        );
    }
    test_field_max_variables_unused();
    fn test_field_varHash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).varHash) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(varHash)
            )
        );
    }
    test_field_varHash();
    fn test_field_nb_types() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nb_types) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(nb_types)
            )
        );
    }
    test_field_nb_types();
    fn test_field_max_types() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_types) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(max_types)
            )
        );
    }
    test_field_max_types();
    fn test_field_types() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).types) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(types)
            )
        );
    }
    test_field_types();
    fn test_field_nb_funcs_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nb_funcs_unused) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(nb_funcs_unused)
            )
        );
    }
    test_field_nb_funcs_unused();
    fn test_field_max_funcs_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_funcs_unused) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(max_funcs_unused)
            )
        );
    }
    test_field_max_funcs_unused();
    fn test_field_funcHash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).funcHash) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(funcHash)
            )
        );
    }
    test_field_funcHash();
    fn test_field_nb_axis() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nb_axis) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(nb_axis)
            )
        );
    }
    test_field_nb_axis();
    fn test_field_max_axis() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_axis) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(max_axis)
            )
        );
    }
    test_field_max_axis();
    fn test_field_axis() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).axis) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(axis)
            )
        );
    }
    test_field_axis();
    fn test_field_namespaces() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).namespaces) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(namespaces)
            )
        );
    }
    test_field_namespaces();
    fn test_field_nsNr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsNr) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(nsNr)
            )
        );
    }
    test_field_nsNr();
    fn test_field_user() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(user)
            )
        );
    }
    test_field_user();
    fn test_field_contextSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).contextSize) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(contextSize)
            )
        );
    }
    test_field_contextSize();
    fn test_field_proximityPosition() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proximityPosition) as usize - ptr as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(proximityPosition)
            )
        );
    }
    test_field_proximityPosition();
    fn test_field_xptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xptr) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(xptr)
            )
        );
    }
    test_field_xptr();
    fn test_field_here() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).here) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(here)
            )
        );
    }
    test_field_here();
    fn test_field_origin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).origin) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(origin)
            )
        );
    }
    test_field_origin();
    fn test_field_nsHash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsHash) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(nsHash)
            )
        );
    }
    test_field_nsHash();
    fn test_field_varLookupFunc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).varLookupFunc) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(varLookupFunc)
            )
        );
    }
    test_field_varLookupFunc();
    fn test_field_varLookupData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).varLookupData) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(varLookupData)
            )
        );
    }
    test_field_varLookupData();
    fn test_field_extra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(extra)
            )
        );
    }
    test_field_extra();
    fn test_field_function() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(function)
            )
        );
    }
    test_field_function();
    fn test_field_functionURI() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).functionURI) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(functionURI)
            )
        );
    }
    test_field_functionURI();
    fn test_field_funcLookupFunc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).funcLookupFunc) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(funcLookupFunc)
            )
        );
    }
    test_field_funcLookupFunc();
    fn test_field_funcLookupData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).funcLookupData) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(funcLookupData)
            )
        );
    }
    test_field_funcLookupData();
    fn test_field_tmpNsList() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tmpNsList) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(tmpNsList)
            )
        );
    }
    test_field_tmpNsList();
    fn test_field_tmpNsNr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tmpNsNr) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(tmpNsNr)
            )
        );
    }
    test_field_tmpNsNr();
    fn test_field_userData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userData) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(userData)
            )
        );
    }
    test_field_userData();
    fn test_field_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(error)
            )
        );
    }
    test_field_error();
    fn test_field_lastError() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastError) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(lastError)
            )
        );
    }
    test_field_lastError();
    fn test_field_debugNode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).debugNode) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(debugNode)
            )
        );
    }
    test_field_debugNode();
    fn test_field_dict() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(dict)
            )
        );
    }
    test_field_dict();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_cache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cache) as usize - ptr as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(cache)
            )
        );
    }
    test_field_cache();
    fn test_field_opLimit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opLimit) as usize - ptr as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(opLimit)
            )
        );
    }
    test_field_opLimit();
    fn test_field_opCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opCount) as usize - ptr as usize
            },
            356usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(opCount)
            )
        );
    }
    test_field_opCount();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathContext),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathCompExpr {
    _unused: [u8; 0],
}
pub type xmlXPathCompExpr = _xmlXPathCompExpr;
pub type xmlXPathCompExprPtr = *mut xmlXPathCompExpr;
#[doc = " xmlXPathParserContext:"]
#[doc = ""]
#[doc = " An XPath parser context. It contains pure parsing information,"]
#[doc = " an xmlXPathContext, and the stack of objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathParserContext {
    pub cur: *const xmlChar,
    pub base: *const xmlChar,
    pub error: ::std::os::raw::c_int,
    pub context: xmlXPathContextPtr,
    pub value: xmlXPathObjectPtr,
    pub valueNr: ::std::os::raw::c_int,
    pub valueMax: ::std::os::raw::c_int,
    pub valueTab: *mut xmlXPathObjectPtr,
    pub comp: xmlXPathCompExprPtr,
    pub xptr: ::std::os::raw::c_int,
    pub ancestor: xmlNodePtr,
    pub valueFrame: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlXPathParserContext() {
    assert_eq!(
        ::std::mem::size_of::<_xmlXPathParserContext>(),
        88usize,
        concat!("Size of: ", stringify!(_xmlXPathParserContext))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlXPathParserContext>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlXPathParserContext))
    );
    fn test_field_cur() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathParserContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cur) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathParserContext),
                "::",
                stringify!(cur)
            )
        );
    }
    test_field_cur();
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathParserContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathParserContext),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathParserContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathParserContext),
                "::",
                stringify!(error)
            )
        );
    }
    test_field_error();
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathParserContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathParserContext),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathParserContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathParserContext),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_valueNr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathParserContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).valueNr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathParserContext),
                "::",
                stringify!(valueNr)
            )
        );
    }
    test_field_valueNr();
    fn test_field_valueMax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathParserContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).valueMax) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathParserContext),
                "::",
                stringify!(valueMax)
            )
        );
    }
    test_field_valueMax();
    fn test_field_valueTab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathParserContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).valueTab) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathParserContext),
                "::",
                stringify!(valueTab)
            )
        );
    }
    test_field_valueTab();
    fn test_field_comp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathParserContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).comp) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathParserContext),
                "::",
                stringify!(comp)
            )
        );
    }
    test_field_comp();
    fn test_field_xptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathParserContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xptr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathParserContext),
                "::",
                stringify!(xptr)
            )
        );
    }
    test_field_xptr();
    fn test_field_ancestor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathParserContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ancestor) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathParserContext),
                "::",
                stringify!(ancestor)
            )
        );
    }
    test_field_ancestor();
    fn test_field_valueFrame() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlXPathParserContext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).valueFrame) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlXPathParserContext),
                "::",
                stringify!(valueFrame)
            )
        );
    }
    test_field_valueFrame();
}
extern "C" {
    #[doc = " Objects and Nodesets handling"]
    pub static mut xmlXPathNAN: f64;
}
extern "C" {
    pub static mut xmlXPathPINF: f64;
}
extern "C" {
    pub static mut xmlXPathNINF: f64;
}
extern "C" {
    pub fn xmlXPathFreeObject(obj: xmlXPathObjectPtr);
}
extern "C" {
    pub fn xmlXPathNodeSetCreate(val: xmlNodePtr) -> xmlNodeSetPtr;
}
extern "C" {
    pub fn xmlXPathFreeNodeSetList(obj: xmlXPathObjectPtr);
}
extern "C" {
    pub fn xmlXPathFreeNodeSet(obj: xmlNodeSetPtr);
}
extern "C" {
    pub fn xmlXPathObjectCopy(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
}
extern "C" {
    pub fn xmlXPathCmpNodes(node1: xmlNodePtr, node2: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Conversion functions to basic types."]
    pub fn xmlXPathCastNumberToBoolean(val: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlXPathCastStringToBoolean(val: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlXPathCastNodeSetToBoolean(ns: xmlNodeSetPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlXPathCastToBoolean(val: xmlXPathObjectPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlXPathCastBooleanToNumber(val: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn xmlXPathCastStringToNumber(val: *const xmlChar) -> f64;
}
extern "C" {
    pub fn xmlXPathCastNodeToNumber(node: xmlNodePtr) -> f64;
}
extern "C" {
    pub fn xmlXPathCastNodeSetToNumber(ns: xmlNodeSetPtr) -> f64;
}
extern "C" {
    pub fn xmlXPathCastToNumber(val: xmlXPathObjectPtr) -> f64;
}
extern "C" {
    pub fn xmlXPathCastBooleanToString(val: ::std::os::raw::c_int) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlXPathCastNumberToString(val: f64) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlXPathCastNodeToString(node: xmlNodePtr) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlXPathCastNodeSetToString(ns: xmlNodeSetPtr) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlXPathCastToString(val: xmlXPathObjectPtr) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlXPathConvertBoolean(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
}
extern "C" {
    pub fn xmlXPathConvertNumber(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
}
extern "C" {
    pub fn xmlXPathConvertString(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
}
extern "C" {
    #[doc = " Context handling."]
    pub fn xmlXPathNewContext(doc: xmlDocPtr) -> xmlXPathContextPtr;
}
extern "C" {
    pub fn xmlXPathFreeContext(ctxt: xmlXPathContextPtr);
}
extern "C" {
    pub fn xmlXPathContextSetCache(
        ctxt: xmlXPathContextPtr,
        active: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Evaluation functions."]
    pub fn xmlXPathOrderDocElems(doc: xmlDocPtr) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn xmlXPathSetContextNode(
        node: xmlNodePtr,
        ctx: xmlXPathContextPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlXPathNodeEval(
        node: xmlNodePtr,
        str_: *const xmlChar,
        ctx: xmlXPathContextPtr,
    ) -> xmlXPathObjectPtr;
}
extern "C" {
    pub fn xmlXPathEval(str_: *const xmlChar, ctx: xmlXPathContextPtr) -> xmlXPathObjectPtr;
}
extern "C" {
    pub fn xmlXPathEvalExpression(
        str_: *const xmlChar,
        ctxt: xmlXPathContextPtr,
    ) -> xmlXPathObjectPtr;
}
extern "C" {
    pub fn xmlXPathEvalPredicate(
        ctxt: xmlXPathContextPtr,
        res: xmlXPathObjectPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Separate compilation/evaluation entry points."]
    pub fn xmlXPathCompile(str_: *const xmlChar) -> xmlXPathCompExprPtr;
}
extern "C" {
    pub fn xmlXPathCtxtCompile(
        ctxt: xmlXPathContextPtr,
        str_: *const xmlChar,
    ) -> xmlXPathCompExprPtr;
}
extern "C" {
    pub fn xmlXPathCompiledEval(
        comp: xmlXPathCompExprPtr,
        ctx: xmlXPathContextPtr,
    ) -> xmlXPathObjectPtr;
}
extern "C" {
    pub fn xmlXPathCompiledEvalToBoolean(
        comp: xmlXPathCompExprPtr,
        ctxt: xmlXPathContextPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlXPathFreeCompExpr(comp: xmlXPathCompExprPtr);
}
extern "C" {
    pub fn xmlXPathInit();
}
extern "C" {
    pub fn xmlXPathIsNaN(val: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlXPathIsInf(val: f64) -> ::std::os::raw::c_int;
}
#[doc = " xmlSecNodeSet:"]
#[doc = " @nodes:                      the nodes list."]
#[doc = " @doc:                        the parent XML document."]
#[doc = " @destroyDoc:                 the flag: if set to 1 then @doc will"]
#[doc = "                              be destroyed when node set is destroyed."]
#[doc = " @type:                       the nodes set type."]
#[doc = " @op:                         the operation type."]
#[doc = " @next:                       the next nodes set."]
#[doc = " @prev:                       the previous nodes set."]
#[doc = " @children:                   the children list (valid only if type"]
#[doc = "                              equal to #xmlSecNodeSetList)."]
#[doc = ""]
#[doc = " The enchanced nodes set."]
pub type xmlSecNodeSet = _xmlSecNodeSet;
pub type xmlSecNodeSetPtr = *mut _xmlSecNodeSet;
pub const xmlSecNodeSetType_xmlSecNodeSetNormal: xmlSecNodeSetType = 0;
pub const xmlSecNodeSetType_xmlSecNodeSetInvert: xmlSecNodeSetType = 1;
pub const xmlSecNodeSetType_xmlSecNodeSetTree: xmlSecNodeSetType = 2;
pub const xmlSecNodeSetType_xmlSecNodeSetTreeWithoutComments: xmlSecNodeSetType = 3;
pub const xmlSecNodeSetType_xmlSecNodeSetTreeInvert: xmlSecNodeSetType = 4;
pub const xmlSecNodeSetType_xmlSecNodeSetTreeWithoutCommentsInvert: xmlSecNodeSetType = 5;
pub const xmlSecNodeSetType_xmlSecNodeSetList: xmlSecNodeSetType = 6;
#[doc = " xmlSecNodeSetType:"]
#[doc = " @xmlSecNodeSetNormal:        nodes set = nodes in the list."]
#[doc = " @xmlSecNodeSetInvert:        nodes set = all document nodes minus nodes in the list."]
#[doc = " @xmlSecNodeSetTree:          nodes set = nodes in the list and all their subtress."]
#[doc = " @xmlSecNodeSetTreeWithoutComments:           nodes set = nodes in the list and"]
#[doc = "                              all their subtress but no comment nodes."]
#[doc = " @xmlSecNodeSetTreeInvert:    nodes set = all document nodes minus nodes in the"]
#[doc = "                              list and all their subtress."]
#[doc = " @xmlSecNodeSetTreeWithoutCommentsInvert:     nodes set = all document nodes"]
#[doc = "                              minus (nodes in the list and all their subtress"]
#[doc = "                              plus all comment nodes)."]
#[doc = " @xmlSecNodeSetList:          nodes set = all nodes in the children list of nodes sets."]
#[doc = ""]
#[doc = " The basic nodes sets types."]
pub type xmlSecNodeSetType = ::std::os::raw::c_int;
pub const xmlSecNodeSetOp_xmlSecNodeSetIntersection: xmlSecNodeSetOp = 0;
pub const xmlSecNodeSetOp_xmlSecNodeSetSubtraction: xmlSecNodeSetOp = 1;
pub const xmlSecNodeSetOp_xmlSecNodeSetUnion: xmlSecNodeSetOp = 2;
#[doc = " xmlSecNodeSetOp:"]
#[doc = " @xmlSecNodeSetIntersection:  intersection."]
#[doc = " @xmlSecNodeSetSubtraction:   subtraction."]
#[doc = " @xmlSecNodeSetUnion:         union."]
#[doc = ""]
#[doc = " The simple nodes sets operations."]
pub type xmlSecNodeSetOp = ::std::os::raw::c_int;
#[doc = " xmlSecNodeSet:"]
#[doc = " @nodes:                      the nodes list."]
#[doc = " @doc:                        the parent XML document."]
#[doc = " @destroyDoc:                 the flag: if set to 1 then @doc will"]
#[doc = "                              be destroyed when node set is destroyed."]
#[doc = " @type:                       the nodes set type."]
#[doc = " @op:                         the operation type."]
#[doc = " @next:                       the next nodes set."]
#[doc = " @prev:                       the previous nodes set."]
#[doc = " @children:                   the children list (valid only if type"]
#[doc = "                              equal to #xmlSecNodeSetList)."]
#[doc = ""]
#[doc = " The enchanced nodes set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecNodeSet {
    pub nodes: xmlNodeSetPtr,
    pub doc: xmlDocPtr,
    pub destroyDoc: ::std::os::raw::c_int,
    pub type_: xmlSecNodeSetType,
    pub op: xmlSecNodeSetOp,
    pub next: xmlSecNodeSetPtr,
    pub prev: xmlSecNodeSetPtr,
    pub children: xmlSecNodeSetPtr,
}
#[test]
fn bindgen_test_layout__xmlSecNodeSet() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecNodeSet>(),
        56usize,
        concat!("Size of: ", stringify!(_xmlSecNodeSet))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecNodeSet>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecNodeSet))
    );
    fn test_field_nodes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecNodeSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodes) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecNodeSet),
                "::",
                stringify!(nodes)
            )
        );
    }
    test_field_nodes();
    fn test_field_doc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecNodeSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecNodeSet),
                "::",
                stringify!(doc)
            )
        );
    }
    test_field_doc();
    fn test_field_destroyDoc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecNodeSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destroyDoc) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecNodeSet),
                "::",
                stringify!(destroyDoc)
            )
        );
    }
    test_field_destroyDoc();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecNodeSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecNodeSet),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_op() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecNodeSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).op) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecNodeSet),
                "::",
                stringify!(op)
            )
        );
    }
    test_field_op();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecNodeSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecNodeSet),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecNodeSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecNodeSet),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_children() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecNodeSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecNodeSet),
                "::",
                stringify!(children)
            )
        );
    }
    test_field_children();
}
#[doc = " xmlSecNodeSetWalkCallback:"]
#[doc = " @nset:                       the pointer to #xmlSecNodeSet structure."]
#[doc = " @cur:                        the pointer current XML node."]
#[doc = " @parent:                     the pointer to the @cur parent node."]
#[doc = " @data:                       the pointer to application specific data."]
#[doc = ""]
#[doc = " The callback function called once per each node in the nodes set."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value if an error occurs"]
#[doc = " an walk procedure should be interrupted."]
pub type xmlSecNodeSetWalkCallback = ::std::option::Option<
    unsafe extern "C" fn(
        nset: xmlSecNodeSetPtr,
        cur: xmlNodePtr,
        parent: xmlNodePtr,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn xmlSecNodeSetCreate(
        doc: xmlDocPtr,
        nodes: xmlNodeSetPtr,
        type_: xmlSecNodeSetType,
    ) -> xmlSecNodeSetPtr;
}
extern "C" {
    pub fn xmlSecNodeSetDestroy(nset: xmlSecNodeSetPtr);
}
extern "C" {
    pub fn xmlSecNodeSetDocDestroy(nset: xmlSecNodeSetPtr);
}
extern "C" {
    pub fn xmlSecNodeSetContains(
        nset: xmlSecNodeSetPtr,
        node: xmlNodePtr,
        parent: xmlNodePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecNodeSetAdd(
        nset: xmlSecNodeSetPtr,
        newNSet: xmlSecNodeSetPtr,
        op: xmlSecNodeSetOp,
    ) -> xmlSecNodeSetPtr;
}
extern "C" {
    pub fn xmlSecNodeSetAddList(
        nset: xmlSecNodeSetPtr,
        newNSet: xmlSecNodeSetPtr,
        op: xmlSecNodeSetOp,
    ) -> xmlSecNodeSetPtr;
}
extern "C" {
    pub fn xmlSecNodeSetGetChildren(
        doc: xmlDocPtr,
        parent: xmlNodePtr,
        withComments: ::std::os::raw::c_int,
        invert: ::std::os::raw::c_int,
    ) -> xmlSecNodeSetPtr;
}
extern "C" {
    pub fn xmlSecNodeSetWalk(
        nset: xmlSecNodeSetPtr,
        walkFunc: xmlSecNodeSetWalkCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecNodeSetDumpTextNodes(
        nset: xmlSecNodeSetPtr,
        out: xmlOutputBufferPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecNodeSetDebugDump(nset: xmlSecNodeSetPtr, output: *mut FILE);
}
#[doc = " xmlSecTransformKlass:"]
#[doc = " @klassSize:                  the transform klass structure size."]
#[doc = " @objSize:                    the transform object size."]
#[doc = " @name:                       the transform's name."]
#[doc = " @href:                       the transform's identification string (href)."]
#[doc = " @usage:                      the allowed transforms usages."]
#[doc = " @initialize:                 the initialization method."]
#[doc = " @finalize:                   the finalization (destroy) function."]
#[doc = " @readNode:                   the XML node read method."]
#[doc = " @writeNode:                  the XML node write method."]
#[doc = " @setKeyReq:                  the set key requirements method."]
#[doc = " @setKey:                     the set key method."]
#[doc = " @verify:                     the verify method (for digest and signature transforms)."]
#[doc = " @getDataType:                the input/output data type query method."]
#[doc = " @pushBin:                    the binary data \"push thru chain\" processing method."]
#[doc = " @popBin:                     the binary data \"pop from chain\" procesing method."]
#[doc = " @pushXml:                    the XML data \"push thru chain\" processing method."]
#[doc = " @popXml:                     the XML data \"pop from chain\" procesing method."]
#[doc = " @execute:                    the low level data processing method used  by default"]
#[doc = "                              implementations of @pushBin, @popBin, @pushXml and @popXml."]
#[doc = " @reserved0:                  reserved for the future."]
#[doc = " @reserved1:                  reserved for the future."]
#[doc = ""]
#[doc = " The transform klass description structure."]
pub type xmlSecTransformKlass = _xmlSecTransformKlass;
pub type xmlSecTransformId = *const _xmlSecTransformKlass;
extern "C" {
    #[doc = " High-level functions"]
    #[doc = ""]
    pub fn xmlSecTransformIdsGet() -> xmlSecPtrListPtr;
}
extern "C" {
    pub fn xmlSecTransformIdsInit() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformIdsShutdown();
}
extern "C" {
    pub fn xmlSecTransformIdsRegisterDefault() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformIdsRegister(id: xmlSecTransformId) -> ::std::os::raw::c_int;
}
pub const xmlSecTransformStatus_xmlSecTransformStatusNone: xmlSecTransformStatus = 0;
pub const xmlSecTransformStatus_xmlSecTransformStatusWorking: xmlSecTransformStatus = 1;
pub const xmlSecTransformStatus_xmlSecTransformStatusFinished: xmlSecTransformStatus = 2;
pub const xmlSecTransformStatus_xmlSecTransformStatusOk: xmlSecTransformStatus = 3;
pub const xmlSecTransformStatus_xmlSecTransformStatusFail: xmlSecTransformStatus = 4;
#[doc = " xmlSecTransformStatus:"]
#[doc = " @xmlSecTransformStatusNone:          the status unknown."]
#[doc = " @xmlSecTransformStatusWorking:       the transform is executed."]
#[doc = " @xmlSecTransformStatusFinished:      the transform finished"]
#[doc = " @xmlSecTransformStatusOk:            the transform succeeded."]
#[doc = " @xmlSecTransformStatusFail:          the transform failed (an error occur)."]
#[doc = ""]
#[doc = " The transform execution status."]
pub type xmlSecTransformStatus = ::std::os::raw::c_int;
pub const xmlSecTransformMode_xmlSecTransformModeNone: xmlSecTransformMode = 0;
pub const xmlSecTransformMode_xmlSecTransformModePush: xmlSecTransformMode = 1;
pub const xmlSecTransformMode_xmlSecTransformModePop: xmlSecTransformMode = 2;
#[doc = " xmlSecTransformMode:"]
#[doc = " @xmlSecTransformModeNone:            the mode is unknown."]
#[doc = " @xmlSecTransformModePush:            pushing data thru transform."]
#[doc = " @xmlSecTransformModePop:             popping data from transform."]
#[doc = ""]
#[doc = " The transform operation mode"]
pub type xmlSecTransformMode = ::std::os::raw::c_int;
pub const xmlSecTransformOperation_xmlSecTransformOperationNone: xmlSecTransformOperation = 0;
pub const xmlSecTransformOperation_xmlSecTransformOperationEncode: xmlSecTransformOperation = 1;
pub const xmlSecTransformOperation_xmlSecTransformOperationDecode: xmlSecTransformOperation = 2;
pub const xmlSecTransformOperation_xmlSecTransformOperationSign: xmlSecTransformOperation = 3;
pub const xmlSecTransformOperation_xmlSecTransformOperationVerify: xmlSecTransformOperation = 4;
pub const xmlSecTransformOperation_xmlSecTransformOperationEncrypt: xmlSecTransformOperation = 5;
pub const xmlSecTransformOperation_xmlSecTransformOperationDecrypt: xmlSecTransformOperation = 6;
#[doc = " xmlSecTransformOperation:"]
#[doc = " @xmlSecTransformOperationNone:       the operation is unknown."]
#[doc = " @xmlSecTransformOperationEncode:     the encode operation (for base64 transform)."]
#[doc = " @xmlSecTransformOperationDecode:     the decode operation (for base64 transform)."]
#[doc = " @xmlSecTransformOperationSign:       the sign or digest operation."]
#[doc = " @xmlSecTransformOperationVerify:     the verification of signature or digest operation."]
#[doc = " @xmlSecTransformOperationEncrypt:    the encryption operation."]
#[doc = " @xmlSecTransformOperationDecrypt:    the decryption operation."]
#[doc = ""]
#[doc = " The transform operation."]
pub type xmlSecTransformOperation = ::std::os::raw::c_int;
#[doc = " xmlSecTransformUriType:"]
#[doc = ""]
#[doc = " xmlSecTransformUriType:"]
#[doc = ""]
#[doc = " URI transform type bit mask."]
pub type xmlSecTransformUriType = ::std::os::raw::c_uint;
extern "C" {
    pub fn xmlSecTransformUriTypeCheck(
        type_: xmlSecTransformUriType,
        uri: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
#[doc = " xmlSecTransformDataType"]
#[doc = ""]
#[doc = " xmlSecTransformDataType:"]
#[doc = ""]
#[doc = " Transform data type bit mask."]
pub type xmlSecTransformDataType = ::std::os::raw::c_uchar;
#[doc = " xmlSecTransformUsage"]
#[doc = ""]
#[doc = " xmlSecTransformUsage:"]
#[doc = ""]
#[doc = " The transform usage bit mask."]
pub type xmlSecTransformUsage = ::std::os::raw::c_uint;
#[doc = " xmlSecTransformCtx"]
#[doc = ""]
#[doc = " xmlSecTransformCtxPreExecuteCallback:"]
#[doc = " @transformCtx:       the pointer to transform's context."]
#[doc = ""]
#[doc = " The callback called after creating transforms chain but before"]
#[doc = " starting data processing. Application can use this callback to"]
#[doc = " do additional transforms chain verification or modification and"]
#[doc = " aborting transforms execution (if necessary)."]
#[doc = ""]
#[doc = " Returns: 0 on success and a negative value otherwise (in this case,"]
#[doc = " transforms chain will not be executed and xmlsec processing stops)."]
pub type xmlSecTransformCtxPreExecuteCallback = ::std::option::Option<
    unsafe extern "C" fn(transformCtx: xmlSecTransformCtxPtr) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecTransformCtx:"]
#[doc = " @userData:           the pointer to user data (xmlsec and xmlsec-crypto never"]
#[doc = "                      touch this)."]
#[doc = " @flags:              the bit mask flags to control transforms execution"]
#[doc = "                      (reserved for the future)."]
#[doc = " @flags2:             the bit mask flags to control transforms execution"]
#[doc = "                      (reserved for the future)."]
#[doc = " @enabledUris:        the allowed transform data source uri types."]
#[doc = " @enabledTransforms:  the list of enabled transforms; if list is empty (default)"]
#[doc = "                      then all registered transforms are enabled."]
#[doc = " @preExecCallback:    the callback called after preparing transform chain"]
#[doc = "                      and right before actual data processing; application"]
#[doc = "                      can use this callback to change transforms parameters,"]
#[doc = "                      insert additional transforms in the chain or do"]
#[doc = "                      additional validation (and abort transform execution"]
#[doc = "                      if needed)."]
#[doc = " @result:             the pointer to transforms result buffer."]
#[doc = " @status:             the transforms chain processing status."]
#[doc = " @uri:                the data source URI without xpointer expression."]
#[doc = " @xptrExpr:           the xpointer expression from data source URI (if any)."]
#[doc = " @first:              the first transform in the chain."]
#[doc = " @last:               the last transform in the chain."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The transform execution context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecTransformCtx {
    pub userData: *mut ::std::os::raw::c_void,
    pub flags: ::std::os::raw::c_uint,
    pub flags2: ::std::os::raw::c_uint,
    pub enabledUris: xmlSecTransformUriType,
    pub enabledTransforms: xmlSecPtrList,
    pub preExecCallback: xmlSecTransformCtxPreExecuteCallback,
    pub result: xmlSecBufferPtr,
    pub status: xmlSecTransformStatus,
    pub uri: *mut xmlChar,
    pub xptrExpr: *mut xmlChar,
    pub first: xmlSecTransformPtr,
    pub last: xmlSecTransformPtr,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSecTransformCtx() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecTransformCtx>(),
        136usize,
        concat!("Size of: ", stringify!(_xmlSecTransformCtx))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecTransformCtx>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecTransformCtx))
    );
    fn test_field_userData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userData) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformCtx),
                "::",
                stringify!(userData)
            )
        );
    }
    test_field_userData();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformCtx),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_flags2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags2) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformCtx),
                "::",
                stringify!(flags2)
            )
        );
    }
    test_field_flags2();
    fn test_field_enabledUris() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enabledUris) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformCtx),
                "::",
                stringify!(enabledUris)
            )
        );
    }
    test_field_enabledUris();
    fn test_field_enabledTransforms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enabledTransforms) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformCtx),
                "::",
                stringify!(enabledTransforms)
            )
        );
    }
    test_field_enabledTransforms();
    fn test_field_preExecCallback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preExecCallback) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformCtx),
                "::",
                stringify!(preExecCallback)
            )
        );
    }
    test_field_preExecCallback();
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformCtx),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformCtx),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_uri() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uri) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformCtx),
                "::",
                stringify!(uri)
            )
        );
    }
    test_field_uri();
    fn test_field_xptrExpr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xptrExpr) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformCtx),
                "::",
                stringify!(xptrExpr)
            )
        );
    }
    test_field_xptrExpr();
    fn test_field_first() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).first) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformCtx),
                "::",
                stringify!(first)
            )
        );
    }
    test_field_first();
    fn test_field_last() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformCtx),
                "::",
                stringify!(last)
            )
        );
    }
    test_field_last();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformCtx),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformCtx),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
extern "C" {
    pub fn xmlSecTransformCtxCreate() -> xmlSecTransformCtxPtr;
}
extern "C" {
    pub fn xmlSecTransformCtxDestroy(ctx: xmlSecTransformCtxPtr);
}
extern "C" {
    pub fn xmlSecTransformCtxInitialize(ctx: xmlSecTransformCtxPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformCtxFinalize(ctx: xmlSecTransformCtxPtr);
}
extern "C" {
    pub fn xmlSecTransformCtxReset(ctx: xmlSecTransformCtxPtr);
}
extern "C" {
    pub fn xmlSecTransformCtxCopyUserPref(
        dst: xmlSecTransformCtxPtr,
        src: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformCtxSetUri(
        ctx: xmlSecTransformCtxPtr,
        uri: *const xmlChar,
        hereNode: xmlNodePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformCtxAppend(
        ctx: xmlSecTransformCtxPtr,
        transform: xmlSecTransformPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformCtxPrepend(
        ctx: xmlSecTransformCtxPtr,
        transform: xmlSecTransformPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformCtxCreateAndAppend(
        ctx: xmlSecTransformCtxPtr,
        id: xmlSecTransformId,
    ) -> xmlSecTransformPtr;
}
extern "C" {
    pub fn xmlSecTransformCtxCreateAndPrepend(
        ctx: xmlSecTransformCtxPtr,
        id: xmlSecTransformId,
    ) -> xmlSecTransformPtr;
}
extern "C" {
    pub fn xmlSecTransformCtxNodeRead(
        ctx: xmlSecTransformCtxPtr,
        node: xmlNodePtr,
        usage: xmlSecTransformUsage,
    ) -> xmlSecTransformPtr;
}
extern "C" {
    pub fn xmlSecTransformCtxNodesListRead(
        ctx: xmlSecTransformCtxPtr,
        node: xmlNodePtr,
        usage: xmlSecTransformUsage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformCtxPrepare(
        ctx: xmlSecTransformCtxPtr,
        inputDataType: xmlSecTransformDataType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformCtxBinaryExecute(
        ctx: xmlSecTransformCtxPtr,
        data: *const ::std::os::raw::c_uchar,
        dataSize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformCtxUriExecute(
        ctx: xmlSecTransformCtxPtr,
        uri: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformCtxXmlExecute(
        ctx: xmlSecTransformCtxPtr,
        nodes: xmlSecNodeSetPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformCtxExecute(
        ctx: xmlSecTransformCtxPtr,
        doc: xmlDocPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformCtxDebugDump(ctx: xmlSecTransformCtxPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecTransformCtxDebugXmlDump(ctx: xmlSecTransformCtxPtr, output: *mut FILE);
}
#[doc = " xmlSecTransform"]
#[doc = ""]
#[doc = " xmlSecTransform:"]
#[doc = " @id:                 the transform id (pointer to #xmlSecTransformId)."]
#[doc = " @operation:          the transform's operation."]
#[doc = " @status:             the current status."]
#[doc = " @hereNode:           the pointer to transform's <dsig:Transform /> node."]
#[doc = " @next:               the pointer to next transform in the chain."]
#[doc = " @prev:               the pointer to previous transform in the chain."]
#[doc = " @inBuf:              the input binary data buffer."]
#[doc = " @outBuf:             the output binary data buffer."]
#[doc = " @inNodes:            the input XML nodes."]
#[doc = " @outNodes:           the output XML nodes."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The transform structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecTransform {
    pub id: xmlSecTransformId,
    pub operation: xmlSecTransformOperation,
    pub status: xmlSecTransformStatus,
    pub hereNode: xmlNodePtr,
    pub next: xmlSecTransformPtr,
    pub prev: xmlSecTransformPtr,
    pub inBuf: xmlSecBuffer,
    pub outBuf: xmlSecBuffer,
    pub inNodes: xmlSecNodeSetPtr,
    pub outNodes: xmlSecNodeSetPtr,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSecTransform() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecTransform>(),
        136usize,
        concat!("Size of: ", stringify!(_xmlSecTransform))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecTransform>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecTransform))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransform>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransform),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_operation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransform>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransform),
                "::",
                stringify!(operation)
            )
        );
    }
    test_field_operation();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransform>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransform),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_hereNode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransform>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hereNode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransform),
                "::",
                stringify!(hereNode)
            )
        );
    }
    test_field_hereNode();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransform>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransform),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransform>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransform),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_inBuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransform>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inBuf) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransform),
                "::",
                stringify!(inBuf)
            )
        );
    }
    test_field_inBuf();
    fn test_field_outBuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransform>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outBuf) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransform),
                "::",
                stringify!(outBuf)
            )
        );
    }
    test_field_outBuf();
    fn test_field_inNodes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransform>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inNodes) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransform),
                "::",
                stringify!(inNodes)
            )
        );
    }
    test_field_inNodes();
    fn test_field_outNodes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransform>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outNodes) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransform),
                "::",
                stringify!(outNodes)
            )
        );
    }
    test_field_outNodes();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransform>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransform),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransform>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransform),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
extern "C" {
    pub fn xmlSecTransformCreate(id: xmlSecTransformId) -> xmlSecTransformPtr;
}
extern "C" {
    pub fn xmlSecTransformDestroy(transform: xmlSecTransformPtr);
}
extern "C" {
    pub fn xmlSecTransformNodeRead(
        node: xmlNodePtr,
        usage: xmlSecTransformUsage,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> xmlSecTransformPtr;
}
extern "C" {
    pub fn xmlSecTransformPump(
        left: xmlSecTransformPtr,
        right: xmlSecTransformPtr,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformSetKey(
        transform: xmlSecTransformPtr,
        key: xmlSecKeyPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformSetKeyReq(
        transform: xmlSecTransformPtr,
        keyReq: xmlSecKeyReqPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformVerify(
        transform: xmlSecTransformPtr,
        data: *const ::std::os::raw::c_uchar,
        dataSize: size_t,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformVerifyNodeContent(
        transform: xmlSecTransformPtr,
        node: xmlNodePtr,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformGetDataType(
        transform: xmlSecTransformPtr,
        mode: xmlSecTransformMode,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> xmlSecTransformDataType;
}
extern "C" {
    pub fn xmlSecTransformPushBin(
        transform: xmlSecTransformPtr,
        data: *const ::std::os::raw::c_uchar,
        dataSize: size_t,
        final_: ::std::os::raw::c_int,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformPopBin(
        transform: xmlSecTransformPtr,
        data: *mut ::std::os::raw::c_uchar,
        maxDataSize: size_t,
        dataSize: *mut size_t,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformPushXml(
        transform: xmlSecTransformPtr,
        nodes: xmlSecNodeSetPtr,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformPopXml(
        transform: xmlSecTransformPtr,
        nodes: *mut xmlSecNodeSetPtr,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformExecute(
        transform: xmlSecTransformPtr,
        last: ::std::os::raw::c_int,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformDebugDump(transform: xmlSecTransformPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecTransformDebugXmlDump(transform: xmlSecTransformPtr, output: *mut FILE);
}
extern "C" {
    #[doc = " Operations on transforms chain"]
    #[doc = ""]
    pub fn xmlSecTransformConnect(
        left: xmlSecTransformPtr,
        right: xmlSecTransformPtr,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformRemove(transform: xmlSecTransformPtr);
}
extern "C" {
    #[doc = " Default callbacks, most of the transforms can use them"]
    #[doc = ""]
    pub fn xmlSecTransformDefaultGetDataType(
        transform: xmlSecTransformPtr,
        mode: xmlSecTransformMode,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> xmlSecTransformDataType;
}
extern "C" {
    pub fn xmlSecTransformDefaultPushBin(
        transform: xmlSecTransformPtr,
        data: *const ::std::os::raw::c_uchar,
        dataSize: size_t,
        final_: ::std::os::raw::c_int,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformDefaultPopBin(
        transform: xmlSecTransformPtr,
        data: *mut ::std::os::raw::c_uchar,
        maxDataSize: size_t,
        dataSize: *mut size_t,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformDefaultPushXml(
        transform: xmlSecTransformPtr,
        nodes: xmlSecNodeSetPtr,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformDefaultPopXml(
        transform: xmlSecTransformPtr,
        nodes: *mut xmlSecNodeSetPtr,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " IO buffers for transforms"]
    #[doc = ""]
    pub fn xmlSecTransformCreateOutputBuffer(
        transform: xmlSecTransformPtr,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> xmlOutputBufferPtr;
}
extern "C" {
    pub fn xmlSecTransformCreateInputBuffer(
        transform: xmlSecTransformPtr,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> xmlParserInputBufferPtr;
}
#[doc = " Transform Klass"]
#[doc = ""]
#[doc = " xmlSecTransformInitializeMethod:"]
#[doc = " @transform:                  the pointer to transform object."]
#[doc = ""]
#[doc = " The transform specific initialization method."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value otherwise."]
pub type xmlSecTransformInitializeMethod = ::std::option::Option<
    unsafe extern "C" fn(transform: xmlSecTransformPtr) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecTransformFinalizeMethod:"]
#[doc = " @transform:                  the pointer to transform object."]
#[doc = ""]
#[doc = " The transform specific destroy method."]
pub type xmlSecTransformFinalizeMethod =
    ::std::option::Option<unsafe extern "C" fn(transform: xmlSecTransformPtr)>;
#[doc = " xmlSecTransformGetDataTypeMethod:"]
#[doc = " @transform:                  the pointer to transform object."]
#[doc = " @mode:                       the mode."]
#[doc = " @transformCtx:               the pointer to transform context object."]
#[doc = ""]
#[doc = " The transform specific method to query information about transform"]
#[doc = " data type in specified mode @mode."]
#[doc = ""]
#[doc = " Returns: transform data type."]
pub type xmlSecTransformGetDataTypeMethod = ::std::option::Option<
    unsafe extern "C" fn(
        transform: xmlSecTransformPtr,
        mode: xmlSecTransformMode,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> xmlSecTransformDataType,
>;
#[doc = " xmlSecTransformNodeReadMethod:"]
#[doc = " @transform:                  the pointer to transform object."]
#[doc = " @node:                       the pointer to <dsig:Transform/> node."]
#[doc = " @transformCtx:               the pointer to transform context object."]
#[doc = ""]
#[doc = " The transform specific method to read the transform data from"]
#[doc = " the @node."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value otherwise."]
pub type xmlSecTransformNodeReadMethod = ::std::option::Option<
    unsafe extern "C" fn(
        transform: xmlSecTransformPtr,
        node: xmlNodePtr,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecTransformNodeWriteMethod:"]
#[doc = " @transform:                  the pointer to transform object."]
#[doc = " @node:                       the pointer to <dsig:Transform/> node."]
#[doc = " @transformCtx:               the pointer to transform context object."]
#[doc = ""]
#[doc = " The transform specific method to write transform information to an XML node @node."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value otherwise."]
pub type xmlSecTransformNodeWriteMethod = ::std::option::Option<
    unsafe extern "C" fn(
        transform: xmlSecTransformPtr,
        node: xmlNodePtr,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecTransformSetKeyRequirementsMethod:"]
#[doc = " @transform:                  the pointer to transform object."]
#[doc = " @keyReq:                     the pointer to key requirements structure."]
#[doc = ""]
#[doc = " Transform specific method to set transform's key requirements."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value otherwise."]
pub type xmlSecTransformSetKeyRequirementsMethod = ::std::option::Option<
    unsafe extern "C" fn(
        transform: xmlSecTransformPtr,
        keyReq: xmlSecKeyReqPtr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecTransformSetKeyMethod:"]
#[doc = " @transform:                  the pointer to transform object."]
#[doc = " @key:                        the pointer to key."]
#[doc = ""]
#[doc = " The transform specific method to set the key for use."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value otherwise."]
pub type xmlSecTransformSetKeyMethod = ::std::option::Option<
    unsafe extern "C" fn(transform: xmlSecTransformPtr, key: xmlSecKeyPtr) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecTransformVerifyMethod:"]
#[doc = " @transform:                  the pointer to transform object."]
#[doc = " @data:                       the input buffer."]
#[doc = " @dataSize:                   the size of input buffer @data."]
#[doc = " @transformCtx:               the pointer to transform context object."]
#[doc = ""]
#[doc = " The transform specific method to verify transform processing results"]
#[doc = " (used by digest and signature transforms). This method sets @status"]
#[doc = " member of the #xmlSecTransform structure to either #xmlSecTransformStatusOk"]
#[doc = " if verification succeeded or #xmlSecTransformStatusFail otherwise."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value otherwise."]
pub type xmlSecTransformVerifyMethod = ::std::option::Option<
    unsafe extern "C" fn(
        transform: xmlSecTransformPtr,
        data: *const ::std::os::raw::c_uchar,
        dataSize: size_t,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecTransformPushBinMethod:"]
#[doc = " @transform:                  the pointer to transform object."]
#[doc = " @data:                       the input binary data,"]
#[doc = " @dataSize:                   the input data size."]
#[doc = " @final:                      the flag: if set to 1 then it's the last"]
#[doc = "                              data chunk."]
#[doc = " @transformCtx:               the pointer to transform context object."]
#[doc = ""]
#[doc = " The transform specific method to process data from @data and push"]
#[doc = " result to the next transform in the chain."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value otherwise."]
pub type xmlSecTransformPushBinMethod = ::std::option::Option<
    unsafe extern "C" fn(
        transform: xmlSecTransformPtr,
        data: *const ::std::os::raw::c_uchar,
        dataSize: size_t,
        final_: ::std::os::raw::c_int,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecTransformPopBinMethod:"]
#[doc = " @transform:                  the pointer to transform object."]
#[doc = " @data:                       the buffer to store result data."]
#[doc = " @maxDataSize:                the size of the buffer @data."]
#[doc = " @dataSize:                   the pointer to returned data size."]
#[doc = " @transformCtx:               the pointer to transform context object."]
#[doc = ""]
#[doc = " The transform specific method to pop data from previous transform"]
#[doc = " in the chain and return result in the @data buffer. The size of returned"]
#[doc = " data is placed in the @dataSize."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value otherwise."]
pub type xmlSecTransformPopBinMethod = ::std::option::Option<
    unsafe extern "C" fn(
        transform: xmlSecTransformPtr,
        data: *mut ::std::os::raw::c_uchar,
        maxDataSize: size_t,
        dataSize: *mut size_t,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecTransformPushXmlMethod:"]
#[doc = " @transform:                  the pointer to transform object."]
#[doc = " @nodes:                      the input nodes."]
#[doc = " @transformCtx:               the pointer to transform context object."]
#[doc = ""]
#[doc = " The transform specific method to process @nodes and push result to the next"]
#[doc = " transform in the chain."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value otherwise."]
pub type xmlSecTransformPushXmlMethod = ::std::option::Option<
    unsafe extern "C" fn(
        transform: xmlSecTransformPtr,
        nodes: xmlSecNodeSetPtr,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecTransformPopXmlMethod:"]
#[doc = " @transform:                  the pointer to transform object."]
#[doc = " @nodes:                      the pointer to store popinter to result nodes."]
#[doc = " @transformCtx:               the pointer to transform context object."]
#[doc = ""]
#[doc = " The transform specific method to pop data from previous transform in the chain,"]
#[doc = " process the data and return result in @nodes."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value otherwise."]
pub type xmlSecTransformPopXmlMethod = ::std::option::Option<
    unsafe extern "C" fn(
        transform: xmlSecTransformPtr,
        nodes: *mut xmlSecNodeSetPtr,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecTransformExecuteMethod:"]
#[doc = " @transform:                  the pointer to transform object."]
#[doc = " @last:                       the flag: if set to 1 then it's the last data chunk."]
#[doc = " @transformCtx:               the pointer to transform context object."]
#[doc = ""]
#[doc = " Transform specific method to process a chunk of data."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value otherwise."]
pub type xmlSecTransformExecuteMethod = ::std::option::Option<
    unsafe extern "C" fn(
        transform: xmlSecTransformPtr,
        last: ::std::os::raw::c_int,
        transformCtx: xmlSecTransformCtxPtr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlSecTransformKlass:"]
#[doc = " @klassSize:                  the transform klass structure size."]
#[doc = " @objSize:                    the transform object size."]
#[doc = " @name:                       the transform's name."]
#[doc = " @href:                       the transform's identification string (href)."]
#[doc = " @usage:                      the allowed transforms usages."]
#[doc = " @initialize:                 the initialization method."]
#[doc = " @finalize:                   the finalization (destroy) function."]
#[doc = " @readNode:                   the XML node read method."]
#[doc = " @writeNode:                  the XML node write method."]
#[doc = " @setKeyReq:                  the set key requirements method."]
#[doc = " @setKey:                     the set key method."]
#[doc = " @verify:                     the verify method (for digest and signature transforms)."]
#[doc = " @getDataType:                the input/output data type query method."]
#[doc = " @pushBin:                    the binary data \"push thru chain\" processing method."]
#[doc = " @popBin:                     the binary data \"pop from chain\" procesing method."]
#[doc = " @pushXml:                    the XML data \"push thru chain\" processing method."]
#[doc = " @popXml:                     the XML data \"pop from chain\" procesing method."]
#[doc = " @execute:                    the low level data processing method used  by default"]
#[doc = "                              implementations of @pushBin, @popBin, @pushXml and @popXml."]
#[doc = " @reserved0:                  reserved for the future."]
#[doc = " @reserved1:                  reserved for the future."]
#[doc = ""]
#[doc = " The transform klass description structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecTransformKlass {
    pub klassSize: size_t,
    pub objSize: size_t,
    pub name: *const xmlChar,
    pub href: *const xmlChar,
    pub usage: xmlSecTransformUsage,
    pub initialize: xmlSecTransformInitializeMethod,
    pub finalize: xmlSecTransformFinalizeMethod,
    pub readNode: xmlSecTransformNodeReadMethod,
    pub writeNode: xmlSecTransformNodeWriteMethod,
    pub setKeyReq: xmlSecTransformSetKeyRequirementsMethod,
    pub setKey: xmlSecTransformSetKeyMethod,
    pub verify: xmlSecTransformVerifyMethod,
    pub getDataType: xmlSecTransformGetDataTypeMethod,
    pub pushBin: xmlSecTransformPushBinMethod,
    pub popBin: xmlSecTransformPopBinMethod,
    pub pushXml: xmlSecTransformPushXmlMethod,
    pub popXml: xmlSecTransformPopXmlMethod,
    pub execute: xmlSecTransformExecuteMethod,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSecTransformKlass() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecTransformKlass>(),
        160usize,
        concat!("Size of: ", stringify!(_xmlSecTransformKlass))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecTransformKlass>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecTransformKlass))
    );
    fn test_field_klassSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).klassSize) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(klassSize)
            )
        );
    }
    test_field_klassSize();
    fn test_field_objSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objSize) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(objSize)
            )
        );
    }
    test_field_objSize();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_href() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).href) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(href)
            )
        );
    }
    test_field_href();
    fn test_field_usage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(usage)
            )
        );
    }
    test_field_usage();
    fn test_field_initialize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initialize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(initialize)
            )
        );
    }
    test_field_initialize();
    fn test_field_finalize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(finalize)
            )
        );
    }
    test_field_finalize();
    fn test_field_readNode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).readNode) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(readNode)
            )
        );
    }
    test_field_readNode();
    fn test_field_writeNode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).writeNode) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(writeNode)
            )
        );
    }
    test_field_writeNode();
    fn test_field_setKeyReq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).setKeyReq) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(setKeyReq)
            )
        );
    }
    test_field_setKeyReq();
    fn test_field_setKey() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).setKey) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(setKey)
            )
        );
    }
    test_field_setKey();
    fn test_field_verify() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).verify) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(verify)
            )
        );
    }
    test_field_verify();
    fn test_field_getDataType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getDataType) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(getDataType)
            )
        );
    }
    test_field_getDataType();
    fn test_field_pushBin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pushBin) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(pushBin)
            )
        );
    }
    test_field_pushBin();
    fn test_field_popBin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).popBin) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(popBin)
            )
        );
    }
    test_field_popBin();
    fn test_field_pushXml() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pushXml) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(pushXml)
            )
        );
    }
    test_field_pushXml();
    fn test_field_popXml() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).popXml) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(popXml)
            )
        );
    }
    test_field_popXml();
    fn test_field_execute() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).execute) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(execute)
            )
        );
    }
    test_field_execute();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecTransformKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecTransformKlass),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
extern "C" {
    pub fn xmlSecTransformIdListGetKlass() -> xmlSecPtrListId;
}
extern "C" {
    pub fn xmlSecTransformIdListFind(
        list: xmlSecPtrListPtr,
        transformId: xmlSecTransformId,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformIdListFindByHref(
        list: xmlSecPtrListPtr,
        href: *const xmlChar,
        usage: xmlSecTransformUsage,
    ) -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformIdListFindByName(
        list: xmlSecPtrListPtr,
        name: *const xmlChar,
        usage: xmlSecTransformUsage,
    ) -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformIdListDebugDump(list: xmlSecPtrListPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecTransformIdListDebugXmlDump(list: xmlSecPtrListPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecTransformBase64GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformBase64SetLineSize(transform: xmlSecTransformPtr, lineSize: size_t);
}
extern "C" {
    pub fn xmlSecTransformInclC14NGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformInclC14NWithCommentsGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformInclC14N11GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformInclC14N11WithCommentsGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformExclC14NGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformExclC14NWithCommentsGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformEnvelopedGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformXPathGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformXPath2GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformXPointerGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformXPointerSetExpr(
        transform: xmlSecTransformPtr,
        expr: *const xmlChar,
        nodeSetType: xmlSecNodeSetType,
        hereNode: xmlNodePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTransformRelationshipGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformRemoveXmlTagsC14NGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformVisa3DHackGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformVisa3DHackSetID(
        transform: xmlSecTransformPtr,
        id: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " High-level functions"]
    #[doc = ""]
    pub fn xmlSecKeyInfoNodeRead(
        keyInfoNode: xmlNodePtr,
        key: xmlSecKeyPtr,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyInfoNodeWrite(
        keyInfoNode: xmlNodePtr,
        key: xmlSecKeyPtr,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int;
}
pub const xmlSecKeyInfoMode_xmlSecKeyInfoModeRead: xmlSecKeyInfoMode = 0;
pub const xmlSecKeyInfoMode_xmlSecKeyInfoModeWrite: xmlSecKeyInfoMode = 1;
#[doc = " xmlSecKeyInfoMode:"]
#[doc = " @xmlSecKeyInfoModeRead: read <dsig:KeyInfo /> element."]
#[doc = " @xmlSecKeyInfoModeWrite: write <dsig:KeyInfo /> element."]
#[doc = ""]
#[doc = " The @xmlSecKeyInfoCtx operation mode (read or write)."]
pub type xmlSecKeyInfoMode = ::std::os::raw::c_int;
#[doc = " xmlSecKeyInfoCtx:"]
#[doc = " @userData:           the pointer to user data (xmlsec and xmlsec-crypto"]
#[doc = "                      never touch this)."]
#[doc = " @flags:              the bit mask for flags that control processin."]
#[doc = " @flags2:             reserved for future."]
#[doc = " @mode:               do we read or write <dsig:KeyInfo /> element."]
#[doc = " @keysMngr:           the pointer to current keys manager."]
#[doc = " @enabledKeyData:     the list of enabled @xmlSecKeyDataId (if list is"]
#[doc = "                      empty then all data ids are enabled)."]
#[doc = " @base64LineSize:     the max columns size for base64 encoding."]
#[doc = " @retrievalMethodCtx: the transforms context for <dsig:RetrievalMethod />"]
#[doc = "                      element processing."]
#[doc = " @maxRetrievalMethodLevel: the max recursion level when processing"]
#[doc = "                      <dsig:RetrievalMethod /> element; default level is 1"]
#[doc = "                      (see also @curRetrievalMethodLevel)."]
#[doc = " @encCtx:             the encryption context for <dsig:EncryptedKey /> element"]
#[doc = "                      processing."]
#[doc = " @maxEncryptedKeyLevel: the max recursion level when processing"]
#[doc = "                      <enc:EncryptedKey /> element; default level is 1"]
#[doc = "                      (see @curEncryptedKeyLevel)."]
#[doc = " @certsVerificationTime: the time to use for X509 certificates verification"]
#[doc = "                      (\"not valid before\" and \"not valid after\" checks);"]
#[doc = "                      if @certsVerificationTime is equal to 0 (default)"]
#[doc = "                      then we verify certificates against the system's"]
#[doc = "                      clock \"now\"."]
#[doc = " @certsVerificationDepth: the max certifications chain length (default is 9)."]
#[doc = " @pgpReserved:        reserved for PGP."]
#[doc = " @curRetrievalMethodLevel: the current <dsig:RetrievalMethod /> element"]
#[doc = "                      processing level (see @maxRetrievalMethodLevel)."]
#[doc = " @curEncryptedKeyLevel: the current <enc:EncryptedKey /> element"]
#[doc = "                      processing level (see @maxEncryptedKeyLevel)."]
#[doc = " @keyReq:             the current key requirements."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The <dsig:KeyInfo /> reading or writing context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecKeyInfoCtx {
    pub userData: *mut ::std::os::raw::c_void,
    pub flags: ::std::os::raw::c_uint,
    pub flags2: ::std::os::raw::c_uint,
    pub keysMngr: xmlSecKeysMngrPtr,
    pub mode: xmlSecKeyInfoMode,
    pub enabledKeyData: xmlSecPtrList,
    pub base64LineSize: ::std::os::raw::c_int,
    pub retrievalMethodCtx: xmlSecTransformCtx,
    pub maxRetrievalMethodLevel: ::std::os::raw::c_int,
    pub encCtx: xmlSecEncCtxPtr,
    pub maxEncryptedKeyLevel: ::std::os::raw::c_int,
    pub certsVerificationTime: time_t,
    pub certsVerificationDepth: ::std::os::raw::c_int,
    pub pgpReserved: *mut ::std::os::raw::c_void,
    pub curRetrievalMethodLevel: ::std::os::raw::c_int,
    pub curEncryptedKeyLevel: ::std::os::raw::c_int,
    pub keyReq: xmlSecKeyReq,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSecKeyInfoCtx() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecKeyInfoCtx>(),
        368usize,
        concat!("Size of: ", stringify!(_xmlSecKeyInfoCtx))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecKeyInfoCtx>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecKeyInfoCtx))
    );
    fn test_field_userData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userData) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(userData)
            )
        );
    }
    test_field_userData();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_flags2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags2) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(flags2)
            )
        );
    }
    test_field_flags2();
    fn test_field_keysMngr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keysMngr) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(keysMngr)
            )
        );
    }
    test_field_keysMngr();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_enabledKeyData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enabledKeyData) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(enabledKeyData)
            )
        );
    }
    test_field_enabledKeyData();
    fn test_field_base64LineSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base64LineSize) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(base64LineSize)
            )
        );
    }
    test_field_base64LineSize();
    fn test_field_retrievalMethodCtx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).retrievalMethodCtx) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(retrievalMethodCtx)
            )
        );
    }
    test_field_retrievalMethodCtx();
    fn test_field_maxRetrievalMethodLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxRetrievalMethodLevel) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(maxRetrievalMethodLevel)
            )
        );
    }
    test_field_maxRetrievalMethodLevel();
    fn test_field_encCtx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).encCtx) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(encCtx)
            )
        );
    }
    test_field_encCtx();
    fn test_field_maxEncryptedKeyLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxEncryptedKeyLevel) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(maxEncryptedKeyLevel)
            )
        );
    }
    test_field_maxEncryptedKeyLevel();
    fn test_field_certsVerificationTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).certsVerificationTime) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(certsVerificationTime)
            )
        );
    }
    test_field_certsVerificationTime();
    fn test_field_certsVerificationDepth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).certsVerificationDepth) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(certsVerificationDepth)
            )
        );
    }
    test_field_certsVerificationDepth();
    fn test_field_pgpReserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pgpReserved) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(pgpReserved)
            )
        );
    }
    test_field_pgpReserved();
    fn test_field_curRetrievalMethodLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).curRetrievalMethodLevel) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(curRetrievalMethodLevel)
            )
        );
    }
    test_field_curRetrievalMethodLevel();
    fn test_field_curEncryptedKeyLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).curEncryptedKeyLevel) as usize - ptr as usize
            },
            268usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(curEncryptedKeyLevel)
            )
        );
    }
    test_field_curEncryptedKeyLevel();
    fn test_field_keyReq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyReq) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(keyReq)
            )
        );
    }
    test_field_keyReq();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyInfoCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyInfoCtx),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
extern "C" {
    pub fn xmlSecKeyInfoCtxCreate(keysMngr: xmlSecKeysMngrPtr) -> xmlSecKeyInfoCtxPtr;
}
extern "C" {
    pub fn xmlSecKeyInfoCtxDestroy(keyInfoCtx: xmlSecKeyInfoCtxPtr);
}
extern "C" {
    pub fn xmlSecKeyInfoCtxInitialize(
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
        keysMngr: xmlSecKeysMngrPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyInfoCtxFinalize(keyInfoCtx: xmlSecKeyInfoCtxPtr);
}
extern "C" {
    pub fn xmlSecKeyInfoCtxReset(keyInfoCtx: xmlSecKeyInfoCtxPtr);
}
extern "C" {
    pub fn xmlSecKeyInfoCtxCopyUserPref(
        dst: xmlSecKeyInfoCtxPtr,
        src: xmlSecKeyInfoCtxPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyInfoCtxCreateEncCtx(keyInfoCtx: xmlSecKeyInfoCtxPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyInfoCtxDebugDump(keyInfoCtx: xmlSecKeyInfoCtxPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecKeyInfoCtxDebugXmlDump(keyInfoCtx: xmlSecKeyInfoCtxPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecKeyDataNameGetKlass() -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataValueGetKlass() -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataRetrievalMethodGetKlass() -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataEncryptedKeyGetKlass() -> xmlSecKeyDataId;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecKeyKlass {
    _unused: [u8; 0],
}
pub type xmlSecKeyKlass = _xmlSecKeyKlass;
pub type xmlSecKeyId = *const _xmlSecKeyKlass;
#[doc = " xmlSecKeyStoreKlass:"]
#[doc = " @klassSize:          the store klass size."]
#[doc = " @objSize:            the store obj size."]
#[doc = " @name:               the store's name."]
#[doc = " @initialize:         the store's initialization method."]
#[doc = " @finalize:           the store's finalization (destroy) method."]
#[doc = " @findKey:            the store's find method."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The keys store id (klass)."]
pub type xmlSecKeyStoreKlass = _xmlSecKeyStoreKlass;
pub type xmlSecKeyStoreId = *const _xmlSecKeyStoreKlass;
extern "C" {
    #[doc = " Keys Manager"]
    #[doc = ""]
    pub fn xmlSecKeysMngrCreate() -> xmlSecKeysMngrPtr;
}
extern "C" {
    pub fn xmlSecKeysMngrDestroy(mngr: xmlSecKeysMngrPtr);
}
extern "C" {
    pub fn xmlSecKeysMngrFindKey(
        mngr: xmlSecKeysMngrPtr,
        name: *const xmlChar,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> xmlSecKeyPtr;
}
extern "C" {
    pub fn xmlSecKeysMngrAdoptKeysStore(
        mngr: xmlSecKeysMngrPtr,
        store: xmlSecKeyStorePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeysMngrGetKeysStore(mngr: xmlSecKeysMngrPtr) -> xmlSecKeyStorePtr;
}
extern "C" {
    pub fn xmlSecKeysMngrAdoptDataStore(
        mngr: xmlSecKeysMngrPtr,
        store: xmlSecKeyDataStorePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeysMngrGetDataStore(
        mngr: xmlSecKeysMngrPtr,
        id: xmlSecKeyDataStoreId,
    ) -> xmlSecKeyDataStorePtr;
}
#[doc = " xmlSecGetKeyCallback:"]
#[doc = " @keyInfoNode:                the pointer to <dsig:KeyInfo/> node."]
#[doc = " @keyInfoCtx:                 the pointer to <dsig:KeyInfo/> node processing context."]
#[doc = ""]
#[doc = " Reads the <dsig:KeyInfo/> node @keyInfoNode and extracts the key."]
#[doc = ""]
#[doc = " Returns: the pointer to key or NULL if the key is not found or"]
#[doc = " an error occurs."]
pub type xmlSecGetKeyCallback = ::std::option::Option<
    unsafe extern "C" fn(keyInfoNode: xmlNodePtr, keyInfoCtx: xmlSecKeyInfoCtxPtr) -> xmlSecKeyPtr,
>;
#[doc = " xmlSecKeysMngr:"]
#[doc = " @keysStore:                  the key store (list of keys known to keys manager)."]
#[doc = " @storesList:                 the list of key data stores known to keys manager."]
#[doc = " @getKey:                     the callback used to read <dsig:KeyInfo/> node."]
#[doc = ""]
#[doc = " The keys manager structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecKeysMngr {
    pub keysStore: xmlSecKeyStorePtr,
    pub storesList: xmlSecPtrList,
    pub getKey: xmlSecGetKeyCallback,
}
#[test]
fn bindgen_test_layout__xmlSecKeysMngr() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecKeysMngr>(),
        56usize,
        concat!("Size of: ", stringify!(_xmlSecKeysMngr))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecKeysMngr>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecKeysMngr))
    );
    fn test_field_keysStore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeysMngr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keysStore) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeysMngr),
                "::",
                stringify!(keysStore)
            )
        );
    }
    test_field_keysStore();
    fn test_field_storesList() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeysMngr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storesList) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeysMngr),
                "::",
                stringify!(storesList)
            )
        );
    }
    test_field_storesList();
    fn test_field_getKey() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeysMngr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getKey) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeysMngr),
                "::",
                stringify!(getKey)
            )
        );
    }
    test_field_getKey();
}
extern "C" {
    pub fn xmlSecKeysMngrGetKey(
        keyInfoNode: xmlNodePtr,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> xmlSecKeyPtr;
}
#[doc = " xmlSecKeyStore"]
#[doc = ""]
#[doc = " xmlSecKeyStore:"]
#[doc = " @id:                 the store id (#xmlSecKeyStoreId)."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The keys store."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecKeyStore {
    pub id: xmlSecKeyStoreId,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSecKeyStore() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecKeyStore>(),
        24usize,
        concat!("Size of: ", stringify!(_xmlSecKeyStore))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecKeyStore>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecKeyStore))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyStore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyStore),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyStore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyStore),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyStore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyStore),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
extern "C" {
    pub fn xmlSecKeyStoreCreate(id: xmlSecKeyStoreId) -> xmlSecKeyStorePtr;
}
extern "C" {
    pub fn xmlSecKeyStoreDestroy(store: xmlSecKeyStorePtr);
}
extern "C" {
    pub fn xmlSecKeyStoreFindKey(
        store: xmlSecKeyStorePtr,
        name: *const xmlChar,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> xmlSecKeyPtr;
}
#[doc = " xmlSecKeyStoreInitializeMethod:"]
#[doc = " @store:              the store."]
#[doc = ""]
#[doc = " Keys store specific initialization method."]
#[doc = ""]
#[doc = " Returns: 0 on success or a negative value if an error occurs."]
pub type xmlSecKeyStoreInitializeMethod =
    ::std::option::Option<unsafe extern "C" fn(store: xmlSecKeyStorePtr) -> ::std::os::raw::c_int>;
#[doc = " xmlSecKeyStoreFinalizeMethod:"]
#[doc = " @store:              the store."]
#[doc = ""]
#[doc = " Keys store specific finalization (destroy) method."]
pub type xmlSecKeyStoreFinalizeMethod =
    ::std::option::Option<unsafe extern "C" fn(store: xmlSecKeyStorePtr)>;
#[doc = " xmlSecKeyStoreFindKeyMethod:"]
#[doc = " @store:              the store."]
#[doc = " @name:               the desired key name."]
#[doc = " @keyInfoCtx:         the pointer to key info context."]
#[doc = ""]
#[doc = " Keys store specific find method. The caller is responsible for destroying"]
#[doc = " the returned key using #xmlSecKeyDestroy method."]
#[doc = ""]
#[doc = " Returns: the pointer to a key or NULL if key is not found or an error occurs."]
pub type xmlSecKeyStoreFindKeyMethod = ::std::option::Option<
    unsafe extern "C" fn(
        store: xmlSecKeyStorePtr,
        name: *const xmlChar,
        keyInfoCtx: xmlSecKeyInfoCtxPtr,
    ) -> xmlSecKeyPtr,
>;
#[doc = " xmlSecKeyStoreKlass:"]
#[doc = " @klassSize:          the store klass size."]
#[doc = " @objSize:            the store obj size."]
#[doc = " @name:               the store's name."]
#[doc = " @initialize:         the store's initialization method."]
#[doc = " @finalize:           the store's finalization (destroy) method."]
#[doc = " @findKey:            the store's find method."]
#[doc = " @reserved0:          reserved for the future."]
#[doc = " @reserved1:          reserved for the future."]
#[doc = ""]
#[doc = " The keys store id (klass)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecKeyStoreKlass {
    pub klassSize: size_t,
    pub objSize: size_t,
    pub name: *const xmlChar,
    pub initialize: xmlSecKeyStoreInitializeMethod,
    pub finalize: xmlSecKeyStoreFinalizeMethod,
    pub findKey: xmlSecKeyStoreFindKeyMethod,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSecKeyStoreKlass() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecKeyStoreKlass>(),
        64usize,
        concat!("Size of: ", stringify!(_xmlSecKeyStoreKlass))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecKeyStoreKlass>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecKeyStoreKlass))
    );
    fn test_field_klassSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).klassSize) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyStoreKlass),
                "::",
                stringify!(klassSize)
            )
        );
    }
    test_field_klassSize();
    fn test_field_objSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objSize) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyStoreKlass),
                "::",
                stringify!(objSize)
            )
        );
    }
    test_field_objSize();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyStoreKlass),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_initialize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initialize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyStoreKlass),
                "::",
                stringify!(initialize)
            )
        );
    }
    test_field_initialize();
    fn test_field_finalize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyStoreKlass),
                "::",
                stringify!(finalize)
            )
        );
    }
    test_field_finalize();
    fn test_field_findKey() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).findKey) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyStoreKlass),
                "::",
                stringify!(findKey)
            )
        );
    }
    test_field_findKey();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyStoreKlass),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecKeyStoreKlass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecKeyStoreKlass),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
extern "C" {
    pub fn xmlSecSimpleKeysStoreGetKlass() -> xmlSecKeyStoreId;
}
extern "C" {
    pub fn xmlSecSimpleKeysStoreAdoptKey(
        store: xmlSecKeyStorePtr,
        key: xmlSecKeyPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecSimpleKeysStoreLoad(
        store: xmlSecKeyStorePtr,
        uri: *const ::std::os::raw::c_char,
        keysMngr: xmlSecKeysMngrPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecSimpleKeysStoreSave(
        store: xmlSecKeyStorePtr,
        filename: *const ::std::os::raw::c_char,
        type_: xmlSecKeyDataType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecSimpleKeysStoreGetKeys(store: xmlSecKeyStorePtr) -> xmlSecPtrListPtr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecCryptoDLFunctions {
    _unused: [u8; 0],
}
pub type xmlSecCryptoDLFunctions = _xmlSecCryptoDLFunctions;
pub type xmlSecCryptoDLFunctionsPtr = *mut _xmlSecCryptoDLFunctions;
extern "C" {
    pub fn xmlSecCryptoDLFunctionsRegisterKeyDataAndTransforms(
        functions: xmlSecCryptoDLFunctionsPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dynamic load functions"]
    #[doc = ""]
    pub fn xmlSecCryptoDLInit() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoDLShutdown() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoDLLoadLibrary(crypto: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoDLGetLibraryFunctions(crypto: *const xmlChar) -> xmlSecCryptoDLFunctionsPtr;
}
extern "C" {
    pub fn xmlSecCryptoDLUnloadLibrary(crypto: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoDLSetFunctions(
        functions: xmlSecCryptoDLFunctionsPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoDLGetFunctions() -> xmlSecCryptoDLFunctionsPtr;
}
extern "C" {
    #[doc = " Crypto Init/shutdown"]
    #[doc = ""]
    pub fn xmlSecCryptoInit() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoShutdown() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoKeysMngrInit(mngr: xmlSecKeysMngrPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecKeyDataAesGetKlass() -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataDesGetKlass() -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataDsaGetKlass() -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataEcdsaGetKlass() -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataGost2001GetKlass() -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataGostR3410_2012_256GetKlass() -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataGostR3410_2012_512GetKlass() -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataHmacGetKlass() -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataRsaGetKlass() -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataX509GetKlass() -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecKeyDataRawX509CertGetKlass() -> xmlSecKeyDataId;
}
extern "C" {
    pub fn xmlSecX509StoreGetKlass() -> xmlSecKeyDataStoreId;
}
extern "C" {
    pub fn xmlSecTransformAes128CbcGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformAes192CbcGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformAes256CbcGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformAes128GcmGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformAes192GcmGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformAes256GcmGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformKWAes128GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformKWAes192GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformKWAes256GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformDes3CbcGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformKWDes3GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformDsaSha1GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformDsaSha256GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformEcdsaSha1GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformEcdsaSha224GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformEcdsaSha256GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformEcdsaSha384GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformEcdsaSha512GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformGost2001GostR3411_94GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformGostR3410_2012GostR3411_2012_256GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformGostR3410_2012GostR3411_2012_512GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformHmacMd5GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformHmacRipemd160GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformHmacSha1GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformHmacSha224GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformHmacSha256GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformHmacSha384GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformHmacSha512GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformMd5GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformRipemd160GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformRsaMd5GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformRsaRipemd160GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformRsaSha1GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformRsaSha224GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformRsaSha256GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformRsaSha384GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformRsaSha512GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformRsaPkcs1GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformRsaOaepGetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformGostR3411_94GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformGostR3411_2012_256GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformGostR3411_2012_512GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformSha1GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformSha224GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformSha256GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformSha384GetKlass() -> xmlSecTransformId;
}
extern "C" {
    pub fn xmlSecTransformSha512GetKlass() -> xmlSecTransformId;
}
extern "C" {
    #[doc = " High level routines form xmlsec command line utility"]
    #[doc = ""]
    pub fn xmlSecCryptoAppInit(config: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoAppShutdown() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoAppDefaultKeysMngrInit(mngr: xmlSecKeysMngrPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoAppDefaultKeysMngrAdoptKey(
        mngr: xmlSecKeysMngrPtr,
        key: xmlSecKeyPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoAppDefaultKeysMngrLoad(
        mngr: xmlSecKeysMngrPtr,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoAppDefaultKeysMngrSave(
        mngr: xmlSecKeysMngrPtr,
        filename: *const ::std::os::raw::c_char,
        type_: xmlSecKeyDataType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoAppKeysMngrCertLoad(
        mngr: xmlSecKeysMngrPtr,
        filename: *const ::std::os::raw::c_char,
        format: xmlSecKeyDataFormat,
        type_: xmlSecKeyDataType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoAppKeysMngrCertLoadMemory(
        mngr: xmlSecKeysMngrPtr,
        data: *const ::std::os::raw::c_uchar,
        dataSize: size_t,
        format: xmlSecKeyDataFormat,
        type_: xmlSecKeyDataType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoAppKeyLoad(
        filename: *const ::std::os::raw::c_char,
        format: xmlSecKeyDataFormat,
        pwd: *const ::std::os::raw::c_char,
        pwdCallback: *mut ::std::os::raw::c_void,
        pwdCallbackCtx: *mut ::std::os::raw::c_void,
    ) -> xmlSecKeyPtr;
}
extern "C" {
    pub fn xmlSecCryptoAppKeyLoadMemory(
        data: *const ::std::os::raw::c_uchar,
        dataSize: size_t,
        format: xmlSecKeyDataFormat,
        pwd: *const ::std::os::raw::c_char,
        pwdCallback: *mut ::std::os::raw::c_void,
        pwdCallbackCtx: *mut ::std::os::raw::c_void,
    ) -> xmlSecKeyPtr;
}
extern "C" {
    pub fn xmlSecCryptoAppPkcs12Load(
        filename: *const ::std::os::raw::c_char,
        pwd: *const ::std::os::raw::c_char,
        pwdCallback: *mut ::std::os::raw::c_void,
        pwdCallbackCtx: *mut ::std::os::raw::c_void,
    ) -> xmlSecKeyPtr;
}
extern "C" {
    pub fn xmlSecCryptoAppPkcs12LoadMemory(
        data: *const ::std::os::raw::c_uchar,
        dataSize: size_t,
        pwd: *const ::std::os::raw::c_char,
        pwdCallback: *mut ::std::os::raw::c_void,
        pwdCallbackCtx: *mut ::std::os::raw::c_void,
    ) -> xmlSecKeyPtr;
}
extern "C" {
    pub fn xmlSecCryptoAppKeyCertLoad(
        key: xmlSecKeyPtr,
        filename: *const ::std::os::raw::c_char,
        format: xmlSecKeyDataFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoAppKeyCertLoadMemory(
        key: xmlSecKeyPtr,
        data: *const ::std::os::raw::c_uchar,
        dataSize: size_t,
        format: xmlSecKeyDataFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecCryptoAppGetDefaultPwdCallback() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " <dsig:Signature> node"]
    #[doc = ""]
    pub fn xmlSecTmplSignatureCreate(
        doc: xmlDocPtr,
        c14nMethodId: xmlSecTransformId,
        signMethodId: xmlSecTransformId,
        id: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplSignatureCreateNsPref(
        doc: xmlDocPtr,
        c14nMethodId: xmlSecTransformId,
        signMethodId: xmlSecTransformId,
        id: *const xmlChar,
        nsPrefix: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplSignatureEnsureKeyInfo(signNode: xmlNodePtr, id: *const xmlChar)
        -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplSignatureAddReference(
        signNode: xmlNodePtr,
        digestMethodId: xmlSecTransformId,
        id: *const xmlChar,
        uri: *const xmlChar,
        type_: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplSignatureAddObject(
        signNode: xmlNodePtr,
        id: *const xmlChar,
        mimeType: *const xmlChar,
        encoding: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplSignatureGetSignMethodNode(signNode: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplSignatureGetC14NMethodNode(signNode: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplReferenceAddTransform(
        referenceNode: xmlNodePtr,
        transformId: xmlSecTransformId,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplObjectAddSignProperties(
        objectNode: xmlNodePtr,
        id: *const xmlChar,
        target: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplObjectAddManifest(objectNode: xmlNodePtr, id: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplManifestAddReference(
        manifestNode: xmlNodePtr,
        digestMethodId: xmlSecTransformId,
        id: *const xmlChar,
        uri: *const xmlChar,
        type_: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    #[doc = " <enc:EncryptedData> node"]
    #[doc = ""]
    pub fn xmlSecTmplEncDataCreate(
        doc: xmlDocPtr,
        encMethodId: xmlSecTransformId,
        id: *const xmlChar,
        type_: *const xmlChar,
        mimeType: *const xmlChar,
        encoding: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplEncDataEnsureKeyInfo(encNode: xmlNodePtr, id: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplEncDataEnsureEncProperties(
        encNode: xmlNodePtr,
        id: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplEncDataAddEncProperty(
        encNode: xmlNodePtr,
        id: *const xmlChar,
        target: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplEncDataEnsureCipherValue(encNode: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplEncDataEnsureCipherReference(
        encNode: xmlNodePtr,
        uri: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplEncDataGetEncMethodNode(encNode: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplCipherReferenceAddTransform(
        cipherReferenceNode: xmlNodePtr,
        transformId: xmlSecTransformId,
    ) -> xmlNodePtr;
}
extern "C" {
    #[doc = " <enc:EncryptedKey> node"]
    #[doc = ""]
    pub fn xmlSecTmplReferenceListAddDataReference(
        encNode: xmlNodePtr,
        uri: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplReferenceListAddKeyReference(
        encNode: xmlNodePtr,
        uri: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    #[doc = " <dsig:KeyInfo> node"]
    #[doc = ""]
    pub fn xmlSecTmplKeyInfoAddKeyName(keyInfoNode: xmlNodePtr, name: *const xmlChar)
        -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplKeyInfoAddKeyValue(keyInfoNode: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplKeyInfoAddX509Data(keyInfoNode: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplKeyInfoAddRetrievalMethod(
        keyInfoNode: xmlNodePtr,
        uri: *const xmlChar,
        type_: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplRetrievalMethodAddTransform(
        retrMethodNode: xmlNodePtr,
        transformId: xmlSecTransformId,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplKeyInfoAddEncryptedKey(
        keyInfoNode: xmlNodePtr,
        encMethodId: xmlSecTransformId,
        id: *const xmlChar,
        type_: *const xmlChar,
        recipient: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    #[doc = " <dsig:X509Data> node"]
    #[doc = ""]
    pub fn xmlSecTmplX509DataAddIssuerSerial(x509DataNode: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplX509IssuerSerialAddIssuerName(
        x509IssuerSerialNode: xmlNodePtr,
        issuerName: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplX509IssuerSerialAddSerialNumber(
        x509IssuerSerialNode: xmlNodePtr,
        serial: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplX509DataAddSubjectName(x509DataNode: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplX509DataAddSKI(x509DataNode: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplX509DataAddCertificate(x509DataNode: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecTmplX509DataAddCRL(x509DataNode: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    #[doc = " <dsig:Transform> node"]
    #[doc = ""]
    pub fn xmlSecTmplTransformAddHmacOutputLength(
        transformNode: xmlNodePtr,
        bitsLen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTmplTransformAddRsaOaepParam(
        transformNode: xmlNodePtr,
        buf: *const ::std::os::raw::c_uchar,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTmplTransformAddXsltStylesheet(
        transformNode: xmlNodePtr,
        xslt: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTmplTransformAddC14NInclNamespaces(
        transformNode: xmlNodePtr,
        prefixList: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTmplTransformAddXPath(
        transformNode: xmlNodePtr,
        expression: *const xmlChar,
        nsList: *mut *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTmplTransformAddXPath2(
        transformNode: xmlNodePtr,
        type_: *const xmlChar,
        expression: *const xmlChar,
        nsList: *mut *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecTmplTransformAddXPointer(
        transformNode: xmlNodePtr,
        expression: *const xmlChar,
        nsList: *mut *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
#[doc = " xmlSecDSigReferenceCtx:"]
#[doc = " @userData:                   the pointer to user data (xmlsec and xmlsec-crypto libraries"]
#[doc = "                              never touches this)."]
#[doc = " @dsigCtx:                    the pointer to \"parent\" <dsig:Signature/> processing context."]
#[doc = " @origin:                     the signature origin (<dsig:SignedInfo/> or <dsig:Manifest/>)."]
#[doc = " @transformCtx:               the reference processing transforms context."]
#[doc = " @digestMethod:               the pointer to digest transform."]
#[doc = " @result:                     the pointer to digest result."]
#[doc = " @status:                     the reference processing status."]
#[doc = " @preDigestMemBufMethod:      the pointer to binary buffer right before digest"]
#[doc = "                              (valid only if either"]
#[doc = "                              #XMLSEC_DSIG_FLAGS_STORE_SIGNEDINFO_REFERENCES or"]
#[doc = "                              #XMLSEC_DSIG_FLAGS_STORE_MANIFEST_REFERENCES flags are set)."]
#[doc = " @id:                         the <dsig:Reference/> node ID attribute."]
#[doc = " @uri:                        the <dsig:Reference/> node URI attribute."]
#[doc = " @type:                       the <dsig:Reference/> node Type attribute."]
#[doc = " @reserved0:                  reserved for the future."]
#[doc = " @reserved1:                  reserved for the future."]
#[doc = ""]
#[doc = " The <dsig:Reference/> processing context."]
pub type xmlSecDSigReferenceCtx = _xmlSecDSigReferenceCtx;
pub type xmlSecDSigReferenceCtxPtr = *mut _xmlSecDSigReferenceCtx;
pub const xmlSecDSigStatus_xmlSecDSigStatusUnknown: xmlSecDSigStatus = 0;
pub const xmlSecDSigStatus_xmlSecDSigStatusSucceeded: xmlSecDSigStatus = 1;
pub const xmlSecDSigStatus_xmlSecDSigStatusInvalid: xmlSecDSigStatus = 2;
#[doc = " xmlSecDSigStatus:"]
#[doc = " @xmlSecDSigStatusUnknown:    the status is unknown."]
#[doc = " @xmlSecDSigStatusSucceeded:  the processing succeeded."]
#[doc = " @xmlSecDSigStatusInvalid:    the processing failed."]
#[doc = ""]
#[doc = " XML Digital signature processing status."]
pub type xmlSecDSigStatus = ::std::os::raw::c_int;
#[doc = " xmlSecDSigCtx:"]
#[doc = " @userData:                   the pointer to user data (xmlsec and xmlsec-crypto libraries"]
#[doc = "                              never touches this)."]
#[doc = " @flags:                      the XML Digital Signature processing flags."]
#[doc = " @flags2:                     the XML Digital Signature processing flags."]
#[doc = " @keyInfoReadCtx:             the reading key context."]
#[doc = " @keyInfoWriteCtx:            the writing key context (not used for signature verification)."]
#[doc = " @transformCtx:               the <dsig:SignedInfo/> node processing context."]
#[doc = " @enabledReferenceUris:       the URI types allowed for <dsig:Reference/> node."]
#[doc = " @enabledReferenceTransforms: the list of transforms allowed in <dsig:Reference/> node."]
#[doc = " @referencePreExecuteCallback:the callback for <dsig:Reference/> node processing."]
#[doc = " @defSignMethodId:            the default signing method klass."]
#[doc = " @defC14NMethodId:            the default c14n method klass."]
#[doc = " @defDigestMethodId:          the default digest method klass."]
#[doc = " @signKey:                    the signature key; application may set #signKey"]
#[doc = "                              before calling #xmlSecDSigCtxSign or #xmlSecDSigCtxVerify"]
#[doc = "                              functions."]
#[doc = " @operation:                  the operation: sign or verify."]
#[doc = " @result:                     the pointer to signature (not valid for signature verification)."]
#[doc = " @status:                     the <dsig:Signature/> processing status."]
#[doc = " @signMethod:                 the pointer to signature transform."]
#[doc = " @c14nMethod:                 the pointer to c14n transform."]
#[doc = " @preSignMemBufMethod:        the pointer to binary buffer right before signature"]
#[doc = "                              (valid only if #XMLSEC_DSIG_FLAGS_STORE_SIGNATURE flag is set)."]
#[doc = " @signValueNode:              the pointer to <dsig:SignatureValue/> node."]
#[doc = " @id:                         the pointer to Id attribute of <dsig:Signature/> node."]
#[doc = " @signedInfoReferences:       the list of references in <dsig:SignedInfo/> node."]
#[doc = " @manifestReferences:         the list of references in <dsig:Manifest/> nodes."]
#[doc = " @reserved0:                  reserved for the future."]
#[doc = " @reserved1:                  reserved for the future."]
#[doc = ""]
#[doc = " XML DSig processing context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecDSigCtx {
    pub userData: *mut ::std::os::raw::c_void,
    pub flags: ::std::os::raw::c_uint,
    pub flags2: ::std::os::raw::c_uint,
    pub keyInfoReadCtx: xmlSecKeyInfoCtx,
    pub keyInfoWriteCtx: xmlSecKeyInfoCtx,
    pub transformCtx: xmlSecTransformCtx,
    pub enabledReferenceUris: xmlSecTransformUriType,
    pub enabledReferenceTransforms: xmlSecPtrListPtr,
    pub referencePreExecuteCallback: xmlSecTransformCtxPreExecuteCallback,
    pub defSignMethodId: xmlSecTransformId,
    pub defC14NMethodId: xmlSecTransformId,
    pub defDigestMethodId: xmlSecTransformId,
    pub signKey: xmlSecKeyPtr,
    pub operation: xmlSecTransformOperation,
    pub result: xmlSecBufferPtr,
    pub status: xmlSecDSigStatus,
    pub signMethod: xmlSecTransformPtr,
    pub c14nMethod: xmlSecTransformPtr,
    pub preSignMemBufMethod: xmlSecTransformPtr,
    pub signValueNode: xmlNodePtr,
    pub id: *mut xmlChar,
    pub signedInfoReferences: xmlSecPtrList,
    pub manifestReferences: xmlSecPtrList,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSecDSigCtx() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecDSigCtx>(),
        1104usize,
        concat!("Size of: ", stringify!(_xmlSecDSigCtx))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecDSigCtx>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecDSigCtx))
    );
    fn test_field_userData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userData) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(userData)
            )
        );
    }
    test_field_userData();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_flags2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags2) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(flags2)
            )
        );
    }
    test_field_flags2();
    fn test_field_keyInfoReadCtx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyInfoReadCtx) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(keyInfoReadCtx)
            )
        );
    }
    test_field_keyInfoReadCtx();
    fn test_field_keyInfoWriteCtx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyInfoWriteCtx) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(keyInfoWriteCtx)
            )
        );
    }
    test_field_keyInfoWriteCtx();
    fn test_field_transformCtx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformCtx) as usize - ptr as usize
            },
            752usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(transformCtx)
            )
        );
    }
    test_field_transformCtx();
    fn test_field_enabledReferenceUris() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enabledReferenceUris) as usize - ptr as usize
            },
            888usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(enabledReferenceUris)
            )
        );
    }
    test_field_enabledReferenceUris();
    fn test_field_enabledReferenceTransforms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enabledReferenceTransforms) as usize - ptr as usize
            },
            896usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(enabledReferenceTransforms)
            )
        );
    }
    test_field_enabledReferenceTransforms();
    fn test_field_referencePreExecuteCallback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).referencePreExecuteCallback) as usize - ptr as usize
            },
            904usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(referencePreExecuteCallback)
            )
        );
    }
    test_field_referencePreExecuteCallback();
    fn test_field_defSignMethodId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defSignMethodId) as usize - ptr as usize
            },
            912usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(defSignMethodId)
            )
        );
    }
    test_field_defSignMethodId();
    fn test_field_defC14NMethodId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defC14NMethodId) as usize - ptr as usize
            },
            920usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(defC14NMethodId)
            )
        );
    }
    test_field_defC14NMethodId();
    fn test_field_defDigestMethodId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defDigestMethodId) as usize - ptr as usize
            },
            928usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(defDigestMethodId)
            )
        );
    }
    test_field_defDigestMethodId();
    fn test_field_signKey() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signKey) as usize - ptr as usize
            },
            936usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(signKey)
            )
        );
    }
    test_field_signKey();
    fn test_field_operation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize
            },
            944usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(operation)
            )
        );
    }
    test_field_operation();
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            952usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            960usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_signMethod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signMethod) as usize - ptr as usize
            },
            968usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(signMethod)
            )
        );
    }
    test_field_signMethod();
    fn test_field_c14nMethod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c14nMethod) as usize - ptr as usize
            },
            976usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(c14nMethod)
            )
        );
    }
    test_field_c14nMethod();
    fn test_field_preSignMemBufMethod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preSignMemBufMethod) as usize - ptr as usize
            },
            984usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(preSignMemBufMethod)
            )
        );
    }
    test_field_preSignMemBufMethod();
    fn test_field_signValueNode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signValueNode) as usize - ptr as usize
            },
            992usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(signValueNode)
            )
        );
    }
    test_field_signValueNode();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            1000usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_signedInfoReferences() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signedInfoReferences) as usize - ptr as usize
            },
            1008usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(signedInfoReferences)
            )
        );
    }
    test_field_signedInfoReferences();
    fn test_field_manifestReferences() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).manifestReferences) as usize - ptr as usize
            },
            1048usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(manifestReferences)
            )
        );
    }
    test_field_manifestReferences();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            1088usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            1096usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigCtx),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
extern "C" {
    pub fn xmlSecDSigCtxCreate(keysMngr: xmlSecKeysMngrPtr) -> xmlSecDSigCtxPtr;
}
extern "C" {
    pub fn xmlSecDSigCtxDestroy(dsigCtx: xmlSecDSigCtxPtr);
}
extern "C" {
    pub fn xmlSecDSigCtxInitialize(
        dsigCtx: xmlSecDSigCtxPtr,
        keysMngr: xmlSecKeysMngrPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecDSigCtxFinalize(dsigCtx: xmlSecDSigCtxPtr);
}
extern "C" {
    pub fn xmlSecDSigCtxSign(dsigCtx: xmlSecDSigCtxPtr, tmpl: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecDSigCtxVerify(
        dsigCtx: xmlSecDSigCtxPtr,
        node: xmlNodePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecDSigCtxEnableReferenceTransform(
        dsigCtx: xmlSecDSigCtxPtr,
        transformId: xmlSecTransformId,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecDSigCtxEnableSignatureTransform(
        dsigCtx: xmlSecDSigCtxPtr,
        transformId: xmlSecTransformId,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecDSigCtxGetPreSignBuffer(dsigCtx: xmlSecDSigCtxPtr) -> xmlSecBufferPtr;
}
extern "C" {
    pub fn xmlSecDSigCtxDebugDump(dsigCtx: xmlSecDSigCtxPtr, output: *mut FILE);
}
extern "C" {
    pub fn xmlSecDSigCtxDebugXmlDump(dsigCtx: xmlSecDSigCtxPtr, output: *mut FILE);
}
pub const xmlSecDSigReferenceOrigin_xmlSecDSigReferenceOriginSignedInfo: xmlSecDSigReferenceOrigin =
    0;
pub const xmlSecDSigReferenceOrigin_xmlSecDSigReferenceOriginManifest: xmlSecDSigReferenceOrigin =
    1;
#[doc = " xmlSecDSigReferenceCtx"]
#[doc = ""]
#[doc = " xmlSecDSigReferenceOrigin:"]
#[doc = " @xmlSecDSigReferenceOriginSignedInfo:reference in <dsig:SignedInfo> node."]
#[doc = " @xmlSecDSigReferenceOriginManifest:  reference <dsig:Manifest> node."]
#[doc = ""]
#[doc = " The possible <dsig:Reference/> node locations: in the <dsig:SignedInfo/>"]
#[doc = " node or in the <dsig:Manifest/> node."]
pub type xmlSecDSigReferenceOrigin = ::std::os::raw::c_int;
#[doc = " xmlSecDSigReferenceCtx:"]
#[doc = " @userData:                   the pointer to user data (xmlsec and xmlsec-crypto libraries"]
#[doc = "                              never touches this)."]
#[doc = " @dsigCtx:                    the pointer to \"parent\" <dsig:Signature/> processing context."]
#[doc = " @origin:                     the signature origin (<dsig:SignedInfo/> or <dsig:Manifest/>)."]
#[doc = " @transformCtx:               the reference processing transforms context."]
#[doc = " @digestMethod:               the pointer to digest transform."]
#[doc = " @result:                     the pointer to digest result."]
#[doc = " @status:                     the reference processing status."]
#[doc = " @preDigestMemBufMethod:      the pointer to binary buffer right before digest"]
#[doc = "                              (valid only if either"]
#[doc = "                              #XMLSEC_DSIG_FLAGS_STORE_SIGNEDINFO_REFERENCES or"]
#[doc = "                              #XMLSEC_DSIG_FLAGS_STORE_MANIFEST_REFERENCES flags are set)."]
#[doc = " @id:                         the <dsig:Reference/> node ID attribute."]
#[doc = " @uri:                        the <dsig:Reference/> node URI attribute."]
#[doc = " @type:                       the <dsig:Reference/> node Type attribute."]
#[doc = " @reserved0:                  reserved for the future."]
#[doc = " @reserved1:                  reserved for the future."]
#[doc = ""]
#[doc = " The <dsig:Reference/> processing context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecDSigReferenceCtx {
    pub userData: *mut ::std::os::raw::c_void,
    pub dsigCtx: xmlSecDSigCtxPtr,
    pub origin: xmlSecDSigReferenceOrigin,
    pub transformCtx: xmlSecTransformCtx,
    pub digestMethod: xmlSecTransformPtr,
    pub result: xmlSecBufferPtr,
    pub status: xmlSecDSigStatus,
    pub preDigestMemBufMethod: xmlSecTransformPtr,
    pub id: *mut xmlChar,
    pub uri: *mut xmlChar,
    pub type_: *mut xmlChar,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSecDSigReferenceCtx() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecDSigReferenceCtx>(),
        232usize,
        concat!("Size of: ", stringify!(_xmlSecDSigReferenceCtx))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecDSigReferenceCtx>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecDSigReferenceCtx))
    );
    fn test_field_userData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigReferenceCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userData) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigReferenceCtx),
                "::",
                stringify!(userData)
            )
        );
    }
    test_field_userData();
    fn test_field_dsigCtx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigReferenceCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dsigCtx) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigReferenceCtx),
                "::",
                stringify!(dsigCtx)
            )
        );
    }
    test_field_dsigCtx();
    fn test_field_origin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigReferenceCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).origin) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigReferenceCtx),
                "::",
                stringify!(origin)
            )
        );
    }
    test_field_origin();
    fn test_field_transformCtx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigReferenceCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformCtx) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigReferenceCtx),
                "::",
                stringify!(transformCtx)
            )
        );
    }
    test_field_transformCtx();
    fn test_field_digestMethod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigReferenceCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).digestMethod) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigReferenceCtx),
                "::",
                stringify!(digestMethod)
            )
        );
    }
    test_field_digestMethod();
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigReferenceCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigReferenceCtx),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigReferenceCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigReferenceCtx),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_preDigestMemBufMethod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigReferenceCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preDigestMemBufMethod) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigReferenceCtx),
                "::",
                stringify!(preDigestMemBufMethod)
            )
        );
    }
    test_field_preDigestMemBufMethod();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigReferenceCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigReferenceCtx),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_uri() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigReferenceCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uri) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigReferenceCtx),
                "::",
                stringify!(uri)
            )
        );
    }
    test_field_uri();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigReferenceCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigReferenceCtx),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigReferenceCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigReferenceCtx),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecDSigReferenceCtx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecDSigReferenceCtx),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
extern "C" {
    pub fn xmlSecDSigReferenceCtxCreate(
        dsigCtx: xmlSecDSigCtxPtr,
        origin: xmlSecDSigReferenceOrigin,
    ) -> xmlSecDSigReferenceCtxPtr;
}
extern "C" {
    pub fn xmlSecDSigReferenceCtxDestroy(dsigRefCtx: xmlSecDSigReferenceCtxPtr);
}
extern "C" {
    pub fn xmlSecDSigReferenceCtxInitialize(
        dsigRefCtx: xmlSecDSigReferenceCtxPtr,
        dsigCtx: xmlSecDSigCtxPtr,
        origin: xmlSecDSigReferenceOrigin,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecDSigReferenceCtxFinalize(dsigRefCtx: xmlSecDSigReferenceCtxPtr);
}
extern "C" {
    pub fn xmlSecDSigReferenceCtxProcessNode(
        dsigRefCtx: xmlSecDSigReferenceCtxPtr,
        node: xmlNodePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecDSigReferenceCtxGetPreDigestBuffer(
        dsigRefCtx: xmlSecDSigReferenceCtxPtr,
    ) -> xmlSecBufferPtr;
}
extern "C" {
    pub fn xmlSecDSigReferenceCtxDebugDump(
        dsigRefCtx: xmlSecDSigReferenceCtxPtr,
        output: *mut FILE,
    );
}
extern "C" {
    pub fn xmlSecDSigReferenceCtxDebugXmlDump(
        dsigRefCtx: xmlSecDSigReferenceCtxPtr,
        output: *mut FILE,
    );
}
extern "C" {
    pub fn xmlSecDSigReferenceCtxListGetKlass() -> xmlSecPtrListId;
}
extern "C" {
    pub fn xmlSecGetDefaultLineFeed() -> *const xmlChar;
}
extern "C" {
    pub fn xmlSecSetDefaultLineFeed(linefeed: *const xmlChar);
}
extern "C" {
    pub fn xmlSecGetNodeNsHref(cur: xmlNodePtr) -> *const xmlChar;
}
extern "C" {
    pub fn xmlSecCheckNodeName(
        cur: xmlNodePtr,
        name: *const xmlChar,
        ns: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecGetNextElementNode(cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecFindSibling(
        cur: xmlNodePtr,
        name: *const xmlChar,
        ns: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecFindChild(
        parent: xmlNodePtr,
        name: *const xmlChar,
        ns: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecFindParent(
        cur: xmlNodePtr,
        name: *const xmlChar,
        ns: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecFindNode(
        parent: xmlNodePtr,
        name: *const xmlChar,
        ns: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecAddChild(
        parent: xmlNodePtr,
        name: *const xmlChar,
        ns: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecEnsureEmptyChild(
        parent: xmlNodePtr,
        name: *const xmlChar,
        ns: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecAddChildNode(parent: xmlNodePtr, child: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecAddNextSibling(
        node: xmlNodePtr,
        name: *const xmlChar,
        ns: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecAddPrevSibling(
        node: xmlNodePtr,
        name: *const xmlChar,
        ns: *const xmlChar,
    ) -> xmlNodePtr;
}
extern "C" {
    pub fn xmlSecReplaceNode(node: xmlNodePtr, newNode: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecReplaceNodeAndReturn(
        node: xmlNodePtr,
        newNode: xmlNodePtr,
        replaced: *mut xmlNodePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecReplaceContent(node: xmlNodePtr, newNode: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecReplaceContentAndReturn(
        node: xmlNodePtr,
        newNode: xmlNodePtr,
        replaced: *mut xmlNodePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecReplaceNodeBuffer(
        node: xmlNodePtr,
        buffer: *const ::std::os::raw::c_uchar,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecReplaceNodeBufferAndReturn(
        node: xmlNodePtr,
        buffer: *const ::std::os::raw::c_uchar,
        size: size_t,
        replaced: *mut xmlNodePtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecNodeEncodeAndSetContent(
        node: xmlNodePtr,
        buffer: *const xmlChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecAddIDs(doc: xmlDocPtr, cur: xmlNodePtr, ids: *mut *const xmlChar);
}
extern "C" {
    pub fn xmlSecCreateTree(rootNodeName: *const xmlChar, rootNodeNs: *const xmlChar) -> xmlDocPtr;
}
extern "C" {
    pub fn xmlSecIsEmptyNode(node: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecIsEmptyString(str_: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecGetQName(
        node: xmlNodePtr,
        href: *const xmlChar,
        local: *const xmlChar,
    ) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlSecPrintXmlString(fd: *mut FILE, str_: *const xmlChar) -> ::std::os::raw::c_int;
}
#[doc = " xmlSecQName2IntegerInfo:"]
#[doc = " @qnameHref:          the QName href"]
#[doc = " @qnameLocalPart:     the QName local"]
#[doc = " @intValue:           the integer value"]
#[doc = ""]
#[doc = " QName <-> Integer conversion definition."]
pub type xmlSecQName2IntegerInfo = _xmlSecQName2IntegerInfo;
#[doc = " xmlSecQName2IntegerInfo:"]
#[doc = " @qnameHref:          the QName href"]
#[doc = " @qnameLocalPart:     the QName local"]
#[doc = " @intValue:           the integer value"]
#[doc = ""]
#[doc = " QName <-> Integer conversion definition."]
pub type xmlSecQName2IntegerInfoPtr = *mut _xmlSecQName2IntegerInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecQName2IntegerInfo {
    pub qnameHref: *const xmlChar,
    pub qnameLocalPart: *const xmlChar,
    pub intValue: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlSecQName2IntegerInfo() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecQName2IntegerInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_xmlSecQName2IntegerInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecQName2IntegerInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecQName2IntegerInfo))
    );
    fn test_field_qnameHref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecQName2IntegerInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qnameHref) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecQName2IntegerInfo),
                "::",
                stringify!(qnameHref)
            )
        );
    }
    test_field_qnameHref();
    fn test_field_qnameLocalPart() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecQName2IntegerInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qnameLocalPart) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecQName2IntegerInfo),
                "::",
                stringify!(qnameLocalPart)
            )
        );
    }
    test_field_qnameLocalPart();
    fn test_field_intValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecQName2IntegerInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).intValue) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecQName2IntegerInfo),
                "::",
                stringify!(intValue)
            )
        );
    }
    test_field_intValue();
}
#[doc = " xmlSecQName2IntegerInfoConstPtr:"]
#[doc = ""]
#[doc = " Pointer to constant QName <-> Integer conversion definition."]
pub type xmlSecQName2IntegerInfoConstPtr = *const xmlSecQName2IntegerInfo;
extern "C" {
    pub fn xmlSecQName2IntegerGetInfo(
        info: xmlSecQName2IntegerInfoConstPtr,
        intValue: ::std::os::raw::c_int,
    ) -> xmlSecQName2IntegerInfoConstPtr;
}
extern "C" {
    pub fn xmlSecQName2IntegerGetInteger(
        info: xmlSecQName2IntegerInfoConstPtr,
        qnameHref: *const xmlChar,
        qnameLocalPart: *const xmlChar,
        intValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecQName2IntegerGetIntegerFromString(
        info: xmlSecQName2IntegerInfoConstPtr,
        node: xmlNodePtr,
        qname: *const xmlChar,
        intValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecQName2IntegerGetStringFromInteger(
        info: xmlSecQName2IntegerInfoConstPtr,
        node: xmlNodePtr,
        intValue: ::std::os::raw::c_int,
    ) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlSecQName2IntegerNodeRead(
        info: xmlSecQName2IntegerInfoConstPtr,
        node: xmlNodePtr,
        intValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecQName2IntegerNodeWrite(
        info: xmlSecQName2IntegerInfoConstPtr,
        node: xmlNodePtr,
        nodeName: *const xmlChar,
        nodeNs: *const xmlChar,
        intValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecQName2IntegerAttributeRead(
        info: xmlSecQName2IntegerInfoConstPtr,
        node: xmlNodePtr,
        attrName: *const xmlChar,
        intValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecQName2IntegerAttributeWrite(
        info: xmlSecQName2IntegerInfoConstPtr,
        node: xmlNodePtr,
        attrName: *const xmlChar,
        intValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecQName2IntegerDebugDump(
        info: xmlSecQName2IntegerInfoConstPtr,
        intValue: ::std::os::raw::c_int,
        name: *const xmlChar,
        output: *mut FILE,
    );
}
extern "C" {
    pub fn xmlSecQName2IntegerDebugXmlDump(
        info: xmlSecQName2IntegerInfoConstPtr,
        intValue: ::std::os::raw::c_int,
        name: *const xmlChar,
        output: *mut FILE,
    );
}
#[doc = " xmlSecBitMask:"]
#[doc = ""]
#[doc = " Bitmask datatype."]
pub type xmlSecBitMask = ::std::os::raw::c_uint;
#[doc = " xmlSecQName2BitMaskInfo:"]
#[doc = " @qnameHref:          the QName href"]
#[doc = " @qnameLocalPart:     the QName local"]
#[doc = " @mask:               the bitmask value"]
#[doc = ""]
#[doc = " QName <-> Bitmask conversion definition."]
pub type xmlSecQName2BitMaskInfo = _xmlSecQName2BitMaskInfo;
#[doc = " xmlSecQName2BitMaskInfo:"]
#[doc = " @qnameHref:          the QName href"]
#[doc = " @qnameLocalPart:     the QName local"]
#[doc = " @mask:               the bitmask value"]
#[doc = ""]
#[doc = " QName <-> Bitmask conversion definition."]
pub type xmlSecQName2BitMaskInfoPtr = *mut _xmlSecQName2BitMaskInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSecQName2BitMaskInfo {
    pub qnameHref: *const xmlChar,
    pub qnameLocalPart: *const xmlChar,
    pub mask: xmlSecBitMask,
}
#[test]
fn bindgen_test_layout__xmlSecQName2BitMaskInfo() {
    assert_eq!(
        ::std::mem::size_of::<_xmlSecQName2BitMaskInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_xmlSecQName2BitMaskInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmlSecQName2BitMaskInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_xmlSecQName2BitMaskInfo))
    );
    fn test_field_qnameHref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecQName2BitMaskInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qnameHref) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecQName2BitMaskInfo),
                "::",
                stringify!(qnameHref)
            )
        );
    }
    test_field_qnameHref();
    fn test_field_qnameLocalPart() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecQName2BitMaskInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qnameLocalPart) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecQName2BitMaskInfo),
                "::",
                stringify!(qnameLocalPart)
            )
        );
    }
    test_field_qnameLocalPart();
    fn test_field_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_xmlSecQName2BitMaskInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_xmlSecQName2BitMaskInfo),
                "::",
                stringify!(mask)
            )
        );
    }
    test_field_mask();
}
#[doc = " xmlSecQName2BitMaskInfoConstPtr:"]
#[doc = ""]
#[doc = " Pointer to constant QName <-> Bitmask conversion definition."]
pub type xmlSecQName2BitMaskInfoConstPtr = *const xmlSecQName2BitMaskInfo;
extern "C" {
    pub fn xmlSecQName2BitMaskGetInfo(
        info: xmlSecQName2BitMaskInfoConstPtr,
        mask: xmlSecBitMask,
    ) -> xmlSecQName2BitMaskInfoConstPtr;
}
extern "C" {
    pub fn xmlSecQName2BitMaskGetBitMask(
        info: xmlSecQName2BitMaskInfoConstPtr,
        qnameLocalPart: *const xmlChar,
        qnameHref: *const xmlChar,
        mask: *mut xmlSecBitMask,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecQName2BitMaskNodesRead(
        info: xmlSecQName2BitMaskInfoConstPtr,
        node: *mut xmlNodePtr,
        nodeName: *const xmlChar,
        nodeNs: *const xmlChar,
        stopOnUnknown: ::std::os::raw::c_int,
        mask: *mut xmlSecBitMask,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecQName2BitMaskGetBitMaskFromString(
        info: xmlSecQName2BitMaskInfoConstPtr,
        node: xmlNodePtr,
        qname: *const xmlChar,
        mask: *mut xmlSecBitMask,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecQName2BitMaskGetStringFromBitMask(
        info: xmlSecQName2BitMaskInfoConstPtr,
        node: xmlNodePtr,
        mask: xmlSecBitMask,
    ) -> *mut xmlChar;
}
extern "C" {
    pub fn xmlSecQName2BitMaskNodesWrite(
        info: xmlSecQName2BitMaskInfoConstPtr,
        node: xmlNodePtr,
        nodeName: *const xmlChar,
        nodeNs: *const xmlChar,
        mask: xmlSecBitMask,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xmlSecQName2BitMaskDebugDump(
        info: xmlSecQName2BitMaskInfoConstPtr,
        mask: xmlSecBitMask,
        name: *const xmlChar,
        output: *mut FILE,
    );
}
extern "C" {
    pub fn xmlSecQName2BitMaskDebugXmlDump(
        info: xmlSecQName2BitMaskInfoConstPtr,
        mask: xmlSecBitMask,
        name: *const xmlChar,
        output: *mut FILE,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
